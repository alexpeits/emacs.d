#+EXCLUDE_TAGS: TOC
# #+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup
#+EXPORT_FILE_NAME: docs/index.html
* Table of contents                                                     :TOC:
- [[#variables-and-path][Variables and PATH]]
- [[#package-management][Package management]]
- [[#various-utility-functions][Various utility functions]]
- [[#various-configurations][Various configurations]]
  - [[#emacs-ui--editing][emacs UI & editing]]
  - [[#auth][auth]]
  - [[#server][server]]
  - [[#fast-recompile-minor-mode][fast recompile minor mode]]
  - [[#smartparens][Smartparens]]
  - [[#documentation--help][Documentation & help]]
  - [[#jumping-etc][Jumping etc]]
  - [[#autocompleting-etc][Autocompleting etc]]
  - [[#engine-mode][engine-mode]]
  - [[#anzu][anzu]]
  - [[#math-input][math input]]
  - [[#recentf][recentf]]
  - [[#info-mode][info mode]]
  - [[#hi-lock--symbol-overlay][hi-lock & symbol overlay]]
  - [[#alignment][alignment]]
  - [[#highlight-keywords-in-some-modes][highlight keywords in some modes]]
  - [[#temp-project-roots][temp project roots]]
  - [[#edit-indirect][edit indirect]]
- [[#term-eshell-and-comint-mode][Term, eshell and comint-mode]]
  - [[#terms][Terms]]
  - [[#eshell][eshell]]
- [[#ui][UI]]
  - [[#highlight-trailing-whitespace][highlight trailing whitespace]]
- [[#theme][Theme]]
- [[#font][Font]]
- [[#vcs][VCS]]
  - [[#vc][vc]]
  - [[#magit][Magit]]
  - [[#git-timemachine][git-timemachine]]
  - [[#diff-hl][Diff-hl]]
  - [[#helpers][Helpers]]
- [[#keybindings][Keybindings]]
  - [[#keybind-to-command-mapping][keybind to command mapping]]
  - [[#setup-keybindings][setup keybindings]]
- [[#evil-mode][Evil-mode]]
  - [[#evil-mode-setup][evil-mode setup]]
  - [[#evil-packages-that-can-be-used-without-evil-mode][evil packages that can be used without evil-mode]]
- [[#hybrid-input-mode][Hybrid input mode]]
- [[#spell-checking][Spell checking]]
- [[#nix][nix]]
- [[#direnv][direnv]]
- [[#haskell][Haskell]]
- [[#purescript][Purescript]]
- [[#python][Python]]
- [[#jstshtmlcss][js/ts/html/css]]
- [[#lisps][Lisps]]
  - [[#all-lisps][all lisps]]
  - [[#emacs-lisp][emacs lisp]]
- [[#coq-proof-general][Coq (proof-general)]]
- [[#markdown][Markdown]]
- [[#other-prog-modes][Other prog modes]]
  - [[#idris][Idris]]
  - [[#agda][Agda]]
  - [[#rust][Rust]]
  - [[#cc][c/c++]]
  - [[#dhall][dhall]]
  - [[#bazel][bazel]]
  - [[#nginx][nginx]]
  - [[#terraform][terraform]]
  - [[#docker][docker]]
  - [[#elasticsearch][elasticsearch]]
  - [[#json][json]]
  - [[#yaml][yaml]]
  - [[#asciidoc][asciidoc]]
  - [[#restructuredtext][reStructuredText]]
- [[#other-major-modes][Other major modes]]
  - [[#deft][deft]]
  - [[#elfeed][elfeed]]
  - [[#pdf-tools][pdf tools]]
  - [[#erc][erc]]
  - [[#restclient][restclient]]
  - [[#ledger][ledger]]
- [[#searching][Searching]]
  - [[#isearch][isearch]]
  - [[#rg][rg]]
- [[#company][Company]]
- [[#flycheck][Flycheck]]
- [[#projectile][Projectile]]
- [[#ivycounselswiper][Ivy/Counsel/Swiper]]
- [[#yasnippet][Yasnippet]]
- [[#other-window-management][Other window management]]
  - [[#dired][Dired]]
  - [[#ibuffer][ibuffer]]
  - [[#avy][Avy]]
  - [[#ace-window][Ace-window]]
  - [[#buffer-move][buffer-move]]
  - [[#zoom][zoom]]
- [[#modeline][Modeline]]
  - [[#regular-modeline][Regular modeline]]
  - [[#selected-window--focused-frame][Selected window & focused frame]]
  - [[#experimental-new-modeline][Experimental new modeline]]
  - [[#powerline][Powerline]]
- [[#org-mode][Org-mode]]
- [[#setup][Setup]]
  - [[#per-workstation-setup][Per-workstation setup]]
  - [[#performance][Performance]]
  - [[#global-setup][Global setup]]

* Variables and PATH

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (expand-file-name (concat user-emacs-directory "lisp")))
(add-to-list 'custom-theme-load-path
             (expand-file-name (concat user-emacs-directory "custom-themes/")))

(setq user-full-name "Alex Peitsinis"
      user-mail-address "alexpeitsinis@gmail.com")

(dolist (pth '(
               "/usr/local/bin"
               "~/bin"
               "~/.local/bin"
               "~/.ghcup/bin"
               ))
  (add-to-list 'exec-path (expand-file-name pth))
  (setenv "PATH" (concat (expand-file-name pth)
                         path-separator
                         (getenv "PATH"))))

(defvar my/dropbox-dir (expand-file-name "~/Dropbox/emacs/")
  "Private directory synced with dropbox")

(defvar is-mac (eq system-type 'darwin)
  "Whether emacs is running in mac or not")

(defvar is-gui (display-graphic-p)
  "Whether emacs is running in gui mode or not")

(defvar is-term (not is-gui)
  "Whether emacs is running in a terminal or not")
#+END_SRC

* Package management

#+BEGIN_SRC emacs-lisp
(require 'package)
(add-to-list 'package-archives
             '("melpa" . "https://melpa.org/packages/")
             '("MELPA Stable" . "https://stable.melpa.org/packages/"))
(when (< emacs-major-version 24)
  ;; For important compatibility libraries like cl-lib
  (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/")))

;; Some sort of emacs bug workaround
(when (= emacs-major-version 26)
  (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3"))

;; activate installed packages
(package-initialize)
;; (setq package-enable-at-startup nil)
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

;; Can be used to debug slow packages
;; (setq use-package-minimum-reported-time 0.05
;;       use-package-verbose t)

(eval-when-compile
  (require 'use-package))

(if (< emacs-major-version 27)
    (require 'cl))
(use-package diminish :ensure t)

;; `dash' is used in various places
(use-package dash :ensure t)
#+END_SRC

* Various utility functions

#+BEGIN_SRC emacs-lisp
(defmacro comment (&rest body)
  "Comment out one or more s-expressions."
  nil)

(defmacro my/add-hooks (hooks &rest body)
  `(dolist (hook ,hooks)
     (add-hook hook (lambda () ,@body))))

(defmacro my/execute-f-with-hook (f winf)
  `(lambda (&rest args)
     (interactive)
     (,winf)
     (apply (quote ,f) args)))

(defmacro my/control-function-window-split (f height width)
  `(lambda (&rest args)
     (interactive)
     (let ((split-height-threshold ,height)
           (split-width-threshold ,width))
       (apply (quote ,f) args))))

(defmacro my/case-prefix-arg (without-arg with-arg)
  `(lambda (arg)
     (interactive "P")
     (if arg
         (call-interactively (quote ,with-arg))
       (call-interactively (quote ,without-arg)))))

;; what it says
(defun my/revert-all-buffers (also-git)
  "Refresh all open file buffers without confirmation.

Buffers in modified \(not yet saved) state in EMACS will not be reverted. They
will be reverted though if they were modified outside EMACS. Buffers visiting
files which do not exist any more or are no longer readable will be killed.

With prefix argument ALSO-GIT, refresh the git state as well \(branch status on
modeline)."
  (interactive "P")
  (dolist (buf (buffer-list))
    (let ((filename (buffer-file-name buf)))
      ;; Revert only buffers containing files, which are not modified;
      ;; do not try to revert non-file buffers like *Messages*.
      (when (and filename
                 (not (buffer-modified-p buf)))
        (if (file-readable-p filename)
            ;; If the file exists and is readable, revert the buffer.
            (with-current-buffer buf
              (revert-buffer :ignore-auto :noconfirm :preserve-modes)
              (when also-git (vc-refresh-state)))
          ;; Otherwise, kill the buffer.
          (let (kill-buffer-query-functions) ; No query done when killing buffer
            (kill-buffer buf)
            (message "Killed non-existing/unreadable file buffer: %s" filename))))))
  (let ((msg-end (if also-git ", and their git state." ".")))
    (message
     (format "Finished reverting buffers containing unmodified files%s" msg-end))))

(defalias 'rb  'revert-buffer)
(defalias 'rab 'my/revert-all-buffers)

;; read file lines into a list
(defun my/read-file-into-list (file-path)
  "Return a list of lines of a file at `file-path'."
  (with-temp-buffer
    (insert-file-contents file-path)
    (split-string (buffer-string) "\n" t)))

(defun my/indent-region-or-buffer ()
  "Indent a region if selected, otherwise the whole buffer."
  (interactive)
  (save-excursion
    (if (region-active-p)
        (progn
          (indent-region (region-beginning) (region-end))
          (message "Indented selected region."))
      (progn
        (indent-region (point-min) (point-max))
        (message "Indented buffer.")))))

(global-set-key (kbd "C-M-\\") #'my/indent-region-or-buffer)

(defun my/line-length (&optional line)
  "Length of the Nth line."
  (let ((ln (if line line (line-number-at-pos))))
    (save-excursion
      (goto-char (point-min))
      (if (zerop (forward-line (1- ln)))
          (- (line-end-position)
             (line-beginning-position))
        0))))

(defun my/format-region-or-buffer (cmd &rest args)
  (interactive)
  (let ((buf (current-buffer))
        (cur-point (point))
        (cur-line (line-number-at-pos))
        (cur-col (current-column))
        (cur-rel-line (- (line-number-at-pos) (line-number-at-pos (window-start)))))
    (with-current-buffer (get-buffer-create "*codefmt*")
      (erase-buffer)
      (insert-buffer-substring buf)
      (if (zerop (apply 'call-process-region `(,(point-min) ,(point-max) ,cmd t (t nil) nil ,@args)))
          (progn
            (if (not (string= (buffer-string) (with-current-buffer buf (buffer-string))))
                (copy-to-buffer buf (point-min) (point-max)))
            (kill-buffer))
        (error (format "%s failed, see *codefmt* for details" cmd))))
    (goto-line cur-line)
    (when (< cur-col (my/line-length cur-line))
      (forward-char cur-col))
    (recenter cur-rel-line)
    (message (format "Formatted with %s" cmd))))

(defun my/format-and-save (cmd &rest args)
  (interactive)
  (apply 'my/format-region-or-buffer `(,cmd ,@args))
  (save-buffer))

(defvar my/select-a-major-mode-last-selected nil)
(defun my/select-a-major-mode ()
  "Interactively select a major mode and return it as a string."
  (let* ((def (or
               my/select-a-major-mode-last-selected
               (symbol-name initial-major-mode)))
         (choice (completing-read "major mode: "
                                  (apropos-internal "-mode$")
                                  nil nil nil nil
                                  def)))
    (setq my/select-a-major-mode-last-selected choice)))

(defun my/create-scratch-buffer-with-mode (other-window)
  "Create a new scratch buffer and select major mode to use.
With a prefix argument, open the buffer using `switch-to-buffer-other-window'."
  (interactive "P")
  (let* ((mmode (my/select-a-major-mode))
         (buf (generate-new-buffer (concat "*scratch" "-" mmode "*")))
         (switch-func (if other-window 'switch-to-buffer-other-window 'switch-to-buffer)))
    (funcall switch-func buf)
    (funcall (intern mmode))
    (setq buffer-offer-save nil)))

;; https://www.reddit.com/r/emacs/comments/ac9gsf/question_emacs_way_of_using_windows/
(defun my/window-dedicated (&optional window)
  "Toggle the dedicated flag on a window."
  (interactive)
  (let* ((window (or window (selected-window)))
         (dedicated (not (window-dedicated-p window))))
    (when (called-interactively-p)
      (message (format "%s %sdedicated"
                       (buffer-name (window-buffer window))
                       (if dedicated "" "un"))))
    (set-window-dedicated-p window dedicated)
    dedicated))

(defun my/window-fixed (&optional window)
  "Make a window non-resizable."
  (interactive)
  (let* ((window (or window (selected-window)))
         (new-status (with-selected-window window (not window-size-fixed))))
    (when (called-interactively-p)
      (message (format "%s %sfixed"
                       (buffer-name (window-buffer window))
                       (if new-status "" "un"))))
    (with-selected-window window
      (setq window-size-fixed new-status))
    new-status))

(defun my/copy-file-path (include-line-number)
  (interactive "P")
  (let* ((full-fp (buffer-file-name))
         (prefix (read-directory-name "prefix to strip: " (projectile-project-root)))
         (suffix (if include-line-number (format ":%s" (number-to-string (line-number-at-pos))) ""))
         (fp (concat (string-remove-prefix prefix full-fp) suffix))
         )
    (kill-new fp)
    (message fp)
    t))

(defvar my/useful-files
  '(
    ;; haskell
    "package.yaml"
    "stack.yaml"
    "shell.nix"
    ".hlint.yaml"
    ;; docker
    "docker-compose.yml"
    "Dockerfile"
    ;; bazel
    "BUILD.bazel"
    ;; git
    "README.md"
    ;; emacs
    ".dir-locals.el"))

(defun my/try-open-dominating-file (file)
  "Search up the file path of current file a file named FILE, and open it if it
exists.

If FILE is not provided, prompt for the filename.
With a prefix argument, open using `find-file-other-window'."
  (interactive (list (completing-read "File name: "
                                      my/useful-files
                                      nil nil nil nil nil)))
  (let ((dir (locate-dominating-file (buffer-file-name) file))
        (find-file-func (if current-prefix-arg 'find-file-other-window 'find-file)))
    (if dir
        (funcall find-file-func (concat (file-name-as-directory dir) file))
      (message "No matching file found"))))

(defun my/line-numbers (arg)
  (interactive "P")
  (if (< emacs-major-version 26)
      (call-interactively 'linum-mode)
    (if display-line-numbers
        (setq display-line-numbers nil)
      (if arg
          (setq display-line-numbers 'relative)
        (setq display-line-numbers t)))))

(defun my/shell-command-on-buffer-or-region (cmd)
  (save-excursion
    (unless (region-active-p)
      (mark-whole-buffer))
    (shell-command-on-region (region-beginning)
                             (region-end)
                             cmd
                             nil
                             t)))
#+END_SRC

* Various configurations
** emacs UI & editing

#+BEGIN_SRC emacs-lisp
;; remember last position
(use-package saveplace
  :hook (after-init . save-place-mode))

;; undo tree
(use-package undo-tree
  :ensure t
  :bind ("C-x u" . undo-tree-visualize)
  :diminish undo-tree-mode
  :hook (after-init . global-undo-tree-mode)
  :init
  (setq undo-tree-visualizer-relative-timestamps t
        undo-tree-visualizer-diff t))

;; use column width 80 to fill (e.g. with `M-q'/`gq')
(setq-default fill-column 80)
(defun my/set-mode-fill-width (mode-hook width)
  (add-hook mode-hook `(lambda () (setq fill-column ,width))))

(use-package autorevert
  :hook (after-init . global-auto-revert-mode)
  :diminish auto-revert-mode
  :init
  (setq auto-revert-verbose nil))

(use-package eldoc :diminish eldoc-mode)

(use-package files
  :init
  ;; store all backup and autosave files in
  ;; one dir
  (setq backup-directory-alist
        `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t))))

;; only with this set to nil can org-mode export & open too
;; ... but it also breaks some stuff so it's disabled
;; (setq process-connection-type nil)

;; yesss
(defalias 'yes-or-no-p #'y-or-n-p)

;; Always confirm before closing because I'm stupid
(add-hook
 'kill-emacs-query-functions
 (lambda () (y-or-n-p "Do you really want to exit Emacs? "))
 'append)

;; use spaces
(setq-default indent-tabs-mode nil)

;; always scroll to the end of compilation buffers
;; (setq compilation-scroll-output t)

;; vim-like scrolling (emacs=0)
(setq scroll-conservatively 101)

;; Supress "ad-handle-definition: x got redefined" warnings
(setq ad-redefinition-action 'accept)

;; smooth mouse scrolling
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)) ;; one line at a time
      mouse-wheel-progressive-speed t ;; don't accelerate scrolling
      mouse-wheel-follow-mouse 't) ;; scroll window under mouse

;; turn off because it causes delays in some modes (e.g. coq-mode)
;; TODO: not sure if this makes a difference
(setq smie-blink-matching-inners nil)
;; (setq blink-matching-paren nil)

;; who in their right mind ends sentences with 2 spaces?
(setq sentence-end-double-space nil)

;; always trim whitespace before saving
;; (add-hook 'before-save-hook 'delete-trailing-whitespace)
(defalias 'dw 'delete-trailing-whitespace)

;; some keymaps
(global-set-key (kbd "M-o") 'other-window)
(global-set-key (kbd "C-c j") 'previous-buffer)
(global-set-key (kbd "C-c k") 'next-buffer)
;; I use that to switch to Greek layout
(global-set-key (kbd "M-SPC") nil)
;; Bind M-\ to just-one-space instead of delete-horizontal-space
(global-set-key (kbd "M-\\") 'just-one-space)
;; used in help
(define-key 'help-command (kbd "C-l") 'find-library)
(define-key 'help-command (kbd "C-k") 'find-function-on-key)
(define-key 'help-command (kbd "C-f") 'find-function)
(define-key 'help-command (kbd "C-p") 'find-function-at-point)
(define-key 'help-command (kbd "C-v") 'find-variable)
;; proper count-words keybinding
(global-set-key (kbd "M-=") 'count-words)

;; commenting TODO: use newcomment
(global-set-key (kbd "C-;") 'comment-indent)
(global-set-key (kbd "C-:") 'comment-kill)

;; add env files to conf-mode alist
(add-to-list 'auto-mode-alist '(".env\\'" . conf-mode))
(add-to-list 'auto-mode-alist '(".env.local\\'" . conf-mode))
(add-to-list 'auto-mode-alist '("env\\.example\\'" . conf-mode))

;; DocView
(setq doc-view-continuous t)

;; shr (html rendering)
(make-variable-buffer-local 'shr-width)

(use-package expand-region
  :ensure t
  :bind (("C-=" . er/expand-region)
         ("C-M-=" . er/contract-region)))

(use-package misc
  :bind ("M-Z" . zap-up-to-char))

(use-package subword
  :diminish subword-mode
  :commands (subword-mode)
  :init
  (defadvice subword-mode
      (after advice-for-subword-mode activate)
    (setq evil-symbol-word-search subword-mode)))

(use-package outline
  :ensure t
  :defer t
  :bind (:map outline-minor-mode-map
              ("<tab>" . outline-toggle-children))
  :diminish outline-minor-mode)

(use-package outshine
  :ensure t
  :after outline
  :bind (:map outline-minor-mode-map
              ("<S-iso-lefttab>" . outshine-cycle-buffer))
  :commands (outshine-mode))

(use-package rainbow-mode
  :ensure t
  :commands (rainbow-mode))

(use-package rainbow-delimiters
  :ensure t
  :commands (rainbow-delimiters-mode))
#+END_SRC

** auth

#+BEGIN_SRC emacs-lisp
(use-package auth-source
  :config
  (add-to-list 'auth-sources (concat my/dropbox-dir "authinfo.gpg")))
#+END_SRC

** server

#+BEGIN_SRC emacs-lisp
(use-package server
  :init
  ;; don't kill buffers in server sessions
  (setq server-kill-new-buffers nil))
#+END_SRC

** fast recompile minor mode

#+BEGIN_SRC emacs-lisp
(defvar my/fast-recompile-mode-map (make-sparse-keymap))

(define-minor-mode my/fast-recompile-mode
  "Minor mode for fast recompilation using C-c C-c"
  :lighter " rc"
  :global t
  :keymap my/fast-recompile-mode-map
  (if my/fast-recompile-mode
      (progn
        (put 'my/-old-compilation-ask-about-save 'state compilation-ask-about-save)
        (setq compilation-ask-about-save nil))
    (setq compilation-ask-about-save (get 'my/-old-compilation-ask-about-save 'state))))

(define-key my/fast-recompile-mode-map (kbd "C-c C-c") #'recompile)
#+END_SRC

** Smartparens

#+BEGIN_SRC emacs-lisp
(use-package smartparens-config
  :after smartparens
  :config
  ;; don't create a pair with single quote in minibuffer
  (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)

  ;; because DataKinds
  ;;(with-eval-after-load 'haskell-mode
  ;;  (sp-local-pair 'haskell-mode "'" nil :actions nil))

  ;; indent after inserting any kinds of parens
  (defun my/smartparens-pair-newline-and-indent (id action context)
    (save-excursion
      (newline)
      (indent-according-to-mode))
    (indent-according-to-mode))
  (sp-pair "(" nil :post-handlers
           '(:add (my/smartparens-pair-newline-and-indent "RET")))
  (sp-pair "{" nil :post-handlers
           '(:add (my/smartparens-pair-newline-and-indent "RET")))
  (sp-pair "[" nil :post-handlers
           '(:add (my/smartparens-pair-newline-and-indent "RET")))
  )

(use-package smartparens
  :ensure t
  :hook (after-init . show-smartparens-global-mode)
  :bind (:map smartparens-mode-map
              ;; paredit bindings
              ("C-M-f" . sp-forward-sexp)
              ("C-M-b" . sp-backward-sexp)
              ("C-M-u" . sp-backward-up-sexp)
              ("C-M-d" . sp-down-sexp)
              ("C-M-p" . sp-backward-down-sexp)
              ("C-M-n" . sp-up-sexp)
              ("M-s" . sp-splice-sexp)
              ("M-<up>" . sp-splice-sexp-killing-backward)
              ("M-<down>" . sp-splice-sexp-killing-forward)
              ("M-r" . sp-splice-sexp-killing-around)
              ("M-(" . sp-wrap-round)
              ("C-)" . sp-forward-slurp-sexp)
              ("C-<right>" . sp-forward-slurp-sexp)
              ("C-}" . sp-forward-barf-sexp)
              ("C-<left>" . sp-forward-barf-sexp)
              ("C-(" . sp-backward-slurp-sexp)
              ("C-M-<left>" . sp-backward-slurp-sexp)
              ("C-{" . sp-backward-barf-sexp)
              ("C-M-<right>" . sp-backward-barf-sexp)
              ("M-S" . sp-split-sexp)
              ;; mine
              ("C-M-k" . sp-kill-sexp)
              ("C-M-w" . sp-copy-sexp)
              )
  :diminish smartparens-mode
  :init
  (setq sp-show-pair-delay 0.2
        ;; avoid slowness when editing inside a comment for modes with
        ;; parenthesized comments (e.g. coq)
        sp-show-pair-from-inside nil
        sp-cancel-autoskip-on-backward-movement nil
        sp-highlight-pair-overlay nil
        sp-highlight-wrap-overlay nil
        sp-highlight-wrap-tag-overlay nil)

  (my/add-hooks '(emacs-lisp-mode-hook clojure-mode-hook)
                (smartparens-strict-mode)
                (evil-smartparens-mode))
  (my/add-hooks '(prog-mode-hook coq-mode-hook comint-mode-hook css-mode-hook)
                (smartparens-mode)))

(use-package evil-smartparens
  :ensure t
  :after smartparens
  :diminish evil-smartparens-mode)
#+END_SRC

** Documentation & help

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :hook (after-init . which-key-mode)
  :diminish which-key-mode)
#+END_SRC

** Jumping etc

#+BEGIN_SRC emacs-lisp
(defun my/goto-line-show ()
  "Show line numbers temporarily, while prompting for the line number input."
  (interactive)
  (let ((cur display-line-numbers))
    (unwind-protect
        (progn
          (setq display-line-numbers t)
          (call-interactively #'goto-line))
      (setq display-line-numbers cur))))

(global-set-key (kbd "M-g M-g") 'my/goto-line-show)

(define-key prog-mode-map (kbd "M-a") 'beginning-of-defun)
(define-key prog-mode-map (kbd "M-e") 'end-of-defun)

(defun my/push-mark-no-activate ()
  "Pushes `point' to `mark-ring' and does not activate the region
   Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
  (interactive)
  (push-mark (point) t nil)
  (message "Pushed mark to ring"))

(global-set-key (kbd "C-`") 'my/push-mark-no-activate)

(defun my/jump-to-mark ()
  "Jumps to the local mark, respecting the `mark-ring' order.
  This is the same as using \\[set-mark-command] with the prefix argument."
  (interactive)
  (set-mark-command 1))

(global-set-key (kbd "M-`") 'my/jump-to-mark)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package imenu-list
  :ensure t
  :bind ("C-|" . my/imenu-list-smart-toggle)
  :config

  (defun my/imenu-list-jump-to-window ()
    "Jump to imenu-list window if visible, otherwise create it and jump."
    (interactive)
    (if (get-buffer-window imenu-list-buffer-name)
        (select-window (get-buffer-window imenu-list-buffer-name))
      (progn
        (imenu-list-minor-mode)
        (select-window (get-buffer-window imenu-list-buffer-name)))))

  (defun my/imenu-list-smart-toggle ()
    "If imenu-list window doesn't exist, create it and jump. If if does but
it is not the current buffer, jump there. If it exists and it's the current
buffer, close it."
    (interactive)
    (if (eq (current-buffer) (get-buffer imenu-list-buffer-name))
        (imenu-list-quit-window)
      (my/imenu-list-jump-to-window)))

  (setq imenu-list-size 40))
#+END_SRC

** Autocompleting etc

#+begin_src emacs-lisp
;; Don't consider punctuation part of word for completion,
;; helps complete qualified symbols
(add-hook
 'prog-mode-hook
 (lambda ()
   (setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_\\|\\sw\\s.")))

;; Don't autofill when pressing RET
(aset auto-fill-chars ?\n nil)
#+end_src

** engine-mode

#+BEGIN_SRC emacs-lisp
(use-package engine-mode
  :ensure t
  :hook (after-init . engine-mode)
  :bind-keymap ("C-x /" . engine-mode-map)
  :config
  (defengine google
    "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s"
    :keybinding "g")

  (defengine google-images
    "http://www.google.com/images?hl=en&source=hp&biw=1440&bih=795&gbv=2&aq=f&aqi=&aql=&oq=&q=%s"
    :keybinding "i")

  (defengine google-maps
    "http://maps.google.com/maps?q=%s")

  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
    :keybinding "w")

  (defengine wiktionary
    "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s"
    :keybinding "d")

  (defengine wolfram-alpha
    "http://www.wolframalpha.com/input/?i=%s"
    :keybinding "m")

  (defengine youtube
    "http://www.youtube.com/results?aq=f&oq=&search_query=%s"
    :keybinding "v")

  (defengine hoogle
    "https://hoogle.haskell.org/?hoogle=%s"
    :keybinding "h")

  (defengine stackage
    "https://www.stackage.org/lts/hoogle?q=%s"
    :keybinding "s")

  (defengine haskell-language-extensions
    "https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-%s"
    :keybinding "#")

  (defengine pursuit
    "https://pursuit.purescript.org/search?q=%s"
    :keybinding "p")
  )
#+END_SRC

** anzu

#+BEGIN_SRC emacs-lisp
(use-package anzu
  :ensure t
  :hook (after-init . global-anzu-mode)
  :diminish
  :init
  (setq anzu-mode-lighter ""))

(use-package evil-anzu
  :ensure t
  :after (evil anzu))
#+END_SRC

** math input

# http://ergoemacs.org/emacs/xmsi-math-symbols-input.html
# https://github.com/roelvandijk/base-unicode-symbols/blob/master/Prelude/Unicode.hs

#+BEGIN_SRC emacs-lisp
(use-package xah-math-input
  :ensure t
  :hook (after-init . global-xah-math-input-mode)
  :commands (xah-math-input-change-to-symbol)
  :diminish xah-math-input-mode
  :config
  (define-key xah-math-input-keymap (kbd "S-SPC" ) nil)
  (define-key xah-math-input-keymap (kbd "S-C-SPC") 'xah-math-input-change-to-symbol)

  (puthash "::" "∷" xah-math-input-abrvs)
  (puthash "bottom" "⊥" xah-math-input-abrvs))
#+END_SRC

** recentf

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :hook (after-init . recentf-mode)
  :init
  (setq recentf-max-saved-items 100))
#+END_SRC

** info mode

#+BEGIN_SRC emacs-lisp
(use-package info
  :bind (:map Info-mode-map
              ("h" . backward-char)
              ("j" . next-line)
              ))
#+END_SRC

** hi-lock & symbol overlay

#+begin_src emacs-lisp
(use-package hi-lock
  :hook (after-init . global-hi-lock-mode)
  :init
  (setq hi-lock-face-defaults
        '(
          "hi-black-b"
          "hi-red-b"
          "hi-green-b"
          "hi-blue-b"
          "hi-green"
          "hi-blue"
          "hi-pink"
          "hi-yellow"
          ))
  (setq hi-lock-auto-select-face t)
  :config
  (define-key hi-lock-map (kbd "M-H") (lookup-key hi-lock-map (kbd "C-x w")))
  ;; TODO: find out why I can't just `define-key'
  (substitute-key-definition
   'highlight-regexp 'my/highlight-regexp hi-lock-map)

  (defun my/highlight-regexp (regexp &optional face)
    (interactive
     (list
      (hi-lock-regexp-okay
       (read-regexp "Regexp to highlight" 'regexp-history-last))
      (hi-lock-read-face-name)))
    (or (facep face) (setq face 'hi-yellow))
    (unless hi-lock-mode (hi-lock-mode 1))
    (hi-lock-set-pattern regexp face nil)))

(use-package symbol-overlay
  :ensure t
  :commands (symbol-overlay-mode)
  :diminish
  :config
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd ",i") 'symbol-overlay-put)
    (define-key map (kbd ",d") 'symbol-overlay-remove-all)
    (define-key map (kbd "n") 'symbol-overlay-jump-next)
    (define-key map (kbd "p") 'symbol-overlay-jump-prev)
    (define-key map (kbd ",q") 'symbol-overlay-query-replace)
    (define-key map (kbd ",r") 'symbol-overlay-rename)
    (define-key map (kbd ",w") 'symbol-overlay-save-symbol)
    (define-key map (kbd ",s") 'symbol-overlay-isearch-literally)
    (setq symbol-overlay-map map)))
#+end_src

** alignment

#+begin_src emacs-lisp
(use-package align
  :bind ("C-c \\" . align-regexp)
  :config
  (add-hook 'align-load-hook
            (lambda ()
              (add-to-list 'align-rules-list
                           '(haskell-types
                             (regexp . "\\(\\s-+\\)\\(::\\|∷\\)\\s-+")
                             (modes quote (haskell-mode purescript-mode literate-haskell-mode))))
              (add-to-list 'align-rules-list
                           '(haskell-assignment
                             (regexp . "\\(\\s-+\\)=\\s-+")
                             (modes quote (haskell-mode purescript-mode literate-haskell-mode))))
              (add-to-list 'align-rules-list
                           '(haskell-arrows
                             (regexp . "\\(\\s-+\\)\\(->\\|→\\)\\s-+")
                             (modes quote (haskell-mode purescript-mode literate-haskell-mode))))
              (add-to-list 'align-rules-list
                           '(haskell-left-arrows
                             (regexp . "\\(\\s-+\\)\\(<-\\|←\\)\\s-+")
                             (modes quote (haskell-mode purescript-mode literate-haskell-mode))))))
  )
#+end_src

** highlight keywords in some modes

#+BEGIN_SRC emacs-lisp
(defface my/special-keyword-face
  '((t (:inherit font-lock-keyword-face)))
  "Face for highlighting special keywords"
  :group 'my/faces)

(defface my/special-comment-keyword-face
  '((t (:inherit font-lock-preprocessor-face)))
  "Face for highlighting special keywords in comments"
  :group 'my/faces)

(defun my/highlight-keyword-in-mode (mode kw &optional in-comment face)
  (let ((fc (or face (if in-comment 'my/special-comment-keyword-face 'my/special-keyword-face)))
        (str (format "\\<\\(%s\\)\\>" kw)))
    (font-lock-add-keywords
     mode
     (if in-comment
         `((,str 1 ,`(quote ,fc) prepend))
       `((,str . ,`(quote ,fc)))))))

(defvar my/comment-keywords
  '("TODO" "NOTE" "FIXME" "WARNING" "HACK" "XXX" "DONE"))

(defun my/highlight-comment-keywords (mode &optional face)
  (dolist (kw my/comment-keywords)
    (my/highlight-keyword-in-mode mode kw t face)))

(dolist
    (mode '(haskell-mode
            literate-haskell-mode
            purescript-mode
            js2-mode
            html-mode
            python-mode
            idris-mode
            agda-mode
            rust-mode
            c-mode
            emacs-lisp-mode
            coq-mode
            markdown-mode
            ))
  (my/highlight-comment-keywords mode))
#+END_SRC

** temp project roots

#+BEGIN_SRC emacs-lisp
(defvar my/temp-project-root nil)

(defun my/get-or-set-temp-root (reset)
  (let* ((reset-root (if reset my/temp-project-root nil))
         (root
          (if (or reset
                  (null my/temp-project-root)
                  (not (file-directory-p my/temp-project-root)))
              (read-directory-name "Temp root dir: " reset-root)
            my/temp-project-root)))
    (setq my/temp-project-root root)))
#+END_SRC

** edit indirect

#+BEGIN_SRC emacs-lisp
(use-package edit-indirect
  :ensure t
  :commands (edit-indirect-region)
  :bind ("C-c C-'" . my/edit-indirect-region)
  :config
  (add-hook 'edit-indirect-after-creation-hook 'my/edit-indirect-dedent)
  (add-hook 'edit-indirect-before-commit-hook 'my/edit-indirect-indent))

(defun my/edit-indirect-region ()
  (interactive)
  (unless (region-active-p) (user-error "No region selected"))
  (save-excursion
    (let* ((begin (region-beginning))
           (end (region-end))
           (mode (my/select-a-major-mode))
           (edit-indirect-guess-mode-function
            (lambda (_parent _beg _end)
              (funcall (intern mode)))))
      (edit-indirect-region begin end 'display-buffer))))

(defun my/get-buffer-min-leading-spaces (&optional buffer)
  (let* ((buf (or buffer (current-buffer)))
         (ind nil)
         )
    (save-excursion
      (goto-char (point-min))
      (setq ind (org-get-indentation))
      (while (not (or (evil-eobp) (eobp)))
        (unless (string-match-p "\\`\\s-*$" (thing-at-point 'line))
          (setq ind (min ind (org-get-indentation))))
        (ignore-errors (next-line))
        ))
    ind))

(defun my/edit-indirect-dedent ()
  (let ((amount (my/get-buffer-min-leading-spaces)))
    (setq-local my/edit-indirect-dedented-amount amount)
    (save-excursion
      (indent-rigidly (point-min) (point-max) (- amount)))))

(defun my/edit-indirect-indent ()
  (when (boundp 'my/edit-indirect-dedented-amount)
    (save-excursion
      (indent-rigidly (point-min) (point-max) my/edit-indirect-dedented-amount))))
#+END_SRC

* Term, eshell and comint-mode
** Terms

#+BEGIN_SRC emacs-lisp
(use-package term
  :defer t
  :config
  (my/add-hooks
   '(term-mode-hook)
   (define-key term-raw-map (kbd "M-o") nil)
   (define-key term-raw-map (kbd "M-+") nil))

  ;; automatically close term buffers on EOF
  (defun my/term-exec-hook ()
    (let* ((buff (current-buffer))
           (proc (get-buffer-process buff)))
      (set-process-sentinel
       proc
       `(lambda (process event)
          (if (string= event "finished\n")
              (kill-buffer ,buff))))))
  (add-hook 'term-exec-hook 'my/term-exec-hook))

(use-package comint
  :defer t
  :init
  (setq comint-prompt-read-only t)
  :config
  (defun my/comint-clear-buffer ()
    (interactive)
    (let ((comint-buffer-maximum-size 0))
      (comint-truncate-buffer)))
  (add-hook 'comint-mode-hook
            (lambda ()
              (define-key comint-mode-map (kbd "C-l") 'my/comint-clear-buffer))))
#+END_SRC

** eshell

#+BEGIN_SRC emacs-lisp
(use-package em-hist :after eshell)

(use-package eshell
  :commands (eshell)
  :bind (:map eshell-mode-map
              ("C-l" . my/eshell-clear))
  :init
  ;; eshell/clear doesn't work anymore because eshell has its own clear function
  (defun my/eshell-clear ()
    (interactive)
    "Clear the eshell buffer."
    (let ((eshell-buffer-maximum-lines (if my/eshell-prompt-multiline 1 0)))
      (eshell-truncate-buffer)))

  ;; toggle between single line/multiline prompt
  (defun eshell/sp ()
    "Clear the eshell buffer."
    (setq my/eshell-prompt-multiline (not my/eshell-prompt-multiline))
    nil)

  (setq eshell-destroy-buffer-when-process-dies t
        eshell-history-size 1024
        eshell-prompt-regexp "^[^#$]* [#$] ")

  (defvar my/eshell-prompt-multiline nil)

  (setq eshell-prompt-function
        (lambda ()
          (concat
           (propertize (if my/eshell-prompt-multiline "┌─╼ " "") 'face 'font-lock-type-face)
           (propertize
            ((lambda (p-lst)
               (if (> (length p-lst) 3)
                   (concat
                    (mapconcat (lambda (elm) (if (zerop (length elm)) ""
                                               (substring elm 0 1)))
                               (butlast p-lst 3)
                               "/")
                    "/"
                    (mapconcat (lambda (elm) elm)
                               (last p-lst 3)
                               "/"))
                 (mapconcat (lambda (elm) elm)
                            p-lst
                            "/")))
             (split-string (pwd-repl-home (eshell/pwd)) "/"))
            'face
            'font-lock-type-face)
           (or (curr-dir-git-branch-string (eshell/pwd)))
           (propertize (if my/eshell-prompt-multiline "\n└╼ " " ") 'face 'font-lock-type-face)
           (propertize "$" 'face 'font-lock-function-name-face)
           (propertize " " 'face 'default))))
  :config
  (if (boundp 'eshell-save-history-on-exit)
      (setq eshell-save-history-on-exit t)) ; Don't ask, just save
  (if (boundp 'eshell-ask-to-save-history)
      (setq eshell-ask-to-save-history 'always)) ; For older(?) version
  )

(use-package em-smart
  :after eshell
  :init
  (setq eshell-where-to-jump 'begin
        eshell-review-quick-commands nil
        eshell-smart-space-goes-to-end t))

(defun pwd-repl-home (pwd)
  (interactive)
  (let* ((home (expand-file-name (getenv "HOME")))
         (home-len (length home)))
    (if (and
         (>= (length pwd) home-len)
         (equal home (substring pwd 0 home-len)))
        (concat "~" (substring pwd home-len))
      pwd)))

(defun my/eshell-in-dir (dir-or-file)
  (interactive "DOpen eshell in: ")
  (let* ((dir (if (file-directory-p dir-or-file)
                  dir-or-file
                (file-name-directory dir-or-file)))
         (default-directory dir))
    (eshell t)))

(defun curr-dir-git-branch-string (cwd)
  "Returns current git branch as a string, or the empty string if
CWD is not in a git repo (or the git command is not found)."
  (interactive)
  (when (and (eshell-search-path "git")
             (locate-dominating-file cwd ".git"))
    (let ((git-output
           (shell-command-to-string
            (concat "cd "
                    cwd
                    " && git branch | grep '\\*' | sed -e 's/^\\* //'"))))
      (concat
       (propertize
        (concat "["
                (if (> (length git-output) 0)
                    (substring git-output 0 -1)
                  "(no branch)")
                )
        'face 'font-lock-string-face)
       (my/git-collect-status cwd)
       (propertize "]" 'face 'font-lock-string-face)
       )
      )))

;; TODO
;; https://github.com/xuchunyang/eshell-git-prompt/blob/master/eshell-git-prompt.el
(defun my/git-collect-status (cwd)
  (when (and (eshell-search-path "git")
             (locate-dominating-file cwd ".git"))
    (let ((git-output
           (split-string
            (shell-command-to-string
             (concat "cd "
                     cwd
                     " && git status --porcelain"))
            "\n" t))
          (untracked 0)
          (modified 0)
          (modified-updated 0)
          (new-added 0)
          (deleted 0)
          (deleted-updated 0)
          (renamed-updated 0)
          (commits-ahead 0) ;; TODO
          (commits-behind 0) ;; TODO
          )
      (dolist (x git-output)
        (pcase (substring x 0 2)
          ("??" (cl-incf untracked))
          ("MM" (progn (cl-incf modified)
                       (cl-incf modified-updated)))
          (" M" (cl-incf modified))
          ("M " (cl-incf modified-updated))
          ("A " (cl-incf new-added))
          (" D" (cl-incf deleted))
          ("D " (cl-incf deleted-updated))
          ("R " (cl-incf renamed-updated))
          )
        )
      (concat
       (propertize (if (> (+ untracked deleted) 0) "•" "") 'face '(:foreground "salmon3"))
       (propertize (if (> modified 0) "•" "") 'face '(:foreground "goldenrod3"))
       (propertize (if (> modified-updated 0) "•" "") 'face '(:foreground "SeaGreen4"))
       )
      )
    ))
#+END_SRC

* UI

#+BEGIN_SRC emacs-lisp
;; highlight numbers
(use-package highlight-numbers
  :ensure t
  :hook ((prog-mode haskell-cabal-mode css-mode) . highlight-numbers-mode))

;; show column in modeline
(setq column-number-mode t)

;; disable annoying stuff
(setq ring-bell-function 'ignore
      inhibit-startup-message t
      inhibit-splash-screen t
      initial-scratch-message nil)
(menu-bar-mode -1)
(scroll-bar-mode -1)
(set-window-scroll-bars (minibuffer-window) nil nil)
(tool-bar-mode -1)

(use-package linum
  :if (< emacs-major-version 26)
  :init (setq linum-format 'dynamic))

(use-package hl-line
  ;; :hook (prog-mode . hl-line-mode)
  :commands (hl-line-mode global-hl-line-mode)
  :init
  (setq hl-line-sticky-flag nil)
  (defvar my/hl-line-contrast 5)
  (defun my/hl-line-set-bg (&optional light-bg th)
    (let* ((func (if light-bg 'color-darken-name 'color-lighten-name))
           (bg (face-attribute 'default :background))
           (theme (if th th my/theme)))
      (custom-theme-set-faces
       theme
       `(hl-line ((t (:background ,(funcall func bg my/hl-line-contrast)))))))))

(use-package display-fill-column-indicator
  :if (>= emacs-major-version 27)
  :commands (display-fill-column-indicator-mode)
  :hook ((python-mode markdown-mode) . display-fill-column-indicator-mode))
#+END_SRC

** highlight trailing whitespace

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :ensure t
  :diminish whitespace-mode
  :diminish global-whitespace-mode
  :hook ((prog-mode . whitespace-mode))
  :init
  (setq whitespace-line-column 80
        whitespace-style '(face trailing)))
#+END_SRC

* Theme

#+BEGIN_SRC emacs-lisp
(defun my/after-set-theme (&optional light-bg)
  (setq my/theme-light-bg (if light-bg t nil))
  (my/diff-hl-set-fringe-faces light-bg)
  (my/hl-line-set-bg light-bg)
  (my/org-set-src-faces light-bg))

(when (>= emacs-major-version 27)
  (setq custom--inhibit-theme-enable nil))

;; I am trying a lot of themes dammit
(setq my/all-themes
      '(
        (wombat
         (progn
           (custom-theme-set-faces
            'wombat
            '(default ((t (:foreground "#c7c7c7" :background "#1a1a1a"))))
            '(font-lock-comment-face ((t (:foreground "#828987"))))
            '(font-lock-string-face ((t (:foreground "#4096c9"))))
            '(font-lock-doc-face ((t (:foreground "#348dc1"))))
            '(region ((t (:background "#515151"))))
            '(highlight ((t (:background "#3a3a3a"))))
            '(cursor ((t (:background "#d8d8d8"))))
            '(fringe ((t (:background "#2e2e2e"))))
            '(isearch ((t (:foreground "#242424" :background "#e5786d"))))
            '(vertical-border ((t (:foreground "#b0b0b0"))))
            '(show-paren-match ((t (:background "steelblue4" :weight bold))))
            '(mode-line-buffer-id ((t (:weight bold))))
            '(persp-selected-face ((t (:inherit font-lock-string-face :weight bold))))
            '(mode-line
              ((t (:background "#454545" :foreground "#d1d1d1" :box (:line-width 1 :color "#4a4a4a")))))
            '(mode-line-inactive
              ((t (:inherit mode-line :background "#282828" :foreground "#858585"))))
            ;; '(-operator-face ((t (:foreground "#e5786d"))))
            '(haskell-constructor-face ((t (:inherit haskell-type-face :weight normal))))
            '(ivy-grep-info ((t (:foreground "#a4bd64" :weight bold))))
            '(ag-hit-face   ((t (:foreground "#a4bd64" :weight bold))))
            '(sh-quoted-exec ((t (:foreground "#72c8db"))))
            )
           (my/after-set-theme)
           ))
        (zenburn
         (progn
           (custom-theme-set-faces
            'zenburn
            '(default ((t (:foreground "#dcdccc" :background "#3f3f3f"))))
            '(region ((t (:background "#5a5a5a"))))
            '(vertical-border ((t (:foreground "#a5a5a5"))))
            '(fringe ((t (:background "#454545"))))
            '(mode-line ((t
                          (:box
                           (:line-width -1 :color nil :style released-button)
                           :foreground "#a2c6a2" :background "#454545"))))
            '(mode-line-inactive ((t
                                   (:box
                                    (:line-width -1 :color nil :style released-button)
                                    :foreground "#5F7F5F" :background "#353535"))))
            '(powerline-active0 ((t (:background "#5F5F5F" :inherit mode-line))))
            '(powerline-active1 ((t (:inherit mode-line))))
            '(powerline-active2 ((t (:background "#383838" :inherit mode-line))))
            '(powerline-inactive0 ((t (:inherit mode-line-inactive))))
            '(powerline-inactive1 ((t (:inherit mode-line-inactive))))
            '(powerline-inactive2 ((t (:inherit mode-line-inactive))))
            '(mode-line-buffer-id ((t (:weight bold))))
            '(persp-selected-face ((t (:foreground "#d0bf8f" :weight bold))))
            '(diff-hl-insert ((t (:foreground "#789c78" :background "#3c543c"))))
            '(diff-hl-change ((t (:foreground "#79b3b5" :background "#425f61"))))
            '(diff-hl-delete ((t (:foreground "#ab8080" :background "#694848"))))
            '(fill-column-indicator ((t (:foreground "#5a5a5a"))))
            )
           (my/hl-line-set-bg) (my/org-set-src-faces)
           (setq pdf-view-midnight-colors '("#dcdccc" . "#383838"))
           ))
        (darktooth
         (progn
           (custom-theme-set-faces
            'darktooth
            '(default ((t (:foreground "#ddd7b4" :background "#222222"))))
            '(fringe ((t (:background "#2d2d2d"))))
            '(persp-selected-face ((t (:foreground "#8ec07c" :weight bold))))
            ;; '(font-lock-function-name-face ((t (:foreground "#74b8bc"))))
            '(font-lock-function-name-face ((t (:foreground "#afa08b"))))
            '(font-lock-preprocessor-face ((t (:foreground "#d787af"))))
            '(purescript-constructor-face ((t (:inherit haskell-constructor-face))))
            '(mode-line ((t (:box nil :foreground "#e5dfbc" :background "#4d4845"))))
            '(mode-line-inactive ((t (:box nil :foreground "#968a79" :background "#33302d"))))
            '(vertical-border ((t (:foreground "#a89984"))))
            '(markdown-pre-face ((t (:foreground "#8ec07c"))))
            '(anzu-mode-line ((t (:foreground "magenta" :weight bold))))
            '(anzu-mode-line-no-match ((t (:foreground "red" :weight bold))))
            '(powerline-active0 ((t (:background "#696461" :foreground "#e5dfbc"))))
            '(powerline-active1 ((t (:background "#55504d" :foreground "#e5dfbc"))))
            '(powerline-active2 ((t (:background "#433f3e" :foreground "#e5dfbc"))))
            '(powerline-inactive0 ((t (:inherit mode-line-inactive))))
            '(powerline-inactive1 ((t (:inherit powerline-inactive0))))
            '(powerline-inactive2 ((t (:inherit powerline-inactive0))))
            '(fill-column-indicator ((t (:foreground "#464646"))))
            )
           (my/after-set-theme)
           (setq pdf-view-midnight-colors '("#ddd7b4" . "#3d3d3d"))
           ))
        (nord
         (progn
           (custom-theme-set-faces
            'nord
            '(default ((t (:background "#1c222b" :foreground "#b6c1d3"))))
            '(mode-line ((t (:background "#3f4758" :foreground "#9ac9d7"))))
            '(mode-line-inactive ((t (:background "#2f343f" :foreground "#5e7591"))))
            '(powerline-inactive0 ((t (:inherit mode-line-inactive))))
            '(powerline-inactive1 ((t (:inherit mode-line-inactive))))
            '(powerline-inactive2 ((t (:inherit mode-line-inactive))))
            '(font-lock-doc-face ((t (:foreground "#97aa86"))))
            '(font-lock-preprocessor-face ((t (:foreground "#D08770"))))
            '(font-lock-variable-name-face ((t (:inherit default))))
            '(font-lock-comment-face ((t (:foreground "#707c95"))))
            '(font-lock-comment-delimiter-face ((t (:inherit font-lock-comment-face))))
            '(highlight-numbers-number ((t (:foreground "#B48EAD"))))
            '(haskell-pragma-face ((t (:foreground "#B48EAD"))))
            '(persp-selected-face ((t (:foreground "#A3BE8C" :weight bold))))
            '(fringe ((t (:background "#202830"))))
            '(region ((t (:background "#3b4353"))))
            '(shadow ((t (:foreground "#545d72"))))
            '(show-paren-match ((t (:background "#465d75" :weight bold))))
            '(lazy-highlight ((t (:background "#496665"))))
            '(fill-column-indicator ((t (:foreground "#434c5e"))))
            '(markdown-code-face ((t (:inherit font-lock-string-face))))
            '(rg-match-face ((t (:background "#35535b"))))
            '(hi-green ((t (:foreground "black" :background "#859c73"))))
            '(hi-blue ((t (:foreground "black" :background "#7da9b5"))))
            '(hi-pink ((t (:foreground "black" :background "#a37f9d"))))
            '(hi-green-b ((t (:foreground "#9cb586" :background "#3b4732" :weight bold))))
            '(hi-blue-b ((t (:foreground "#97c4c3" :background "#394b4f" :weight bold))))
            '(hi-red-b ((t (:foreground "#bf95b7" :background "#453341" :weight bold))))
            )
           (my/after-set-theme)
           ))
        ))

(defvar my/avail-themes '(wombat))
(defvar my/current-theme 0)
(defvar my/theme 'wombat)
(defvar my/theme-light-bg nil)

(defvar my/after-set-theme-hook nil
  "Hook called after setting a theme")

(defun my/set-theme (&optional theme-config light-bg)
  (let* ((theme-config (if (null theme-config)
                           (elt my/avail-themes my/current-theme)
                         theme-config))
         (theme (if (listp theme-config)
                    (car theme-config)
                  theme-config))
         (config (if (listp theme-config) (cadr theme-config) nil))
         (light-bg (if (listp theme-config)
                       (caddr theme-config)
                     light-bg)))
    (mapc 'disable-theme custom-enabled-themes)
    (load-theme theme t)
    (setq my/theme theme)
    (setq my/theme-light-bg light-bg)
    (eval config)
    (run-hooks 'my/after-set-theme-hook)))

(defun my/toggle-theme ()
  (interactive)
  (let* ((next-theme (mod (1+ my/current-theme) (length my/avail-themes)))
         (theme (elt my/avail-themes next-theme)))
    (setq my/current-theme next-theme)
    (my/set-theme)))

(defun my/refresh-theme ()
  (interactive)
  (my/set-theme)
  (setq linum-format 'dynamic))
#+END_SRC

* Font

#+BEGIN_SRC emacs-lisp
(defvar my/avail-fonts '(("Monospace" 12)))
(defvar my/current-font 0)
(defvar my/current-font-size nil)
(defvar my/font-size-step 0.5)

(defvar my/after-set-font-hook nil
  "Hook called after updating fonts")

(defun my/set-font (&optional spec)
  (let* ((spec (if (null spec) (elt my/avail-fonts my/current-font) spec))
         (name (car spec))
         (size (cadr spec))
         (spacing (or (caddr spec) 0)))
    (set-face-font 'default (format "%s-%s" name size))
    (setq-default line-spacing spacing)
    (setq line-spacing spacing)
    (run-hooks 'my/after-set-font-hook)))

(defun my/toggle-font ()
  (interactive)
  (let ((next-font (mod (1+ my/current-font) (length my/avail-fonts))))
    (setq my/current-font-size nil)
    (my/set-font (elt my/avail-fonts next-font))
    (setq my/current-font next-font)))

(defun my/refresh-font ()
  (interactive)
  (setq my/current-font-size nil)
  (my/set-font (elt my/avail-fonts my/current-font)))

;; NOTE: trying this out
(defun my/change-font-size (&optional dec)
  (let* ((spec (elt my/avail-fonts my/current-font))
         (name (car spec))
         (size (or my/current-font-size (cadr spec))))
    (setq my/current-font-size
          (if dec
              (- size my/font-size-step)
            (+ size my/font-size-step)))
    (my/set-font (list name my/current-font-size))))

(global-set-key (kbd "C-+") #'(lambda () (interactive) (my/change-font-size)))
(global-set-key (kbd "C--") #'(lambda () (interactive) (my/change-font-size :dec)))
(global-set-key (kbd "C-x C-0") #'my/refresh-font)

;; size & scaling
;; (setq text-scale-mode-step 1.05)
;; (define-key global-map (kbd "C-+") 'text-scale-increase)
;; (define-key global-map (kbd "C--") 'text-scale-decrease)
#+END_SRC

* VCS
** vc

#+BEGIN_SRC emacs-lisp
(use-package vc
  :bind (("C-x v p" . my/vc-project)
         ("C-x v d" . vc-diff))
  :init
  ;; prot
  (defun my/vc-project ()
    (interactive)
    (vc-dir (vc-root-dir)))
  :config
  (define-key diff-mode-map (kbd "M-o") nil))

(use-package vc-git
  :init
  (setq vc-git-print-log-follow t))

(use-package vc-annotate
  :bind (("C-x v a" . vc-annotate)
         :map vc-annotate-mode-map
         ("t" . vc-annotate-toggle-annotation-visibility))
  :init
  (setq vc-annotate-display-mode 'scale))
#+END_SRC

** Magit

#+BEGIN_SRC emacs-lisp
(defun my/magit-set-diff-faces ()
  (custom-theme-set-faces
   my/theme
   '(magit-diff-added-highlight ((t (:background "#3f5f3f" :foreground "#afd8af"))))
   '(magit-diff-removed-highlight ((t (:background "#7c4343" :foreground "#ecb3b3"))))
   '(magit-diff-added ((t (:background "#2f4f2f" :foreground "#9fc59f"))))
   '(magit-diff-removed ((t (:background "#6c3333" :foreground "#dca3a3"))))
   ))

(use-package magit
  :ensure t
  :commands (magit-status
             magit-dispatch-popup
             magit-blame-addition
             magit-log-buffer-file)
  :bind (("C-x g" . magit-status)
         ("C-x M-g" . magit-dispatch-popup))
  :init
  (defalias 'magb 'magit-blame-addition)
  (defalias 'gl   'magit-log-buffer-file)
  (defalias 'magl 'magit-log-buffer-file)
  :config
  (add-hook 'magit-blame-mode-hook
            (lambda ()
              (if (or (not (boundp 'magit-blame-mode))
                      magit-blame-mode)
                  (evil-emacs-state)
                (evil-exit-emacs-state)))))

(use-package magit-todos
  :ensure t
  :after magit
  :config
  (magit-todos-mode))
#+END_SRC

** git-timemachine

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :ensure t
  :commands (git-timemachine)
  :config
  (add-hook
   'git-timemachine-mode-hook
   '(lambda () (evil-local-mode -1))))
#+END_SRC

** Diff-hl

#+BEGIN_SRC emacs-lisp
(defun my/diff-hl-set-fringe-faces (&optional light-bg th)
  (let* ((dark (not light-bg))
         (ins-bg (if dark "#143514" "#b9e0b3"))
         (ins-fg (if dark "#2b872b" "#194219"))
         (ch-bg (if dark "#122544" "#b5d8f4"))
         (ch-fg (if dark "#4171c1" "#2b4775"))
         (del-bg (if dark "#491111" "#f4b5b5"))
         (del-fg (if dark "#bc4d4d" "#561a1a"))
         (theme (if th th my/theme)))
    (custom-theme-set-faces
     theme
     `(diff-hl-insert ((t (:background ,ins-bg :foreground ,ins-fg))))
     `(diff-hl-change ((t (:background ,ch-bg :foreground ,ch-fg))))
     `(diff-hl-delete ((t (:background ,del-bg :foreground ,del-fg)))))))

(use-package diff-hl
  :ensure t
  :if is-gui
  :hook ((after-init . global-diff-hl-mode)
         (dired-mode . diff-hl-dired-mode))
  :config
  ;; https://github.com/dgutov/diff-hl#magit
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))

(use-package git-gutter+
  :ensure t
  :unless is-gui
  :hook (after-init . global-git-gutter+-mode))
#+END_SRC

** Helpers

#+BEGIN_SRC emacs-lisp
(defun my/git-blame-current-line ()
  "Runs `git blame` on the current line and
   adds the commit id to the kill ring"
  (interactive)
  (let* ((line-number (save-excursion
                        (goto-char (point-at-bol))
                        (+ 1 (count-lines 1 (point)))))
         (line-arg (format "%d,%d" line-number line-number))
         (commit-buf (generate-new-buffer "*git-blame-line-commit*")))
    (call-process "git" nil commit-buf nil
                  "blame" (buffer-file-name) "-L" line-arg)
    (let* ((commit-id (with-current-buffer commit-buf
                        (buffer-substring 1 9)))
           (log-buf (generate-new-buffer "*git-blame-line-log*")))
      (kill-new commit-id)
      (call-process "git" nil log-buf nil
                    "log" "-1" "--pretty=%h   %an   %s" commit-id)
      (with-current-buffer log-buf
        (message "Line %d: %s"
                 line-number
                 (replace-regexp-in-string "\n\\'" "" (buffer-string))))
      (kill-buffer log-buf))
    (kill-buffer commit-buf)))

(global-set-key (kbd "M-L") #'my/git-blame-current-line)
#+END_SRC

* Keybindings
** keybind to command mapping

#+BEGIN_SRC emacs-lisp
(setq my/leader-keys
      '(
        ("SPC" display-fill-column-indicator-mode)

        ("a" align-regexp)

        ;; dired
        ("dn" find-name-dired)
        ("dg" find-grep-dired)
        ("dv" my/git-grep-dired)

        ;; errors
        ("el" my/toggle-flycheck-error-list)

        ;; browsing/files
        ("fc" my/copy-file-path)
        ("fd" pwd)
        ("fp" my/try-open-dominating-file)
        ("fs" my/create-scratch-buffer-with-mode)

        ;; git/vc
        ("gb" my/git-blame-current-line)

        ("h"  help)

        ;; insert
        ("iu" counsel-unicode-char)

        ;; project
        ("pa" counsel-projectile-ag)
        ("pr" counsel-projectile-rg)
        ("ps" my/rg-project-or-ask)
        ("pt" my/counsel-ag-todos-global)

        ;; show/display
        ("sd" pwd)
        ;; find/search
        ("sa" ag)
        ("sr" rg)
        ("sca" counsel-ag)
        ("scr" counsel-rg)
        ("sr" rgrep)

        ;; toggle
        ("t8" display-fill-column-indicator-mode)
        ("tc" global-company-mode)
        ("tf" my/toggle-font)
        ("tg" global-diff-hl-mode)
        ("tl" my/line-numbers)
        ("to" symbol-overlay-mode)
        ("th" hl-line-mode)
        ("ts" flycheck-mode)
        ("tt" my/toggle-theme)
        ("tw" toggle-truncate-lines)

        ;; ui
        ("uh" rainbow-mode)
        ("um" (lambda () (interactive) (call-interactively 'tool-bar-mode) (call-interactively 'menu-bar-mode)))
        ("up" rainbow-delimiters-mode)

        ;; windows
        ("wf" my/window-fixed)
        ("wd" my/window-dedicated)

        ;; theme
        ("Ts" counsel-load-theme)

        ("Q" evil-local-mode)
        ))
#+END_SRC

** setup keybindings

#+begin_src emacs-lisp
(define-prefix-command 'my/leader-map)

;; (define-key ctl-x-map "m" 'my/leader-map)
(define-prefix-command 'my/leader-map)
(global-set-key (kbd "C-c m") 'my/leader-map)

(dolist (i my/leader-keys)
  (let ((k (car i))
        (f (cadr i)))
    (define-key my/leader-map (kbd k) f)))

(define-prefix-command 'my/major-mode-map)

(if is-gui
    (progn
      ;; distinguish `C-m` from `RET`
      (define-key input-decode-map [?\C-m] [C-m])
      ;; distinguish `C-i` from `TAB`
      ;; (define-key input-decode-map [?\C-i] [C-i])
      (global-set-key (kbd "C-c <C-m>") 'my/leader-map)
      (setq my/major-mode-map-key "<C-m>"))
  (setq my/major-mode-map-key "C-c m m"))

;; on hold
;; (defun my/define-major-mode-keys (hook &rest combinations)
;;   "Bind all pairs of (key . function) under `my/major-mode-map-key'
;;
;; The keys are bound after `hook'."
;;   (add-hook
;;    hook
;;    `(lambda ()
;;       (let ((map (make-sparse-keymap)))
;;         (local-set-key (kbd ,my/major-mode-map-key) map)
;;         (dolist (comb (quote ,combinations))
;;           (define-key map (kbd (car comb)) (cdr comb)))))))

(defun my/define-major-mode-key (mode key func)
  (let* ((map-symbol (intern (format "my/%s-map" mode)))
         (hook (intern (format "%s-hook" mode)))
         (map
          (if (boundp map-symbol)
              (symbol-value map-symbol)
            (progn
              (let ((map- (make-sparse-keymap)))
                (add-hook
                 hook
                 `(lambda ()
                    (local-set-key (kbd ,my/major-mode-map-key) (quote ,map-))))
                (set (intern (format "my/%s-map" mode)) map-))))))
    (define-key map (kbd key) func)
    (evil-leader/set-key-for-mode mode (kbd (format "m %s" key)) func)))

(if is-gui
    (global-set-key (kbd "<C-m>") 'my/major-mode-map)
  (global-set-key (kbd "C-c m m") 'my/major-mode-map))
#+end_src

* Evil-mode
** evil-mode setup

#+BEGIN_SRC emacs-lisp
(use-package evil-leader
  :hook (evil-local-mode . evil-leader-mode)
  :ensure t
  :config
  ;; (global-evil-leader-mode)
  (evil-leader/set-leader "<SPC>")
  (dolist (i my/leader-keys)
    (let ((k (car i))
          (f (cadr i)))
      (evil-leader/set-key k f))))

(use-package evil-visualstar
  :hook (evil-local-mode . evil-visualstar-mode)
  :ensure t)

(use-package evil
  :ensure t
  :hook ((prog-mode
          text-mode
          haskell-cabal-mode
          coq-mode easycrypt-mode phox-mode
          conf-unix-mode
          conf-colon-mode
          conf-space-mode
          conf-windows-mode
          conf-toml-mode)
         . evil-local-mode)
  :init
  (setq evil-want-C-i-jump nil
        evil-intercept-esc t
        evil-mode-line-format '(before . mode-line-front-space))
  ;; (setq evil-move-cursor-back nil)  ;; works better with lisp navigation
  :config
  (defun my/make-emacs-mode (mode)
    "Make `mode' use emacs keybindings."
    (delete mode evil-insert-state-modes)
    (add-to-list 'evil-emacs-state-modes mode))

  (global-set-key (kbd "<f5>") 'evil-local-mode)

  ;; don't need C-n, C-p
  (define-key evil-insert-state-map (kbd "C-n") nil)
  (define-key evil-insert-state-map (kbd "C-p") nil)

  ;; magit
  (evil-define-key 'normal magit-blame-mode-map (kbd "q") 'magit-blame-quit)

  ;; intercept ESC when running in terminal
  (evil-esc-mode)

  ;; move search result to center of the screen
  (defadvice evil-search-next
      (after advice-for-evil-search-next activate)
    (evil-scroll-line-to-center (line-number-at-pos)))

  (defadvice evil-search-previous
      (after advice-for-evil-search-previous activate)
    (evil-scroll-line-to-center (line-number-at-pos)))

  ;; this is needed to be able to use C-h
  (global-set-key (kbd "C-h") 'help)
  (define-key evil-normal-state-map (kbd "C-h") 'undefined)
  (define-key evil-insert-state-map (kbd "C-h") 'undefined)
  (define-key evil-visual-state-map (kbd "C-h") 'undefined)

  (define-key evil-emacs-state-map (kbd "C-h") 'help)
  (define-key evil-insert-state-map (kbd "C-k") nil)

  (define-key evil-normal-state-map (kbd "M-.") nil)

  (define-key evil-normal-state-map (kbd "C-h") 'evil-window-left)
  (define-key evil-normal-state-map (kbd "C-j") 'evil-window-down)
  (define-key evil-normal-state-map (kbd "C-k") 'evil-window-up)
  (define-key evil-normal-state-map (kbd "C-l") 'evil-window-right)

  (define-key evil-normal-state-map (kbd ";") 'evil-ex)
  (define-key evil-visual-state-map (kbd ";") 'evil-ex)
  (evil-ex-define-cmd "sv" 'evil-window-split)

  (define-key evil-normal-state-map (kbd "C-p") 'counsel-projectile-find-file)

  (define-key evil-insert-state-map (kbd "C-M-i") 'company-complete)

  (define-key evil-visual-state-map (kbd "<") #'(lambda ()
                                                  (interactive)
                                                  (progn
                                                    (call-interactively 'evil-shift-left)
                                                    (execute-kbd-macro "gv"))))

  (define-key evil-visual-state-map (kbd ">") #'(lambda ()
                                                  (interactive)
                                                  (progn
                                                    (call-interactively 'evil-shift-right)
                                                    (execute-kbd-macro "gv"))))

  ;; redefine so that $ doesn't include the EOL char
  (setq my/evil-$-include-eol nil)
  (evil-define-motion evil-end-of-line (count)
    "Move the cursor to the end of the current line.

If COUNT is given, move COUNT - 1 lines downward first."
    :type inclusive
    (move-end-of-line count)
    (when evil-track-eol
      (setq temporary-goal-column most-positive-fixnum
            this-command 'next-line))
    (unless (and (evil-visual-state-p) my/evil-$-include-eol)
      (evil-adjust-cursor)
      (when (eolp)
        ;; prevent "c$" and "d$" from deleting blank lines
        (setq evil-this-type 'exclusive))))

  ;; https://github.com/emacs-evil/evil-surround/issues/141
  (defmacro my/evil-define-text-object (name key start-regex end-regex)
    (let ((inner-name (make-symbol (concat "evil-inner-" name)))
          (outer-name (make-symbol (concat "evil-a-" name))))
      `(progn
         (evil-define-text-object ,inner-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count nil))
         (evil-define-text-object ,outer-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count t))
         (define-key evil-inner-text-objects-map ,key #',inner-name)
         (define-key evil-outer-text-objects-map ,key #',outer-name))))
  )
#+END_SRC

** evil packages that can be used without evil-mode

#+BEGIN_SRC emacs-lisp
(use-package evil-nerd-commenter
  :ensure t
  :bind ("M-;" . evilnc-comment-or-uncomment-lines)
  :init
  ;; evilnc toggles instead of commenting/uncommenting
  (setq evilnc-invert-comment-line-by-line t))

(use-package evil-surround
  :ensure t
  :hook (after-init . global-evil-surround-mode)
  :config
  (evil-define-key 'visual evil-surround-mode-map "s" 'evil-surround-region)
  (defconst my/mark-active-alist
    `((mark-active
       ,@(let ((m (make-sparse-keymap)))
           (define-key m (kbd "C-c s") 'evil-surround-region)
           m))))
  (add-to-list 'emulation-mode-map-alists 'my/mark-active-alist))
#+END_SRC

* Hybrid input mode

# Copied directly from spacemacs

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'evil
  (defcustom hybrid-mode-default-state 'normal
    "Value of `evil-default-state' for hybrid-mode."
    :group 'my
    :type 'symbol)

  (defcustom hybrid-mode-enable-evilified-state t
    "If non nil then evilified states is enabled in buffer supporting it."
    :group 'my
    :type 'boolean)

  (defvar hybrid-mode-default-state-backup evil-default-state
    "Backup of `evil-default-state'.")

  (defadvice evil-insert-state (around hybrid-insert-to-hybrid-state disable)
    "Forces Hybrid state."
    (evil-hybrid-state))

  (defadvice evil-evilified-state (around hybrid-evilified-to-hybrid-state disable)
    "Forces Hybrid state."
    (if (equal -1 (ad-get-arg 0))
        ad-do-it
      (if hybrid-mode-enable-evilified-state
          ad-do-it
        ;; seems better to set the emacs state instead of hybrid for evilified
        ;; buffers
        (evil-emacs-state))))

;;;###autoload
  (define-minor-mode hybrid-mode
    "Global minor mode to replace insert state by hybrid state."
    :global t
    :lighter ""
    :group 'my
    (if hybrid-mode
        (enable-hybrid-editing-style)
      (disable-hybrid-editing-style)))

  (defun enable-hybrid-editing-style ()
    "Enable the hybrid editing style."
    (setq hybrid-mode-default-state-backup evil-default-state
          evil-default-state hybrid-mode-default-state)
    ;; replace evil states by `hybrid state'
    (ad-enable-advice 'evil-insert-state
                      'around 'hybrid-insert-to-hybrid-state)
    (ad-enable-advice 'evil-evilified-state
                      'around 'hybrid-evilified-to-hybrid-state)
    (ad-activate 'evil-insert-state)
    (ad-activate 'evil-evilified-state)
    ;; key bindings hooks for dynamic switching of editing styles
    (run-hook-with-args 'spacemacs-editing-style-hook 'hybrid)
    ;; initiate `hybrid state'
    )

  (defun disable-hybrid-editing-style ()
    "Disable the hybrid editing style (reverting to 'vim style)."
    (setq evil-default-state hybrid-mode-default-state-backup)
    ;; restore evil states
    (ad-disable-advice 'evil-insert-state
                       'around 'hybrid-insert-to-hybrid-state)
    (ad-disable-advice 'evil-evilified-state
                       'around 'hybrid-evilified-to-hybrid-state)
    (ad-activate 'evil-insert-state)
    (ad-activate 'evil-evilified-state)
    ;; restore key bindings
    (run-hook-with-args 'spacemacs-editing-style-hook 'vim)
    ;; restore the states
    )

  ;; This code is from evil insert state definition, any change upstream
  ;; should be reflected here
  ;; see https://github.com/emacs-evil/evil/blob/56e92f7cb4e04e665670460093b41f58446b7a2b/evil-states.el#L108
  (evil-define-state hybrid
    "Hybrid state for hybrid mode."
    :tag " <I> "
    :cursor (bar . 2)
    :message "-- HYBRID --"
    :entry-hook (evil-start-track-last-insertion)
    :exit-hook (evil-cleanup-insert-state evil-stop-track-last-insertion)
    :input-method t
    (cond
     ((evil-hybrid-state-p)
      (add-hook 'post-command-hook #'evil-maybe-remove-spaces)
      (add-hook 'pre-command-hook #'evil-insert-repeat-hook)
      (setq evil-maybe-remove-spaces t)
      (unless (eq evil-want-fine-undo t)
        (evil-start-undo-step)))
     (t
      (remove-hook 'post-command-hook #'evil-maybe-remove-spaces)
      (remove-hook 'pre-command-hook #'evil-insert-repeat-hook)
      (evil-maybe-remove-spaces t)
      (setq evil-insert-repeat-info evil-repeat-info)
      (evil-set-marker ?^ nil t)
      (unless (eq evil-want-fine-undo t)
        (evil-end-undo-step))
      (when evil-move-cursor-back
        (when (or (evil-normal-state-p evil-next-state)
                  (evil-motion-state-p evil-next-state))
          (evil-move-cursor-back))))))

  (define-key evil-hybrid-state-map [escape] 'evil-normal-state)

  ;; Override stock evil function `evil-insert-state-p'
  (defun evil-insert-state-p (&optional state)
    "Whether the current state is insert."
    (and evil-local-mode
         (memq (or state evil-state) '(insert hybrid))))

  (define-key evil-hybrid-state-map [escape] 'evil-normal-state)
  (define-key evil-hybrid-state-map (kbd "C-w") 'evil-delete-backward-word)
  )
#+END_SRC

* Spell checking

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :commands (flyspell-mode flyspell-prog-mode)
  :config
  (add-hook 'flyspell-mode-hook
            (lambda () (add-hook 'hack-local-variables-hook 'flyspell-buffer))))
#+END_SRC

* nix

#+BEGIN_SRC emacs-lisp
(use-package nix-mode
  :ensure t
  :mode (("\\.nix\\'" . nix-mode))
  :init
  (setq nix-nixfmt-bin "nixpkgs-fmt")
  :config
  (my/add-hooks '(nix-mode-hook) (subword-mode 1))
  (my/define-major-mode-key 'nix-mode "s" 'my/nix-format-and-save)
  (my/define-major-mode-key 'nix-mode "m" 'my/nix-mark-multiline-string)
  (define-key nix-mode-map (kbd "C-c '") 'my/nix-edit-indirect-multiline-string))

(defun my/nix-format-and-save ()
  (interactive)
  (nix-format-buffer)
  (save-buffer))

(defun my/nix-mark-multiline-string ()
  (interactive)
  (deactivate-mark)
  (re-search-backward "''$" nil t)
  (next-line)
  (beginning-of-line 1)
  (call-interactively 'set-mark-command)
  (re-search-forward "^\s*''" nil t)
  (previous-line)
  (end-of-line 1))

(defun my/nix-edit-indirect-multiline-string ()
  (interactive)
  (my/nix-mark-multiline-string)
  (my/edit-indirect-region))
#+END_SRC

* direnv

#+begin_src emacs-lisp
(use-package direnv
  :ensure t
  :if (executable-find "direnv")
  :hook (after-init . direnv-mode)
  :init
  (setq direnv-show-paths-in-summary nil
        direnv-always-show-summary nil)
  (unless (fboundp 'file-attribute-size)
    (defun file-attribute-size (attrs) (elt attrs 7))))
#+end_src

* Haskell

#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :ensure t
  :mode (("\\.hs\\'" . haskell-mode)
         ("\\.lhs\\'" . literate-haskell-mode)
         ("\\.cabal\\'" . haskell-cabal-mode)
         ("\\.c2hs\\'" . haskell-c2hs-mode)
         ("\\.hcr\\'" . ghc-core-mode)
         ("\\.dump-simpl\\'" . ghc-core-mode))
  :init
  (setq haskell-align-imports-pad-after-name t
        haskell-hoogle-command "hoogle --count=100"
        haskell-interactive-popup-errors nil
        ;; choices: auto, ghci, cabal-repl, cabal-new-repl, stack-ghci
        ;; cabal-new-repl is the one to use with nix-shell & direnv
        haskell-process-type 'cabal-new-repl
        )

  (with-eval-after-load 'evil
    (my/evil-define-text-object "haskell-inline-comment" "#" "{- " " -}"))

  ;; TODO: sort out this shit
  (with-eval-after-load 'smartparens
    (with-eval-after-load 'haskell-mode
      (sp-local-pair 'haskell-mode "'" nil :actions nil)))

  :config
  (my/highlight-keyword-in-mode 'haskell-mode "error" nil 'font-lock-preprocessor-face)
  (my/highlight-keyword-in-mode 'haskell-mode "undefined" nil 'font-lock-preprocessor-face)

  (my/define-major-mode-key 'haskell-mode "aa" 'my/haskell-align-and-sort-everything)
  (my/define-major-mode-key 'haskell-mode "ai" 'my/haskell-align-and-sort-imports)
  (my/define-major-mode-key 'haskell-mode "al" 'my/haskell-align-and-sort-language-extensions)
  (my/define-major-mode-key 'haskell-mode "c" 'projectile-compile-project)
  (my/define-major-mode-key 'haskell-mode "d" 'my/haskell-open-haddock-documentation)
  (my/define-major-mode-key 'haskell-mode "h" 'hoogle)
  (my/define-major-mode-key 'haskell-mode "i" 'my/haskell-insert-import)
  (my/define-major-mode-key 'haskell-mode "l" 'my/haskell-insert-language-extension)
  (my/define-major-mode-key 'haskell-mode "o" 'my/haskell-insert-ghc-option)
  (my/define-major-mode-key 'haskell-mode "r" 'my/haskell-insert-ghcid-repl-statement)
  (my/define-major-mode-key 'haskell-mode "s" 'my/haskell-format-and-save)
  (my/define-major-mode-key 'haskell-mode "/" 'engine/search-hoogle)
  (my/define-major-mode-key 'haskell-mode "?" 'engine/search-stackage)
  (my/define-major-mode-key 'haskell-mode "#" 'engine/search-haskell-language-extensions)

  (my/add-hooks
   '(haskell-mode-hook)
   (setq evil-shift-width 2)
   (push '(?# . ("{- " . " -}")) evil-surround-pairs-alist)
   (haskell-decl-scan-mode)
   (subword-mode 1)
   )
  )

(use-package ormolu
  :ensure t
  :commands (ormolu-format
             ormolu-format-buffer
             ormolu-format-region
             ormolu-format-on-save-mode)
  :init
  (setq ormolu-extra-args
        '("-o" "-XTypeApplications"
          "-o" "-XInstanceSigs"
          "-o" "-XBangPatterns"
          "-o" "-XPatternSynonyms"
          "-o" "-XUnicodeSyntax"
          )))

(defvar my/haskell-align-stuff t)
(defvar my/haskell-use-ormolu nil)

(defun my/haskell-format-brittany ()
  (interactive)
  (my/format-and-save "brittany"))

(defun my/haskell-format-and-save (use-ormolu)
  "Formats the import statements using haskell-stylish and saves
the current file."
  (interactive "P")
  (save-buffer)
  (if (or use-ormolu my/haskell-use-ormolu)
      (ormolu-format-buffer)
    (progn
      (my/haskell-align-and-sort-imports)
      (my/haskell-align-and-sort-language-extensions)))
  (save-buffer))

(defun my/haskell-align-and-sort-imports ()
  (interactive)
  (save-excursion
    (goto-char 0)
    (let ((n-runs 0)
          (max-runs 10))
      (while (and (< n-runs max-runs)
                  (haskell-navigate-imports))
        (progn
          (setq n-runs (1+ n-runs))
          (when my/haskell-align-stuff (call-interactively 'haskell-align-imports))
          (call-interactively 'haskell-sort-imports)))
      (if (>= n-runs max-runs)
          (message "Sorting/aligning imports probably timed out")))))

(defun my/-haskell-mark-language-extensions ()
  (interactive)
  (deactivate-mark)
  (goto-char 0)
  (re-search-forward "^{-# LANGUAGE" nil t)
  (beginning-of-line 1)
  (call-interactively 'set-mark-command)
  (while (re-search-forward "^{-# LANGUAGE" nil t)
    nil)
  (end-of-line 1))

(defun my/haskell-align-and-sort-language-extensions ()
  (interactive)
  (save-excursion
    (when my/haskell-align-stuff
      (my/-haskell-mark-language-extensions)
      (align-regexp (region-beginning) (region-end) "\\(\\s-*\\)#-"))
    (my/-haskell-mark-language-extensions)
    (sort-lines nil (region-beginning) (region-end))))

(defun my/haskell-insert-language-extension ()
  (interactive)
  (let* ((all-exts
          (split-string (shell-command-to-string "ghc --supported-languages")))
         (ext
          (completing-read "extension: "
                           all-exts
                           nil nil nil nil nil)))
    (save-excursion
      (goto-char 0)
      (re-search-forward "^{-#" nil t)
      (beginning-of-line 1)
      (open-line 1)
      (insert (format "{-# LANGUAGE %s #-}" ext))
      (my/haskell-align-and-sort-language-extensions))))

(defun my/haskell-insert-ghc-option ()
  (interactive)
  (let* ((all-opts
          (split-string (shell-command-to-string "ghc --show-options")))
         (ext
          (completing-read "option: "
                           all-opts
                           nil nil nil nil nil)))
    (save-excursion
      (goto-char 0)
      (re-search-forward "^module" nil t)
      (beginning-of-line 1)
      (open-line 1)
      (insert (format "{-# OPTIONS_GHC %s #-}" ext)))))

(defun my/haskell-insert-import (&optional qualified)
  (interactive "P")
  (let* ((prompt (format "import%s: " (if qualified " qualified" "")))
         (module (read-from-minibuffer
                  prompt nil nil nil
                  'my/haskell-insert-import-import-hist))
         (suff (if qualified
                   (read-from-minibuffer
                    "as: " nil nil nil
                    'my/haskell-insert-import-as-hist)
                 (read-from-minibuffer
                  "imports: " nil nil nil
                  'my/haskell-insert-import-imports-hist))))
    (save-excursion
      (goto-char 0)
      (while (re-search-forward "^import" nil t)
        nil)
      (next-line 1)
      (open-line 1)
      (insert
       (format "import%s%s%s"
               (if qualified " qualified " " ")
               module
               (if qualified (format " as %s" suff) (if (string= "" suff) "" (format " (%s)" suff)))
               )))))

(defun my/haskell-align-and-sort-everything ()
  (interactive)
  (my/haskell-align-and-sort-imports)
  (my/haskell-align-and-sort-language-extensions))

(defun my/haskell-insert-ghcid-repl-statement (new-line)
  (interactive "P")
  (setq current-prefix-arg nil)
  (when new-line
    (end-of-line 1)
    (call-interactively 'newline))
  (beginning-of-line 1)
  (call-interactively 'delete-horizontal-space)
  (insert "-- $> "))

(defun my/haskell-open-haddock-documentation (use-eww)
  (interactive "P")
  (let ((url "https://haskell-haddock.readthedocs.io/en/latest/markup.html"))
    (if use-eww
        (eww url)
      (browse-url url))))

(defvar my/ghc-source-path (expand-file-name "~/sources/ghc/"))

(defun my/visit-ghc-tags-table ()
  (interactive)
  (let ((tags (concat my/ghc-source-path "TAGS")))
    (if (file-exists-p tags)
        (visit-tags-table tags)
      (error "No TAGS file found in ghc source directory"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(use-package intero
  :ensure t
  :after haskell-mode
  :commands (intero-mode-blacklist)
  :hook (haskell-mode . intero-mode-blacklist)
  :diminish intero-mode
  :init
  (setq intero-blacklist '("~/.xmonad"))
  :config
  ;; pretty print (use :pretty, :prettyl, :no-pretty in ghci)
  ;; this has to be installed in every repo until I find a solution
  ;; (setq intero-extra-ghci-options '("-package" "pretty-simple"))

  ;; don't auto insert matching single quotes in haskell mode, since I
  ;; mostly use them for promoted data types
  (define-key intero-mode-map (kbd "M-.") nil)
  (sp-local-pair 'intero-repl-mode "'" nil :actions nil)

  (flycheck-add-next-checker 'intero '(t . haskell-hlint)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(use-package dante
  :ensure t
  :after haskell-mode
  :commands (dante-mode)
  :hook (haskell-mode . dante-mode)
  :init
  (add-hook 'dante-mode-hook
            '(lambda () (flycheck-add-next-checker
                         'haskell-dante
                         '(warning . haskell-hlint)))))
#+END_SRC

* Purescript

#+BEGIN_SRC emacs-lisp
(defvar my/purescript-align-stuff t)

(defun my/purescript-sort-and-align-imports ()
  (interactive)
  (save-excursion
    (goto-line 1)
    (while (purescript-navigate-imports)
      (progn
        (purescript-sort-imports)
        (when my/purescript-align-stuff (purescript-align-imports))))
    (purescript-navigate-imports-return)))

(defun my/purescript-format-and-save ()
  "Formats the import statements using haskell-stylish and saves
the current file."
  (interactive)
  (my/purescript-sort-and-align-imports)
  (save-buffer))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package purescript-mode
  :ensure t
  :mode ("\\.purs\\'" . purescript-mode)
  :init
  (setq purescript-indent-offset 2
        purescript-align-imports-pad-after-name t)
  :config
  (my/define-major-mode-key 'purescript-mode "a" 'my/purescript-sort-and-align-imports)
  (my/define-major-mode-key 'purescript-mode "i" 'purescript-navigate-imports)
  (my/define-major-mode-key 'purescript-mode "s" 'my/purescript-format-and-save)
  (my/define-major-mode-key 'purescript-mode "/" 'engine/search-pursuit)
  (add-hook
   'purescript-mode-hook
   (lambda ()
     (setq evil-shift-width 2)
     (turn-on-purescript-indentation)
     (turn-on-purescript-decl-scan)
     ;; (turn-on-purescript-font-lock)
     (push '(?# . ("{- " . " -}")) evil-surround-pairs-alist)
     (subword-mode 1)
     (make-variable-buffer-local 'find-tag-default-function)
     (setq find-tag-default-function (lambda () (current-word t t)))
     ))
  ;; xref for purescript works a bit weird with qualified identifiers
  ;; (define-key purescript-mode-map (kbd "M-.")
  ;; #'(lambda () (interactive) (xref-find-definitions (current-word t t))))
  )

;; This needs to exist in custom/
(use-package custom-purescript-font-lock
  :after purescript-mode)

;; copy these into the purescript-mode definition
;; (setq-local font-lock-defaults
;;             '((purescript-font-lock-keywords)
;;               nil nil nil nil
;;               (font-lock-syntactic-face-function
;;                . purescript-syntactic-face-function)
;;               (parse-sexp-lookup-properties . t)
;;               (font-lock-extra-managed-props . (composition purescript-type))))
;; (setq-local font-lock-multiline t)
#+END_SRC

* Python

#+BEGIN_SRC emacs-lisp
(use-package python
  :mode ("\\.py\\'" . python-mode)
  :bind (:map python-mode-map
              ("C-c C-j" . counsel-imenu))
  :init
  (setq python-shell-prompt-detect-failure-warning nil)
  :config
  (my/add-hooks
   '(python-mode-hook)
   (setq-default flycheck-disabled-checkers
                 (append flycheck-disabled-checkers
                         '(python-pycompile)))))

(defun my/mode-line-venv ())
(use-package pyvenv
  :ensure t
  :after python
  :commands (pyvenv-workon)
  :config
  (defun my/mode-line-venv ()
    (if (string= major-mode "python-mode")
        (let ((venv (if (null pyvenv-virtual-env-name)
                        "-"
                      pyvenv-virtual-env-name)))
          (concat
           "["
           (propertize venv 'face '(:underline t))
           "] "))
      "")))

(use-package blacken
  :ensure t
  :if (executable-find "black")
  :after python
  :commands (blacken-mode blacken-buffer)
  :init
  (setq blacken-line-length 80)
  (defun my/python-format-and-save ()
    (interactive)
    (blacken-buffer)
    (save-buffer))
  (my/define-major-mode-key 'python-mode "s" 'my/python-format-and-save))

(use-package anaconda-mode
  :ensure t
  :defer t
  :hook ((python-mode . anaconda-mode)
         (python-mode . anaconda-eldoc-mode)
         )
  :diminish anaconda-mode
  :diminish anaconda-eldoc-mode)

(defun eshell/workon (arg) (pyvenv-workon arg))
(defun eshell/deactivate () (pyvenv-deactivate))
#+END_SRC

* js/ts/html/css

#+BEGIN_SRC emacs-lisp
(use-package rjsx-mode
  :ensure t
  :mode (("\\.jsx?\\'" . rjsx-mode))
  :init
  (setq js2-mode-show-strict-warnings nil)
  :config
  (my/define-major-mode-key 'rjsx-mode "s" 'my/prettier-and-save)
  (my/add-hooks
   '(rjsx-mode-hook)
   (setq evil-shift-width 2)
   (define-key js2-mode-map (kbd "C-c C-f") nil)))

(use-package typescript-mode
  :ensure t
  :mode (("\\.ts\\'" . typescript-mode))
  :init
  (setq typescript-indent-level 2)
  :config
  (my/define-major-mode-key 'typescript-mode "s" 'my/prettier-and-save)
  (my/add-hooks
   '(typescript-mode-hook)
   (subword-mode 1)
   (setq evil-shift-width 2)))

(use-package web-mode
  :ensure t
  :mode (("\\.html\\'" . web-html-mode)
         ("\\.tsx\\'" . web-tsx-mode))
  :init
  (setq web-mode-markup-indent-offset 2
        web-mode-css-indent-offset 2
        web-mode-code-indent-offset 2
        web-mode-attr-indent-offset 2)
  (define-derived-mode web-tsx-mode web-mode "web-tsx")
  (define-derived-mode web-html-mode web-mode "web-html")
  :config
  ;; web-tsx-mode
  (my/define-major-mode-key 'web-tsx-mode "s" 'my/prettier-and-save)
  (my/add-hooks '(web-tsx-mode) (subword-mode 1)))

(use-package css-mode
  :mode (("\\.css\\'" . css-mode))
  :init
  (setq css-indent-offset 2
        css-fontify-colors nil))

(use-package js
  :commands (js-mode)
  :init
  (setq js-indent-level 2))

;; (use-package prettier-js
;;   :ensure t
;;   :commands (prettier-js prettier-js-mode my/prettier-and-save)
;;   :init
;;   (setq prettier-js-args '("--trailing-comma" "es5"
;;                            "--tab-width" "2"
;;                            "--semi" "false"
;;                            "--single-quote" "false")))

(defun my/prettier-and-save ()
  (interactive)
  ;; (prettier-js)
  (unless (executable-find "prettier")
    (user-error "`prettier' executable not found"))
  (let* ((fn (file-name-nondirectory buffer-file-name)))
    (my/format-and-save "prettier" "--stdin" "--stdin-filepath" fn))
  (save-buffer))

(use-package emmet-mode
  :ensure t
  :commands (emmet-expand-line)
  :bind (("<C-return>" . emmet-expand-line))
  :hook ((web-html-mode html-mode css-mode) . emmet-mode))
#+END_SRC

* Lisps
** all lisps

#+BEGIN_SRC emacs-lisp
;; expand macros in another window
(define-key
  lisp-mode-map
  (kbd "C-c C-m")
  #'(lambda () (interactive) (macrostep-expand t)))

(my/add-hooks
 '(lisp-mode-hook emacs-lisp-mode-hook lisp-interaction-mode-hook)
 (eldoc-mode))
#+END_SRC

** emacs lisp

#+BEGIN_SRC emacs-lisp
(use-package elisp-mode
  :mode (("\\.el\\'" . emacs-lisp-mode)
         ("\\.elc\\'" . elisp-byte-code-mode))
  :config
  (defun my/emacs-lisp-format-and-save ()
    (interactive)
    (my/indent-region-or-buffer)
    (save-buffer))

  (my/define-major-mode-key 'emacs-lisp-mode "s" #'my/emacs-lisp-format-and-save))
#+END_SRC

* Coq (proof-general)

#+BEGIN_SRC emacs-lisp
(use-package proof-general
  :ensure t
  :init
  (setq proof-splash-enable nil
        proof-script-fly-past-comments t))

(use-package holes
  :ensure proof-general
  :after proof-general coq-mode
  :commands (holes-mode)
  :diminish)

(use-package coq-mode
  :ensure proof-general
  :mode (("\\.v\\'" . coq-mode))
  :bind (:map coq-mode-map
              ("C-c ." . proof-electric-terminator-toggle))
  :init
  (setq coq-one-command-per-line nil
        coq-compile-before-require t)
  :config
  (add-hook 'my/after-set-theme-hook 'coq-highlight-selected-hyps)
  (my/add-hooks
   '(coq-mode-hook)
   (setq evil-shift-width 2)
   (push '(?# . ("(* " . " *)")) evil-surround-pairs-alist)
   (undo-tree-mode 1)
   (whitespace-mode 1)))
#+END_SRC

* Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :bind (:map markdown-mode-map
              ("M-a" . beginning-of-defun)
              ("M-e" . end-of-defun)
              ("TAB" . my/markdown-toggle-heading)
              ("<tab>" . my/markdown-toggle-heading))
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode)
         ("\\.page\\'" . gfm-mode))
  :init
  (if (executable-find "marked")
      (setq markdown-command "marked"))
  (setq markdown-asymmetric-header t
        markdown-gfm-use-electric-backquote nil
        markdown-css-paths
        (list (expand-file-name (concat user-emacs-directory "static/github.css")))
        )
  :config
  (my/add-hooks
   '(markdown-mode-hook)
   (auto-fill-mode 1)
   (whitespace-mode +1)
   ;; (orgtbl-mode +1)
   (push '(?# . ("<!-- " . " -->")) evil-surround-pairs-alist))

  (defun markdown-org-table-align-advice ()
    "Replace \"+\" sign with \"|\" in tables."
    (when (member major-mode '(markdown-mode gfm-mode))
      (save-excursion
        (save-restriction
          (narrow-to-region (org-table-begin) (org-table-end))
          (goto-char (point-min))
          (while (search-forward "-+-" nil t)
            (replace-match "-|-"))))))
  (advice-add 'org-table-align :after 'markdown-org-table-align-advice)

  (defun my/markdown-toggle-heading ()
    (interactive)
    (when (markdown-heading-at-point)
      (outline-toggle-children))))

(use-package markdown-toc
  :ensure t
  :after markdown-mode
  :commands (markdown-toc-refresh-toc
             markdown-toc-generate-toc
             markdown-toc-generate-or-refresh-toc)
  :init
  (defalias 'mtoc 'markdown-toc-generate-or-refresh-toc))
#+END_SRC

* Other prog modes
** Idris

#+BEGIN_SRC emacs-lisp
(use-package idris-mode
  :ensure t
  :mode ("\\.idr\\'" . idris-mode))
#+END_SRC

** Agda

#+BEGIN_SRC emacs-lisp
(defvar my/agda-mode-path
  (expand-file-name
   (concat user-emacs-directory "lisp/agda-mode")))

(defvar my/agda-path "agda")

(use-package agda2-mode
  :if (and (file-directory-p my/agda-mode-path)
           (executable-find my/agda-path))
  :load-path my/agda-mode-path
  :mode ("\\.l?agda\\'" . agda2-mode)
  :init
  (setq agda2-program-name my/agda-path))
#+END_SRC

** Rust

#+BEGIN_SRC emacs-lisp :tangle no
(use-package rust-mode
  :ensure t
  :mode ("\\.rs\\'" . rust-mode)
  :init
  (defvar my/rust-sysroot  "~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu")
  (defvar my/rust-src-path (concat my/rust-sysroot "/lib/rustlib/src/rust/src"))
  (setq racer-cmd "~/.cargo/bin/racer")
  (setq racer-rust-src-path my/rust-src-path)
  (setenv "RUST_SRC_PATH" my/rust-src-path)
  (setq cargo-process--custom-path-to-bin "~/.cargo/bin")
  :config
  (add-hook 'rust-mode-hook 'eldoc-mode)
  (my/define-major-mode-key 'rust-mode "f" 'rust-format-buffer)
  (my/define-major-mode-key 'rust-mode "s" 'my/rust-format-and-save))

(defun my/rust-format-and-save ()
  (interactive)
  (call-interactively 'rust-format-buffer)
  (save-buffer))

(use-package racer
  :ensure t
  :after rust-mode
  :hook (rust-mode . racer-mode))

(use-package cargo
  :ensure t
  :after rust-mode
  :hook (rust-mode . cargo-minor-mode))

(use-package flycheck-rust
  :ensure t
  :after (flycheck rust-mode)
  :hook (flycheck-mode . flycheck-rust-setup))
#+END_SRC

** c/c++

#+BEGIN_SRC emacs-lisp
(setq c-default-style "linux"
      c-basic-offset 4)
#+END_SRC

** dhall

#+BEGIN_SRC emacs-lisp
(use-package dhall-mode
  :ensure t
  :mode ("\\.dhall\\'" . dhall-mode)
  :init
  (setq dhall-format-at-save nil
        dhall-format-arguments '("--ascii"))

  (with-eval-after-load 'smartparens
    (with-eval-after-load 'dhall-mode
      (sp-local-pair 'dhall-mode "\\(" ")")))

  :config
  (my/add-hooks
   '(dhall-mode-hook)
   (setq indent-tabs-mode nil)
   (setq evil-shift-width 2))
  (my/define-major-mode-key 'dhall-mode "d" #'my/dhall-browse-docs)
  (my/define-major-mode-key 'dhall-mode "s" #'my/dhall-format-and-save)
  (my/define-major-mode-key 'dhall-mode "t" #'my/dhall-show-type))

(defun my/dhall-format-and-save ()
  (interactive)
  (dhall-format-buffer)
  (save-buffer))

(defun my/dhall-show-type ()
  (interactive)
  (let ((tp (dhall-buffer-type))
        (errbuf (get-buffer "*dhall-buffer-type-errors*")))
    (if (null tp)
        (display-buffer-below-selected errbuf '(nil (inhibit-same-window .t)))
      (message tp))))

(defun my/dhall-browse-docs ()
  (interactive)
  (browse-url "https://docs.dhall-lang.org/references/Built-in-types.html"))
#+END_SRC

** bazel

#+begin_src emacs-lisp
(use-package bazel-mode
  :ensure t
  :mode (("\\.bazel\\'" . bazel-mode)
         ("\\.bzl\\'" . bazel-mode))
  :config
  (my/define-major-mode-key 'bazel-mode "s" #'my/bazel-format-and-save))

(defun my/bazel-format-and-save ()
  (interactive)
  (let* ((fn (file-name-nondirectory buffer-file-name))
         (ext (file-name-extension fn))
         (tp (cond
              ((string= fn "BUILD.bazel") "build")
              ((string= ext "bzl") "bzl")
              (t (user-error (format "Not a bazel file extension: %s" ext))))))
    (my/format-and-save "buildifier" "--type" tp))
  (save-buffer))
#+end_src

** nginx

#+begin_src emacs-lisp
(use-package nginx-mode
  :ensure t
  :mode (("nginx\\.conf\\'" . nginx-mode)
         ("nginx\\.conf\\.template\\'" . nginx-mode)))
#+end_src

** terraform

#+begin_src emacs-lisp
(use-package terraform-mode
  :ensure t
  :mode ("\\.tf\\'" . terraform-mode)
  :config
  (my/define-major-mode-key 'terraform-mode "s" #'my/terraform-format-and-save))

(defun my/terraform-format-and-save ()
  (interactive)
  (terraform-format-buffer)
  (save-buffer))
#+end_src

** docker

#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :ensure t
  :mode ("Dockerfile.*" . dockerfile-mode))
#+END_SRC

** elasticsearch

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '(".es\\'" . js-mode))
#+end_src

** json

#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :ensure t
  :mode (("\\.json\\'" . json-mode)
         ("\\.json.tmpl\\'" . json-mode))
  :config
  (my/define-major-mode-key 'json-mode "s" #'my/json-format-and-save))

(defun my/json-format-and-save ()
  (interactive)
  (json-mode-beautify)
  (save-buffer))
#+END_SRC

** yaml

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :ensure t
  :mode (("\\.ya?ml\\'" . yaml-mode)
         ("\\.ya?ml.template\\'" . yaml-mode)))

(use-package flycheck-yamllint
  :ensure t
  :after (flycheck yaml-mode)
  :commands (flycheck-yamllint-setup)
  :hook (yaml-mode . flycheck-yamllint-setup))
#+END_SRC

** asciidoc

#+BEGIN_SRC emacs-lisp
(use-package adoc-mode
  :ensure t
  :mode ("\\.adoc\\'" . adoc-mode))
#+END_SRC

** reStructuredText

#+BEGIN_SRC emacs-lisp
(use-package rst
  :mode ("\\.rst\\'" . rst-mode)
  :bind (:map rst-mode-map
              ("M-a" . rst-backward-section)
              ("M-e" . rst-forward-section))
  :init
  (setq rst-indent-width 2)
  :config
  (my/add-hooks
   '(rst-mode-hook)
   (setq evil-shift-width rst-indent-width)))
#+END_SRC

* Other major modes
** deft

#+begin_src emacs-lisp
(use-package deft
  :ensure t
  :bind (("<f8>" . deft)
         ("C-x <f8>" . deft-find-file))
  :commands (deft deft-cache-initialize
              deft-parse-title deft-sort-files-by-mtime)
  :init
  (setq deft-directory (concat my/dropbox-dir "deft")
        deft-recursive t
        deft-extensions '("md" "org" "txt")
        deft-ignore-file-regexp "_sidebar\.md\\|index\.md"
        deft-markdown-mode-title-level 1
        deft-use-filter-string-for-filename t
        deft-file-naming-rules '((noslash . "_")
                                 (nospace . "_")
                                 (case-fn . downcase)))
  (with-eval-after-load 'markdown-mode
    (define-key markdown-mode-map (kbd "C-c <f8>") 'my/generate-deft-link))

  (defun my/deft-search ()
    (interactive)
    (counsel-rg ""
                deft-directory
                "-g !_sidebar.md -g !index.md -g !index.html -g !static/"))
  (defalias 'ds 'my/deft-search)

  :config
  (advice-add 'deft-cache-update-all :after 'my/deft-docsify-write-sidebar))

(defun my/get-deft-file-by-title ()
  (if (or (not (boundp 'deft-hash-mtimes)) (null deft-hash-mtimes))
      (deft-cache-initialize)
    (deft-cache-update-all))
  (let* ((files (deft-sort-files-by-mtime (deft-find-all-files)))
         (titles (mapcar 'deft-file-title files))
         (cands (-zip titles files))
         (title (completing-read "Deft file: " titles)))
    (assoc title cands)))

(defun my/get-deft-file-by-filename ()
  (let* ((name
          (string-trim-left
           (completing-read "Deft file: " (deft-find-all-files-no-prefix))
           "/"))
         (dir (string-trim-right (expand-file-name deft-directory) "/"))
         (path (concat dir "/" name))
         (contents (with-temp-buffer
                     (insert-file-contents path)
                     (buffer-string)))
         (title (deft-parse-title path contents)))
    `(,title . ,path)))

(defun my/generate-deft-link (by-filename)
  "Interactively generate a relative markdown link to a deft file.

With prefix arg or non-nil BY-FILENAME the completion shows the filenames
instead of the title as seen by deft."
  (interactive "P")
  (when (or (null (buffer-file-name))
            (not (string-prefix-p (expand-file-name deft-directory)
                                  (file-name-directory (buffer-file-name)))))
    (user-error "Not currently editing a deft file"))
  (let* ((info (if by-filename
                   (my/get-deft-file-by-filename)
                 (my/get-deft-file-by-title)))
         (title (car info))
         (path (cdr info))
         (prompt (format "Link text [%s]: " title))
         (link-text (read-string prompt nil nil title))
         (curdir (file-name-directory (buffer-file-name)))
         (link-path (file-relative-name path curdir)))
    (insert (format "[%s](%s)" link-text link-path))))

(defun my/deft-docsify-sidebar-content ()
  (let* ((files (deft-sort-files-by-mtime (deft-find-all-files)))
         (titles (mapcar 'deft-file-title files))
         (dd (expand-file-name deft-directory))
         (paths (mapcar '(lambda (p) (file-relative-name p dd)) files))
         (pairs (-zip titles paths)))
    (setq foo pairs)
    (-reduce-from
     #'(lambda (acc pair)
         (let* ((fname (car pair))
                (path (cdr pair))
                (link (format "[%s](%s)" fname path)))
           (concat acc "- " link "\n")))
     "- [Index](index.md)\n"
     pairs)))

(defun my/deft-docsify-write-sidebar ()
  (let* ((dir (string-trim-right (expand-file-name deft-directory) "/"))
         (fname "_sidebar.md")
         (path (concat dir "/" fname)))
    (with-temp-file path
      (erase-buffer)
      (insert (my/deft-docsify-sidebar-content)))))

(defun my/wiki-refresh ()
  (interactive)
  (when (or (not (boundp 'deft-hash-mtimes)) (null deft-hash-mtimes))
    (deft-cache-initialize))
  (deft-cache-update-all)
  (my/deft-docsify-write-sidebar))
#+end_src

** elfeed

#+BEGIN_SRC emacs-lisp
(use-package elfeed-web
  :ensure t
  :commands (elfeed-web-start)
  :after elfeed)

(use-package elfeed
  :ensure t
  :commands (elfeed)
  :bind (:map elfeed-search-mode-map
              ("h" . backward-char)
              ("j" . next-line)
              ("k" . previous-line)
              ("l" . forward-char)
              :map elfeed-show-mode-map
              ("h" . backward-char)
              ("j" . next-line)
              ("k" . previous-line)
              ("l" . forward-char)
              ("w" . forward-word)
              ("b" . backward-word))
  :init
  (setq elfeed-db-directory (concat my/dropbox-dir "elfeed"))
  :config
  (defun my/elfeed-hide-images (tog)
    (interactive "P")
    (let ((shr-inhibit-images (not tog)))
      (elfeed-show-refresh)))

  (define-key elfeed-search-mode-map (kbd "U") #'elfeed-update)
  (define-key elfeed-show-mode-map (kbd "i") #'my/elfeed-hide-images)
  (add-hook 'elfeed-show-mode-hook #'(lambda () (setq-local shr-width 100)))

  (setq elfeed-search-filter "@10-days-ago +unread"
        elfeed-db-directory (concat my/dropbox-dir "elfeed"))

  (add-hook 'elfeed-new-entry-hook
            (elfeed-make-tagger :before "2 weeks ago"
                                :remove 'unread))

  (add-hook 'elfeed-search-update-hook #'elfeed-db-save)
  (add-hook 'elfeed-update-init-hooks #'elfeed-db-save)

  (defface my/elfeed-important
    '((t (:foreground "salmon")))
    "Elfeed unread"
    :group 'my/faces)
  (push '(important my/elfeed-important) elfeed-search-face-alist)

  ;; get feeds from personal dir
  (load-file (concat my/dropbox-dir "lisp/elfeed-feeds.el")))
#+END_SRC

** pdf tools

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :ensure t
  :defer t
  :magic ("%PDF" . pdf-view-mode)
  :bind (:map pdf-view-mode-map
              ("j" . pdf-view-next-line-or-next-page)
              ("k" . pdf-view-previous-line-or-previous-page)
              ("h" . image-backward-hscroll)
              ("l" . image-forward-hscroll)
              ("C-s" . isearch-forward))
  :init
  (setq pdf-view-display-size 'fit-page
        pdf-view-midnight-colors '("#b3dfdd" . "#0a3749"))
  :config
  (pdf-tools-install :no-query))

(use-package pdf-outline
  :defer t
  :bind (:map pdf-outline-buffer-mode-map
              ("<backtab>" . outline-hide-sublevels)))
#+END_SRC

** erc

#+BEGIN_SRC emacs-lisp
(use-package erc
  :defer t
  :commands (erc my/erc-freenode)
  :init
  (setq erc-rename-buffers t
        erc-prompt-for-nickserv-password nil
        erc-autojoin-timing 'ident
        erc-fill-function 'erc-fill-static
        erc-fill-static-center 22
        erc-server-reconnect-attempts 5
        erc-server-reconnect-timeout 3
        erc-interpret-mirc-color t
        erc-lurker-hide-list '("JOIN" "PART" "QUIT")
        erc-autojoin-channels-alist '(("freenode.net" "#haskell"))
        erc-fill-column 80
        my/erc-default-nick "runforestrun"
        )
  :config
  (defun my/erc-freenode (select-nick)
    (interactive "P")
    (let ((nick
           (if select-nick
               (read-string "Nick: ")
             my/erc-default-nick)))
      (erc :server "irc.freenode.net" :port 6667 :nick nick)))

  (defun my/erc-preprocess (string)
    "Avoids channel flooding."
    (setq str
          (string-trim
           (replace-regexp-in-string "\n+" " " str))))

  (defun my/erc-switch-to-buffer ()
    (interactive)
    (let ((read-buffer-function nil))
      (call-interactively 'erc-switch-to-buffer)))
  (define-key erc-mode-map (kbd "C-c C-b") 'my/erc-switch-to-buffer))

;; put a bar after the last read message in erc
;; https://www.emacswiki.org/emacs/ErcBar
(use-package erc-track
  :after erc
  :config
  (defun erc-bar-move-back (n)
    "Moves back n message lines. Ignores wrapping, and server messages."
    (interactive "nHow many lines ? ")
    (re-search-backward "^.*<.*>" nil t n))

  (defun erc-bar-update-overlay ()
    "Update the overlay for current buffer, based on the content of
erc-modified-channels-alist. Should be executed on window change."
    (interactive)
    (let* ((info (assq (current-buffer) erc-modified-channels-alist))
	   (count (cadr info)))
      (if (and info (> count erc-bar-threshold))
	  (save-excursion
	    (end-of-buffer)
	    (when (erc-bar-move-back count)
	      (let ((inhibit-field-text-motion t))
		(move-overlay erc-bar-overlay
			      (line-beginning-position)
			      (line-end-position)
			      (current-buffer)))))
	(delete-overlay erc-bar-overlay))))

  (defvar erc-bar-threshold 0
    "Display bar when there are more than erc-bar-threshold unread messages.")
  (defvar erc-bar-overlay nil
    "Overlay used to set bar")
  (setq erc-bar-overlay (make-overlay 0 0))
  (overlay-put erc-bar-overlay 'face '(:overline "grey40"))
  ;;put the hook before erc-modified-channels-update
  (defadvice erc-track-mode (after erc-bar-setup-hook
				   (&rest args) activate)
    ;;remove and add, so we know it's in the first place
    (remove-hook 'window-configuration-change-hook 'erc-bar-update-overlay)
    (add-hook 'window-configuration-change-hook 'erc-bar-update-overlay))
  (add-hook 'erc-send-completed-hook (lambda (str)
				       (erc-bar-update-overlay))))

;; https://www.reddit.com/r/emacs/comments/8ml6na/tip_how_to_make_erc_fun_to_use/
(use-package erc-hl-nicks
  :ensure t
  :after erc
  :init
  (setq erc-hl-nicks-skip-nicks '("so" "So" "bind" "hackage")))
#+END_SRC

** restclient

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :ensure t
  :mode ("\\.http\\'" . restclient-mode)
  :config
  (add-hook 'restclient-mode-hook 'evil-local-mode))
#+END_SRC

** ledger

#+BEGIN_SRC emacs-lisp :tangle no
(use-package ledger-mode
  :ensure t
  :mode ("\\.h?ledger\\..*\\'" . ledger-mode)
  :init
  (setq ledger-mode-should-check-version nil
        ledger-report-links-in-register nil
        ledger-binary-path "hledger"))
#+END_SRC

* Searching
** isearch

#+BEGIN_SRC emacs-lisp
(use-package isearch
  :init
  (setq search-whitespace-regexp ".*?"  ;; spaces match anything
        isearch-lax-whitespace t  ;; the default
        isearch-regex-lax-whitespace nil
        isearch-lazy-count t  ;; show match count and current match index
        lazy-count-prefix-format "(%s/%s) "
        lazy-count-suffix-format nil)
  :config
  (define-key isearch-mode-map
    (kbd "M-s M-s")
    (lambda () (interactive) (isearch-exit) (swiper isearch-string))))
#+END_SRC

** rg

#+BEGIN_SRC emacs-lisp
(use-package rg
  :ensure t
  :commands (rg my/rg-project-or-ask)
  :bind (:map rg-mode-map
              ("m" . rg-menu)
              ("s" . my/rg-save-search-as-name)
              ("N" . my/rg-open-ace-window)
              ("C-n" . next-line)
              ("C-p" . previous-line)
              ("j" . next-line)
              ("k" . previous-line)
              ("M-n" . rg-next-file)
              ("M-p" . rg-prev-file))
  :init
  (setq rg-group-result t
        rg-ignore-case 'smart)
  (setq rg-custom-type-aliases
        '(("coq" . "*.v")))
  (defalias 'rgp 'my/rg-project-or-ask)
  :config
  (rg-define-toggle "--multiline --multiline-dotall" "u")
  (rg-define-toggle "--word-regexp" "w")
  (rg-define-search my/rg-project-or-ask
    :query ask
    :format regexp
    :files "all"
    :dir (or (projectile-project-root)
             (read-directory-name "rg in: "))
    :confirm prefix)

  ;; https://protesilaos.com/dotemacs/#h:31622bf2-526b-4426-9fda-c0fc59ac8f4b
  (defun my/rg-save-search-as-name ()
    "Save `rg' buffer, naming it after the current search query."
    (interactive)
    (let ((pattern (rg-search-pattern rg-cur-search)))
      (rg-save-search-as-name (concat "«" pattern "»"))))

  (defun my/rg-open-ace-window (&optional event)
    (interactive)
    (flet ((pop-to-buffer (buf &rest args)
                          (let ((pop-up-windows nil))
                            (if (get-buffer-window buf)
                                (while (not (equal buf (current-buffer)))
                                  (other-window 1))
                              (progn
                                (ace-window nil)
                                (switch-to-buffer buf))))))
          (compile-goto-error event)))
  )

#+END_SRC

#+RESULTS:
: rg-prev-file

* Company

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :diminish company-mode
  :bind (("C-M-i" . company-complete)
         :map company-active-map
         ("C-p" . company-select-previous)
         ("C-n" . company-select-next)
         ("C-f" . company-show-location)
         ("TAB" . company-complete-common-or-cycle)
         ("<tab>" . company-complete-common-or-cycle)
         ("<escape>" . company-abort))
  :hook ((after-init . global-company-mode)
         (global-company-mode . company-quickhelp-mode))
  :init
  (setq company-dabbrev-downcase nil
        company-minimum-prefix-length 3
        company-idle-delay 0.4)
  :config
  (setq company-backends (delete 'company-dabbrev company-backends))
  (setq company-backends (delete 'company-capf company-backends))
  (add-to-list 'company-backends 'company-elisp)
  (add-to-list 'company-backends 'company-anaconda)
  (add-to-list 'company-backends 'company-files))

(use-package company-quickhelp
  :ensure t
  :after company)

(use-package company-anaconda
  :ensure t
  :after (company anaconda-mode))
#+END_SRC

* Flycheck

#+BEGIN_SRC emacs-lisp
(defun my/mode-line-flycheck ())

(use-package flycheck
  :ensure t
  :diminish flycheck-mode
  :bind (("C-c ! t" . flycheck-mode))
  :hook (after-init . global-flycheck-mode)
  :init
  (setq flycheck-temp-prefix ".flycheck"
        flycheck-emacs-lisp-load-path 'inherit
        flycheck-check-syntax-automatically '(save mode-enabled)
        ;; to check while typing:
        ;; flycheck-check-syntax-automatically '(save idle-change new-line mode-enabled)
        )
  :config
  (defun my/toggle-flycheck-error-list ()
    (interactive)
    (-if-let (window (flycheck-get-error-list-window))
        (quit-window nil window)
      (flycheck-list-errors)))

  (add-to-list 'display-buffer-alist
               `(,(rx bos "*Flycheck errors*" eos)
                 (display-buffer-reuse-window
                  display-buffer-in-side-window)
                 (side            . bottom)
                 (reusable-frames . visible)
                 (window-height   . 0.33)))

  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(javascript-jshint haskell-ghc haskell-stack-ghc)))
  (flycheck-add-mode 'javascript-eslint 'web-mode)
  (flycheck-add-mode 'javascript-eslint 'js2-mode)

  ;; modeline stuff
  (defface modeline-flycheck-error
    '((t (:foreground "#e05e5e" :distant-foreground "#e05e5e")))
    "Face for flycheck error feedback in the modeline."
    :group 'modeline-flycheck)
  (defface modeline-flycheck-warning
    '((t (:foreground "#bfb03d" :distant-foreground "#bfb03d")))
    "Face for flycheck warning feedback in the modeline."
    :group 'modeline-flycheck)
  (defface modeline-flycheck-info
    '((t (:foreground "DeepSkyBlue3" :distant-foreground "DeepSkyBlue3")))
    "Face for flycheck info feedback in the modeline."
    :group 'modeline-flycheck)
  (defface modeline-flycheck-ok
    '((t (:foreground "SeaGreen3" :distant-foreground "SeaGreen3")))
    "Face for flycheck ok feedback in the modeline."
    :group 'modeline-flycheck)

  (defvar modeline-flycheck-bullet "•%s")

  (defun my/mode-line-flycheck-state (state)
    (let* ((counts (flycheck-count-errors flycheck-current-errors))
           (errorp (flycheck-has-current-errors-p state))
           (err (or (cdr (assq state counts)) "?"))
           (running (eq 'running flycheck-last-status-change))
           (face (intern (format "modeline-flycheck-%S" state))))
      (if (or errorp running)
          (propertize (format modeline-flycheck-bullet err) 'face face))))

  (defun my/mode-line-flycheck ()
    (let* ((ml-error (my/mode-line-flycheck-state 'error))
           (ml-warning (my/mode-line-flycheck-state 'warning))
           (ml-info (my/mode-line-flycheck-state 'info))
           (ml-status (concat ml-error ml-warning ml-info)))
      (if (null ml-status) "" (concat " " ml-status " ")))))
#+END_SRC

* Projectile

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :hook (after-init . projectile-mode)
  :bind-keymap ("C-c p" . projectile-command-map)
  :diminish projectile-mode
  :init
  (setq projectile-completion-system 'ivy)
  (setq
   projectile-mode-line-function
   '(lambda () (format " P[%s]" (or (projectile-project-name) "-"))))
  )

(use-package perspective
  :ensure t
  :hook (after-init . persp-mode)
  :bind (("M-N" . persp-next)
         ("M-P" . persp-prev)
         ("M-J" . persp-switch))
  :config
  ;; emacs window title
  (defadvice persp-switch
      (after advice-for-persp-switch activate)
    (message (persp-name (persp-curr))))
  (setq frame-title-format
        '("" invocation-name "@" system-name
          (:eval (when persp-mode (format "[%s]" (persp-name (persp-curr))))))))

(use-package persp-projectile
  :ensure t
  :after (perspective projectile))
#+END_SRC

#+begin_src emacs-lisp
;; override chosen project names
(defvar my/projectile-project-name-overrides '())

(defun my/projectile-add-to-project-name-overrides (proj name)
  (add-to-list
   'my/projectile-project-name-overrides
   `(,(file-name-as-directory (expand-file-name proj)) . ,name)))

(defun my/projectile-override-project-name (orig &rest args)
  (let* ((dir (file-name-as-directory (expand-file-name (car args))))
         (match (assoc dir my/projectile-project-name-overrides))
         (name (if (null match) nil (cdr match))))
    (if (null name)
        (apply orig args)
      name)))

(advice-add 'projectile-default-project-name :around #'my/projectile-override-project-name)

;; usage:
;; (dolist (override '(
;;                     ("/path/to/my/project" . "some-name")
;;                     ("/other/project" . "some-other-name")
;;                     ))
;;   (let ((proj (car override))
;;         (name (cdr override)))
;;     (my/projectile-add-to-project-name-overrides proj name)))
#+end_src

* Ivy/Counsel/Swiper

#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  :ensure t
  :after projectile
  :bind (:map projectile-command-map
              ("f" . counsel-projectile-find-file)
              ("s" . counsel-projectile-rg)
              ("b" . counsel-projectile-switch-to-buffer))
  :init
  (setq projectile-switch-project-action 'counsel-projectile-find-file))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/swiper (fuzzy)
  (interactive "P")
  (if fuzzy
      (let* ((temp-builders
              (copy-alist ivy-re-builders-alist))
             (ivy-re-builders-alist
              (add-to-list 'temp-builders
                           '(swiper . ivy--regex-fuzzy))))
        (swiper))
    (swiper)))

(defun my/swiper-isearch (fuzzy)
  (interactive "P")
  (if fuzzy
      (let* ((temp-builders
              (copy-alist ivy-re-builders-alist))
             (ivy-re-builders-alist
              (add-to-list 'temp-builders
                           '(swiper-isearch . ivy--regex-fuzzy))))
        (swiper-isearch))
    (swiper-isearch)))

(use-package ivy-xref  ;; currently in lisp/ because of patches
  :config (setq xref-show-xrefs-function 'ivy-xref-show-xrefs)
  :after ivy)

(use-package swiper
  :ensure t
  ;; :bind ("C-s" . my/swiper)
  :bind ("C-s" . my/swiper-isearch)
  :commands (swiper swiper-isearch swiper-all swiper-multi)
  :config
  ;; use regular isearch when in minibuffer
  (define-key minibuffer-local-map (kbd "C-s") #'isearch-forward))

;; better fuzzy matching
(use-package flx
  :ensure t
  :after ivy)

;; mostly to bring recently used M-x targets at the top
(use-package smex
  :ensure t
  :after ivy
  :init
  (setq smex-history-length 12))

(defun my/ivy-reset-builders ()
  (setq ivy-re-builders-alist
        '((swiper               . ivy--regex-plus)
          (swiper-isearch       . ivy--regex-plus)
          (ivy-bibtex           . ivy--regex-ignore-order)
          (counsel-unicode-char . ivy--regex-ignore-order)
          (insert-char          . ivy--regex-ignore-order)
          (ucs-insert           . ivy--regex-ignore-order)
          (counsel-unicode-char . ivy--regex-ignore-order)
          (counsel-ag           . ivy--regex-ignore-order)  ;; NOTE: testing
          (counsel-rg           . ivy--regex-ignore-order)
          (t                    . ivy--regex-fuzzy))))

(use-package counsel
  :ensure t
  :bind (("M-x" . counsel-M-x)
         ("M-i" . counsel-imenu)
         ("C-x C-f" . counsel-find-file)
         ("C-x f" . counsel-file-jump)
         ("C-x r b" . counsel-bookmark)
         ("C-x C-a" . counsel-recentf)
         :map org-mode-map
         ("M-i" . counsel-outline))
  :after ivy
  :init
  (setq counsel-ag-base-command "ag --vimgrep --nocolor --nogroup %s"
        counsel-rg-base-command "rg --with-filename --no-heading --line-number --color never -S %s")
  :config
  (my/ivy-reset-builders)
  (setq ivy-initial-inputs-alist nil) ;; no ^ initially
  ;; counsel-ag
  ;; S-SPC doesn't work properly in counsel-ag anyway
  ;; NOTE: this also applies to rg
  (define-key counsel-ag-map (kbd "S-SPC") nil)
  ;; counsel-rg
  ;; NOTE: testing this (added `-S' for smart case in ivy-occur buffers)
  (global-set-key (kbd "C-c s")
                  (lambda ()
                    (interactive)
                    (counsel-rg nil (read-directory-name "rg in: ") "")))

  (defun my/counsel-file-jump-temp-root (reset)
    (interactive "P")
    (my/get-or-set-temp-root reset)
    (let ((current-prefix-arg nil))
      (counsel-file-jump nil my/temp-project-root)))

  (global-set-key (kbd "C-S-p") #'my/counsel-file-jump-temp-root)

  (defun my/counsel-rg-temp-root (reset)
    (interactive "P")
    (my/get-or-set-temp-root reset)
    (let ((current-prefix-arg nil))
      (counsel-rg "" my/temp-project-root)))

  (global-set-key (kbd "C-S-s") #'my/counsel-rg-temp-root)

  (defun my/counsel-file-jump-from-here (path)
    (interactive)
    (let ((dir (if (file-directory-p path)
                   path
                 (file-name-directory path))))
      (counsel-file-jump "" dir)))

  (defun my/set-temp-root-and-jump (dir)
    (setq my/temp-project-root dir)
    (my/counsel-file-jump-temp-root nil))

  (dolist (action '(counsel-find-file counsel-file-jump counsel-recentf))
    (ivy-set-actions
     action
     `(
       ("s"
        ,(my/control-function-window-split
          find-file-other-window
          0 nil)
        "split horizontally")
       ("v"
        ,(my/control-function-window-split
          find-file-other-window
          nil 0)
        "split vertically")
       ("n"
        ,(my/execute-f-with-hook
          find-file
          ace-select-window)
        "select window")
       ("e"
        my/eshell-in-dir
        "eshell")
       ("j"
        my/counsel-file-jump-from-here
        "jump")
       ("J"
        my/set-temp-root-and-jump
        "set temp root and jump")
       ("r"
        (lambda (dir) (counsel-rg nil dir))
        "counsel-rg")
       )))

  (dolist (action '(counsel-projectile-find-file projectile-recentf))
    (ivy-set-actions
     action
     `(("s"
        ,(my/control-function-window-split
          counsel-projectile-find-file-action-other-window
          0 nil)
        "split horizontally")
       ("v"
        ,(my/control-function-window-split
          counsel-projectile-find-file-action-other-window
          nil 0)
        "split vertically")
       ("n"
        ,(my/execute-f-with-hook
          counsel-projectile-find-file-action
          ace-select-window)
        "select window")
       ("R"
        (lambda (f) (projectile-recentf))
        "recent files")
       ("e"
        (lambda (f) (my/eshell-in-dir (projectile-expand-root f)))
        "eshell")
       )))

  ;; also applies to counsel-projectile-ag
  (dolist (action '(counsel-ag counsel-rg))
    (ivy-set-actions
     action
     '(("v"
        (lambda (x) (split-window-right) (windmove-right) (counsel-git-grep-action x))
        "split vertically")
       ("s"
        (lambda (x) (split-window-below) (windmove-down) (counsel-git-grep-action x))
        "split horizontally")
       ("n"
        (lambda (x) (ace-select-window) (counsel-git-grep-action x))
        "select window")
       )))
  )

(use-package ivy
  :ensure t
  :diminish ivy-mode
  :hook (after-init . ivy-mode)
  :bind (("C-c r" . ivy-resume)
         ("C-x b" . ivy-switch-buffer)
         :map ivy-minibuffer-map
         ("C-l" . ivy-call-and-recenter))
  :init
  (setq ivy-use-virtual-buffers nil
        ivy-count-format "(%d/%d) "
        ivy-magic-tilde nil)
  :config
  (my/ivy-reset-builders)
  (setq ivy-initial-inputs-alist nil) ;; no ^ initially
  (define-key ivy-minibuffer-map (kbd "C-l") 'ivy-call-and-recenter)

  (defun my/ivy-yank-current-region-or-word (&optional qual)
    "Insert current region, if it's active, otherwise the current word,into
the minibuffer."
    (interactive "P")
    (let (text)
      (with-ivy-window
        (unwind-protect
            (setq text
                  (if (region-active-p)
                      (buffer-substring-no-properties (region-beginning) (region-end))
                    (current-word t (not qual))))))
      (when text (insert text))))
  (define-key ivy-minibuffer-map (kbd "M-j") 'my/ivy-yank-current-region-or-word)
  ;; TODO: something's up with rotation
  (define-key ivy-minibuffer-map (kbd "M-r") 'ivy-rotate-preferred-builders)

  (defun my/ivy-minibuffer-grow ()
    (interactive)
    (let* ((prefix (prefix-numeric-value current-prefix-arg))
           (nlines (cond
                    ((= prefix 1) 1)
                    ((= prefix 4) (/ (frame-height) 2))
                    (t (- (frame-height) 5))))
           (current-prefix-arg nil))
      (while (> nlines 0)
        (ivy-minibuffer-grow)
        (setq nlines (1- nlines)))))

  (define-key ivy-minibuffer-map (kbd "C-o") #'my/ivy-minibuffer-grow)

  ;; minibuffer actions for specific commands

  (ivy-set-actions
   'ivy-switch-buffer
   `(("s"
      ,(my/control-function-window-split
        ivy--switch-buffer-other-window-action
        0 nil)
      "split horizontally")
     ("v"
      ,(my/control-function-window-split
        ivy--switch-buffer-other-window-action
        nil 0)
      "split vertically")
     ("n"
      ,(my/execute-f-with-hook
        (lambda (b) (switch-to-buffer b nil 'force-same-window))
        ace-select-window)
      "select window")
     ("k" kill-buffer "kill buffer")
     ))

  (ivy-set-actions
   'projectile-switch-project
   '(("d"
      dired
      "Open Dired in project's directory")
     ("v"
      projectile-vc
      "Open project root in vc-dir or magit")
     ("r"
      projectile-remove-known-project
      "Remove project(s)")))
  )
#+END_SRC

* Yasnippet

#+BEGIN_SRC emacs-lisp
(use-package yasnippet-snippets
  :ensure t
  :after yasnippet
  :config
  (yas-reload-all))

(use-package yasnippet
  :ensure t
  :commands (yas-expand)
  :diminish yas-minor-mode
  :init
  ;; setup keys in `prog-mode-map' initially ...
  (define-key prog-mode-map (kbd "<C-return>") 'yas-expand)
  (define-key prog-mode-map (kbd "C-c y") 'yas-expand)
  :config
  ;; ... remove them from `prog-mode-map' when mode is initialized ...
  (define-key prog-mode-map (kbd "<C-return>") nil)
  (define-key prog-mode-map (kbd "C-c y") nil)
  ;; ... and add them to `yas-minor-mode-map'
  (define-key yas-minor-mode-map (kbd "<C-return>") 'yas-expand)
  (define-key yas-minor-mode-map (kbd "C-c y") 'yas-expand)
  ;; this will run once (since it's in :config)
  (when (derived-mode-p 'prog-mode)
    (yas-minor-mode))
  (add-hook 'prog-mode-hook #'yas-minor-mode))
#+END_SRC

* Other window management
** Dired

#+BEGIN_SRC emacs-lisp
(use-package dired-subtree
  :ensure t
  :after dired
  :bind (:map dired-mode-map
              ("<tab>" . dired-subtree-toggle)
              ("TAB" . dired-subtree-toggle)))

(use-package dired-filter
  :ensure t
  :after dired)

(use-package dired-git-info
  :ensure t
  :after dired
  :bind (:map dired-mode-map (")" . dired-git-info-mode))
  :commands (dired-git-info-mode))

(defun my/dired-find-file-ace ()
  (interactive)
  (let ((find-file-run-dired t)
        (fname (dired-get-file-for-visit)))
    (if (ace-select-window)
        (find-file fname))))

(defun my/dired-file-jump-from-here ()
  (interactive)
  (let ((find-file-run-dired t)
        (fname (dired-get-file-for-visit)))
    (my/counsel-file-jump-from-here fname)))

(defun my/dired-persistent-buffer ()
  (interactive)
  (call-interactively 'dired)
  (use-local-map (copy-keymap dired-mode-map))
  (local-set-key (kbd "RET") #'my/dired-find-file-ace))

(defun my/dired-kill-all-buffers ()
  (interactive)
  (mapc (lambda (buf)
          (when (eq 'dired-mode
                    (buffer-local-value 'major-mode buf))
            (kill-buffer buf)))
        (buffer-list)))

(use-package dired-x
  :after dired
  :init
  (if is-mac (setq dired-use-ls-dired nil)))

(use-package dired
  :bind (:map dired-mode-map
              ("j" . dired-next-line)
              ("J" . dired-next-dirline)
              ("k" . dired-previous-line)
              ("K" . dired-prev-dirline)
              ("h" . backward-char)
              ("l" . forward-char)
              ("C-c n" . my/dired-find-file-ace)
              ("M-j" . my/dired-file-jump-from-here)
              ("M-u" . dired-up-directory)
              ("C-c C-q" . my/dired-kill-all-buffers))
  :init
  ;; hide files being edited + flycheck files from dired
  (setq dired-omit-files "\\`[.]?#\\|\\`.flycheck_"
        dired-omit-verbose nil)
  :config
  (add-hook 'dired-mode-hook #'auto-revert-mode)
  (add-hook 'dired-mode-hook #'dired-omit-mode)

  (define-key dired-mode-map
    (kbd "C-c v")
    (my/control-function-window-split
     dired-find-file-other-window
     nil 0))
  (define-key dired-mode-map
    (kbd "C-c s")
    (my/control-function-window-split
     dired-find-file-other-window
     0 nil))
  )
#+END_SRC

#+begin_src emacs-lisp
;; https://gist.github.com/surajacharya/4127526
(defun my/git-grep-dired (repo wildcards regexp)
  "Find Git-controlled files in DIR with a name like WILDCARDS containing a regexp REGEXP and start Dired on output."
  (interactive "DGit-grep (directory): \nsGit-grep (filename wildcard(s), e.g. *.xml): \nsGit-grep (grep regexp): ")
  (setq repo (file-name-as-directory (expand-file-name repo)))
  (switch-to-buffer (concat "*Git Grep " repo "*"))
  (fundamental-mode)
  (setq buffer-read-only nil)
  (erase-buffer)
  (setq default-directory repo)
  (let ((cmd (format "git --git-dir %s/.git ls-files -z%s | xargs -0 grep -lZ -- %s | xargs -0 ls -l"
                     repo
                     (apply 'concat (mapcar (lambda (s) (concat " " (shell-quote-argument s))) (split-string wildcards)))
                     (shell-quote-argument regexp))))
    (insert " " cmd "\n " repo ":\n")
    (call-process-shell-command (concat cmd " | sed -e 's/^/ /g'") nil t))
  (dired-mode)

  ;; (dired-build-subdir-alist)
  ;; From find-dired:
  ;; Set subdir-alist so that Tree Dired will work:
  (if (fboundp 'dired-simple-subdir-alist)
      ;; will work even with nested dired format (dired-nstd.el,v 1.15
      ;; and later)
      (dired-simple-subdir-alist)
    ;; else we have an ancient tree dired (or classic dired, where
    ;; this does no harm)
    (set (make-local-variable 'dired-subdir-alist)
         (list (cons default-directory (point-min-marker)))))
  (goto-line 2))
#+end_src

** ibuffer

#+begin_src emacs-lisp
(use-package ibuffer
  :init
  ;; `/ R` to toggle showing these groups
  ;; `/ \` to disable
  (setq-default ibuffer-saved-filter-groups
                `(("Default"
                   ("rg" (name . "\*rg.*\*"))
                   ("Dired" (mode . dired-mode))
                   ("Scratch" (name . "\*scratch.*"))
                   ("Temporary" (name . "\*.*\*"))
                   )))
  (setq ibuffer-show-empty-filter-groups nil)
  :config
  (define-key ibuffer-mode-map (kbd "M-o") nil)
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (add-hook 'ibuffer-mode-hook #'(lambda () (ibuffer-auto-mode 1))))
#+end_src

** Avy

#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :bind ("C-c i" . avy-goto-line))
#+END_SRC

** Ace-window

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :bind ("C-c o" . ace-window)
  :init
  (setq aw-dispatch-always nil
        aw-keys (string-to-list "asdfghjkl;"))
  :config
  (custom-set-faces
   '(aw-leading-char-face ((t (:foreground "magenta" :background "gray16" :weight bold :height 1.8))))))
#+END_SRC

** buffer-move

#+BEGIN_SRC emacs-lisp
(use-package buffer-move
  :ensure t
  :bind (("<C-S-up>" . buf-move-up)
         ("<C-S-down>" . buf-move-down)
         ("<C-S-left>" . buf-move-left)
         ("<C-S-right>" . buf-move-right)))
#+END_SRC

** zoom

#+begin_src emacs-lisp
(use-package zoom
  :ensure t
  :bind ("M-+" . zoom)
  :init
  (setq zoom-size '(190 . 92)))
#+end_src

* Modeline
** Regular modeline

#+BEGIN_SRC emacs-lisp
(setq-default mode-line-format
              '("%e"
                mode-line-front-space
                ;; evil-mode-line-tag
                mode-line-mule-info
                mode-line-client mode-line-modified mode-line-remote
                mode-line-frame-identification mode-line-buffer-identification " "
                mode-line-position
                (vc-mode vc-mode)
                (:eval (my/mode-line-flycheck))
                (:eval (my/mode-line-venv))
                mode-line-modes mode-line-misc-info mode-line-end-spaces))

(defun my/mode-line-window-dedicated ()
  (if (window-dedicated-p) "× " ""))

(setq mode-line-misc-info
      (cons '(:eval (my/mode-line-window-dedicated)) mode-line-misc-info))
#+END_SRC

** Selected window & focused frame

#+BEGIN_SRC emacs-lisp
;; is window selected?
(defvar my/-selected-window nil)
;; (add-hook 'post-command-hook '(lambda () (setq my/-selected-window (selected-window))))
(add-hook 'post-command-hook
          '(lambda ()
             (when (not (minibuffer-window-active-p (selected-window)))
               (setq my/-selected-window (selected-window)))))
(add-hook 'buffer-list-update-hook '(lambda () (force-mode-line-update t)))

;; is emacs focused?
(defvar my/-focused-in t)
(add-hook 'focus-in-hook '(lambda () (setq my/-focused-in t)))
(add-hook 'focus-out-hook '(lambda () (setq my/-focused-in nil)))

(defun my/current-window-active-p ()
  (and my/-focused-in
       (eq my/-selected-window (selected-window))))
#+END_SRC

** Experimental new modeline

#+BEGIN_SRC emacs-lisp
;; for the position hud
(use-package powerline
  :ensure t
  :commands (pl/render powerline-hud))

(defun my/split-mode-line-render (left right right-narrow)
  (let* ((available-width (- (window-total-width)
                             (+ (length (format-mode-line left))
                                (length (format-mode-line right)))))
         (actual-right right))
    (when (if (< available-width 0) t nil)  ;; narrow
      (setq actual-right right-narrow)
      (setq available-width (- (window-total-width)
                               (+ (length (format-mode-line left))
                                  (length (format-mode-line right-narrow))))))
    (setq foo (list available-width (length (format-mode-line actual-right)) (length (format-mode-line left))))
    (append left
            (list (format (format "%%%ds" available-width) ""))
            actual-right)))

(defun my/mode-line-hud ()
  (let* ((active (eq my/-selected-window (selected-window)))
         (face0 (if active 'powerline-active0 'powerline-inactive0))
         (face2 (if active 'powerline-active2 'powerline-inactive2)))
    (pl/render (powerline-hud face0 face2))))

(defun my/mode-line-vc ()
  (let ((fname (buffer-file-name)))
    (if (or (null fname) (null vc-mode))
        nil
      (let ((br (let ((backend (vc-backend fname)))
                  (substring vc-mode (+ (if (eq backend 'Hg) 2 3) 2))))
            (st (pcase (vc-state fname)
                  ('up-to-date (propertize "✔" 'face 'compilation-info))
                  ('edited (propertize "•" 'face 'compilation-warning))
                  (_ "?"))))
        (format "%s %s" br st)))))

(defun my/mode-line-region-info ()
  (when mark-active
    (let* ((evilp (and (featurep 'evil) (or evil-local-mode evil-mode)))
           (beg (if evilp evil-visual-beginning (region-beginning)))
           (end (if evilp evil-visual-end (region-end)))
           (lines (count-lines beg end))
           (words (count-words beg end))
           (chars (abs (- beg end)))
           (l (propertize "l" 'face 'compilation-info))
           (w (propertize "w" 'face 'compilation-warning))
           (c (propertize "c" 'face 'compilation-error))
           )
      (propertize (format "[%s:%s %s:%s %s:%s]" l lines w words c chars)))))


(setq global-mode-string (delete '(:eval (persp-mode-line)) global-mode-string))
(setcar mode-line-position "")

(setq-default
 mode-line-format
 '((:eval
    (my/split-mode-line-render
     ;; left
     (quote
      ("%e" " "
       mode-line-modified "  "
       mode-line-buffer-identification " "
       (:eval (string-remove-suffix "-mode" (format "%s" major-mode))) " "
       (:eval (my/mode-line-window-dedicated))
       (:eval (my/mode-line-flycheck))
       (:eval (my/mode-line-region-info))
       ))
     ;; right
     (quote
      ((:eval (my/mode-line-vc)) " "
       (:eval minor-mode-alist) " "
       (:eval (frame-parameter nil 'persp--modestring)) "  "
       mode-line-position
       (:eval (my/mode-line-hud)) "  "
       ))
     ;; right if too narrow
     (quote
      ((:eval (frame-parameter nil 'persp--modestring)) "  "
       mode-line-position
       (:eval (my/mode-line-hud)) "  "
       ))
     ))))

;; evil-mode-line-tag
;; mode-line-mule-info
;; mode-line-client
;; mode-line-remote
;; (vc-mode vc-mode)
;; mode-line-modes
;; mode-line-misc-info
;; (:eval minor-mode-alist)
;; (:eval (my/mode-line-venv))
#+END_SRC

** Powerline

#+BEGIN_SRC emacs-lisp :tangle no
;; local for now
(use-package powerline-default-evil-theme
  :commands (powerline-default-evil-theme)
  :config
  (add-to-list
   'powerline-default-evil-theme-state-faces
   '(hybrid . powerline-active0-evil-insert)))

(use-package powerline
  :ensure t
  :after flycheck
  :if is-gui
  :init
  (setq powerline-display-buffer-size nil)
  (setq powerline-display-mule-info nil)
  (setq flycheck-mode-line '(:eval (my/mode-line-flycheck)))
  (setq global-mode-string
        (append global-mode-string '((:eval (my/mode-line-venv)))))
  (setq global-mode-string
        (cons '(:eval (if (window-dedicated-p) "× " "")) global-mode-string))
  :config
  (powerline-default-evil-theme)
  ;; (powerline-default-theme)
  (diminish-undo 'flycheck-mode)
  (add-hook 'my/after-set-theme-hook 'powerline-reset)
  (add-hook 'my/after-set-font-hook 'powerline-reset)
  ;; Try this to see if it fixes powerline hiccups
  (defun powerline-selected-window-active ()
    "Return whether the current window is active."
    (my/current-window-active-p))
  )
#+END_SRC

* Org-mode

#+BEGIN_SRC emacs-lisp
;; this is the same as doing org-babel-load-languages
(use-package ob-python :commands (org-babel-execute:python))
(use-package ob-sql :commands (org-babel-execute:sql))

(use-package org-mode
  :mode ("\\.org\\'" . org-mode)
  :bind (("C-c a" . org-agenda)
         ("C-c b" . org-iswitchb)
         ("C-c c" . org-capture)
         ("C-c l" . org-store-link)
         )
  :init
  (setq org-log-done 'time
        org-confirm-babel-evaluate nil
        org-clock-into-drawer nil
        org-src-fontify-natively t
        org-src-preserve-indentation t
        org-src-tab-acts-natively t
        org-src-window-setup 'other-window
        org-adapt-indentation nil
        org-directory (expand-file-name "~/org/")
        org-default-notes-file (concat org-directory "notes.org")
        org-ellipsis "…"
        org-todo-keywords '((sequence "TODO" "IN PROGRESS" "|" "DONE"))
        org-todo-keyword-faces '(("IN PROGRESS" . (:foreground "DarkOrange3" :weight bold)))
        )

  ;; org-capture
  (setq org-capture-templates
        '(("c"
           "Code comment"
           entry
           (file+headline org-default-notes-file "Code comments")
           "\n\n* %?\n\n#+BEGIN_SRC %^{Language}\n%i\n#+END_SRC\n\n%a\n")))

  ;; format string used when creating CLOCKSUM lines and when generating a
  ;; time duration (avoid showing days)
  (setq org-time-clocksum-format
        '(:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t))

  (defun my/org-insert-template ()
    (interactive)
    (let* ((templ-dir (expand-file-name (concat user-emacs-directory "org-templates/")))
           (ls (directory-files templ-dir nil "^[^.]"))
           (file (completing-read "Template: " ls))
           (path (concat templ-dir file)))
      (insert-file-contents path)))

  :config
  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)
  (my/add-hooks
   '(org-mode-hook)
   (define-key org-mode-map (kbd "TAB") 'org-cycle)
   (define-key org-mode-map (kbd "<tab>") 'org-cycle)
   (define-key evil-normal-state-map (kbd "TAB") 'org-cycle)
   (my/set-mode-fill-width 'org-mode-hook 100)
   )
  )

(defun my/org-set-src-faces (&optional light-bg th)
  (let* ((func (if light-bg 'color-darken-name 'color-lighten-name))
         (rfunc (if light-bg 'color-lighten-name 'color-darken-name))
         (bg (face-attribute 'default :background))
         (bg+ (funcall func bg 1))
         (bg++ (funcall func bg 4.5))
         (fg (face-attribute 'default :foreground))
         (theme (if th th my/theme))
         (cur-line-fg (face-attribute 'org-block-begin-line :foreground nil t))
         (cur-block-fg (funcall rfunc (face-attribute 'default :foreground nil t) 11))
         )
    (custom-theme-set-faces
     theme
     `(org-block ((t (:background ,bg+ :foreground ,cur-block-fg))))
     `(org-block-begin-line ((t (:background ,bg++ :foreground ,cur-line-fg))))
     `(org-block-end-line ((t (:background ,bg++ :foreground ,cur-line-fg)))))))

(use-package org-bullets
  :ensure t
  :if is-gui
  :after org
  :hook (org-mode . org-bullets-mode)
  :init
  (setq org-hide-leading-stars t))

;; auto-generated if a heading has a :TOC: tag
(use-package toc-org
  :ensure t
  :after org
  :hook (org-mode . toc-org-mode))

(use-package htmlize
  :ensure t
  :defer t
  :init
  (setq org-html-htmlize-output-type 'css))
#+END_SRC

* Setup
** Per-workstation setup

#+BEGIN_SRC emacs-lisp
(defvar my/after-init-hook nil "Hook called after initialization")
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; these have to be paths to projects that projectile recognizes (e.g. git)
(defvar my/start-up-projects '())

(defun my/open-start-up-projects ()
  (unless (null my/start-up-projects)
    (let ((projectile-switch-project-action 'projectile-dired))
      (dolist (proj my/start-up-projects)
        (projectile-persp-switch-project proj)))
    (persp-switch "main")))

(add-hook 'my/after-init-hook 'my/open-start-up-projects)

;; usage:
;; (add-to-list 'my/start-up-projects "/path/to/some/project")
#+END_SRC

# thanks Nicolas Petton
#+BEGIN_SRC emacs-lisp
(defvar my/hosts-dir (expand-file-name (concat user-emacs-directory "hosts/")))
(defvar my/hostname (substring (shell-command-to-string "hostname") 0 -1))
(let* ((host-file (concat my/hosts-dir "init-" my/hostname ".el")))
  (load-file host-file))
#+END_SRC

** Performance

#+BEGIN_SRC emacs-lisp
;; stolen from doom
(defun my/defer-garbage-collection-h ()
  (setq gc-cons-threshold 100000000))

(defun my/restore-garbage-collection-h ()
  ;; Defer it so that commands launched immediately after will enjoy the
  ;; benefits.
  (run-at-time
   1 nil (lambda () (setq gc-cons-threshold 800000))))

(add-hook 'minibuffer-setup-hook #'my/defer-garbage-collection-h)
(add-hook 'minibuffer-exit-hook #'my/restore-garbage-collection-h)
#+END_SRC

** Global setup

#+BEGIN_SRC emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
;; (load custom-file 'noerror)

(setq x-underline-at-descent-line t)

(custom-set-faces
 '(anzu-mode-line ((t (:inherit mode-line :foreground "magenta" :weight bold))))
 '(anzu-mode-line-no-match ((t (:inherit mode-line :foreground "red" :weight bold))))
 '(fixed-pitch ((t nil)))
 '(flycheck-info ((t (:underline (:color "DeepSkyBlue2" :style wave)))))
 '(flycheck-fringe-info ((t (:foreground "DeepSkyBlue2"))))
 '(flycheck-warning ((t (:underline (:color "orange1" :style wave)))))
 '(flycheck-fringe-warning ((t (:foreground "orange1"))))
 '(flycheck-error ((t (:underline (:color "red1" :style wave)))))
 '(flycheck-fringe-error ((t (:foreground "#FB4933"))))
 ;; '(whitespace-trailing ((t (:background "#602020"))))
 )

(dolist (val '((eval . (setq flycheck-disabled-checkers
                             (append flycheck-disabled-checkers
                                     (quote
                                      (intero)))))
               (haskell-hoogle-command . "stack hoogle -- --count=100")
               (projectile-tags-command . "npm run etags")
               (projectile-tags-command . "fast-tags -e -R .")
               (projectile-tags-command . "fast-tags -e -R -o %s --exclude=\"%s\" \"%s\"")
               (psc-ide-output-directory . "build/")
               (my/use-intero . t)
               (my/haskell-align-stuff . nil)
               (my/haskell-use-ormolu . t)
               (my/purescript-align-stuff . nil)
               ))
  (add-to-list 'safe-local-variable-values val))

(my/set-theme)
(my/set-font)

(setq linum-format 'dynamic)

(setq default-input-method "TeX")

(hybrid-mode)
(winner-mode)

(run-hooks 'my/after-init-hook)
#+END_SRC

# end of configuration.org
