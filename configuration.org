* Variables and PATH

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (expand-file-name (expand-file-name "lisp" user-emacs-directory)))
(add-to-list 'custom-theme-load-path
             (expand-file-name (expand-file-name "custom-themes/" user-emacs-directory)))

(setq user-full-name "Alex Peitsinis"
      user-mail-address "alexpeitsinis@gmail.com")

(dolist (pth '(
               "/usr/local/bin"
               "~/bin"
               "~/.local/bin"
               "~/.ghcup/bin"
               ))

(add-to-list 'exec-path (expand-file-name pth))
  (setenv "PATH" (concat (expand-file-name pth)
                         path-separator
                         (getenv "PATH"))))

(defvar my/dropbox-dir (expand-file-name "~/Dropbox/")
  "Private directory synced with dropbox")

(defvar my/dropbox-emacs-dir (expand-file-name "emacs/" my/dropbox-dir)
  "Private directory synced with dropbox")

(defvar my/org-directory (expand-file-name "org/" my/dropbox-emacs-dir)
  "Org directory")

(defvar is-mac (eq system-type 'darwin)
  "Whether emacs is running in mac or not")

(defvar is-gui (display-graphic-p)
  "Whether emacs is running in gui mode or not")

(defvar is-term (not is-gui)
  "Whether emacs is running in a terminal or not")

(defvar my/xmonad-emacs-sp-name "emacs-sp")
#+END_SRC

* Package management

#+BEGIN_SRC emacs-lisp
(require 'package)
(add-to-list 'package-archives
             '("melpa" . "https://melpa.org/packages/")
             ;; '("MELPA Stable" . "https://stable.melpa.org/packages/")
             )

(when (< emacs-major-version 24)
  ;; For important compatibility libraries like cl-lib
  (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/")))

;; Some sort of emacs bug workaround
(when (= emacs-major-version 26)
  (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3"))

(unless (bound-and-true-p package--initialized)
  (package-initialize)
  (setq package-enable-at-startup nil))

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

;; Can be used to debug slow packages
;; (setq use-package-minimum-reported-time 0.05
;;       use-package-verbose t)

(eval-when-compile
  (require 'use-package))

(if (< emacs-major-version 27)
    (require 'cl))
(use-package diminish :ensure t)

;; `dash' is used in various places
(use-package dash :ensure t)
#+END_SRC

* Various utility functions

#+BEGIN_SRC emacs-lisp
(defmacro my/add-hooks (hooks &rest body)
  `(dolist (hook ,hooks)
     (add-hook hook (lambda () ,@body))))

(defmacro my/execute-f-with-hook (f winf)
  `(lambda (&rest args)
     (interactive)
     (,winf)
     (apply (quote ,f) args)))

(defmacro my/control-function-window-split (f height width)
  `(lambda (&rest args)
     (interactive)
     (let ((split-height-threshold ,height)
           (split-width-threshold ,width))
       (apply (quote ,f) args))))

;; what it says
(defun my/revert-all-buffers (also-git)
  "Refresh all open file buffers without confirmation.

Buffers in modified \(not yet saved) state in EMACS will not be reverted. They
will be reverted though if they were modified outside EMACS. Buffers visiting
files which do not exist any more or are no longer readable will be killed.

With prefix argument ALSO-GIT, refresh the git state as well \(branch status on
modeline)."
  (interactive "P")
  (dolist (buf (buffer-list))
    (let ((filename (buffer-file-name buf)))
      ;; Revert only buffers containing files, which are not modified;
      ;; do not try to revert non-file buffers like *Messages*.
      (when (and filename
                 (not (buffer-modified-p buf)))
        (if (file-readable-p filename)
            ;; If the file exists and is readable, revert the buffer.
            (with-current-buffer buf
              (revert-buffer :ignore-auto :noconfirm :preserve-modes)
              (when also-git (vc-refresh-state)))
          ;; Otherwise, kill the buffer.
          (let (kill-buffer-query-functions) ; No query done when killing buffer
            (kill-buffer buf)
            (message "Killed non-existing/unreadable file buffer: %s" filename))))))
  (let ((msg-end (if also-git ", and their git state." ".")))
    (message
     (format "Finished reverting buffers containing unmodified files%s" msg-end))))

(defalias 'rb  'revert-buffer)
(defalias 'rab 'my/revert-all-buffers)

(defun my/indent-region-or-buffer ()
  "Indent a region if selected, otherwise the whole buffer."
  (interactive)
  (save-excursion
    (if (region-active-p)
        (progn
          (indent-region (region-beginning) (region-end))
          (message "Indented selected region."))
      (progn
        (indent-region (point-min) (point-max))
        (message "Indented buffer.")))))

(global-set-key (kbd "C-M-\\") #'my/indent-region-or-buffer)

(defun my/line-length (&optional line)
  "Length of the Nth line."
  (let ((ln (if line line (line-number-at-pos))))
    (save-excursion
      (goto-char (point-min))
      (if (zerop (forward-line (1- ln)))
          (- (line-end-position)
             (line-beginning-position))
        0))))

(defun my/format-region-or-buffer (cmd &rest args)
  (interactive)
  (let ((buf (current-buffer))
        (cur-point (point))
        (cur-line (line-number-at-pos))
        (cur-col (current-column))
        (cur-rel-line (- (line-number-at-pos) (line-number-at-pos (window-start)))))
    (with-current-buffer (get-buffer-create "*codefmt*")
      (erase-buffer)
      (insert-buffer-substring buf)
      (if (zerop (apply 'call-process-region `(,(point-min) ,(point-max) ,cmd t (t nil) nil ,@args)))
          (progn
            (if (not (string= (buffer-string) (with-current-buffer buf (buffer-string))))
                (copy-to-buffer buf (point-min) (point-max)))
            (kill-buffer))
        (error (format "%s failed, see *codefmt* for details" cmd))))
    (goto-line cur-line)
    (when (< cur-col (my/line-length cur-line))
      (forward-char cur-col))
    (recenter cur-rel-line)
    (message (format "Formatted with %s" cmd))))

(defun my/format-and-save (cmd &rest args)
  (interactive)
  (apply 'my/format-region-or-buffer `(,cmd ,@args))
  (save-buffer))

(defvar my/select-a-major-mode-last-selected nil)
(defun my/select-a-major-mode ()
  "Interactively select a major mode and return it as a string."
  (let* ((def (or
               my/select-a-major-mode-last-selected
               (symbol-name initial-major-mode)))
         (choice (completing-read "major mode: "
                                  (apropos-internal "-mode$")
                                  nil nil nil nil
                                  def)))
    (setq my/select-a-major-mode-last-selected choice)))

(defun my/create-scratch-buffer-with-mode (other-window)
  "Create a new scratch buffer and select major mode to use.
With a prefix argument, open the buffer using `switch-to-buffer-other-window'."
  (interactive "P")
  (let* ((mmode (my/select-a-major-mode))
         (buf (generate-new-buffer (concat "*scratch" "-" mmode "*")))
         (switch-func (if other-window 'switch-to-buffer-other-window 'switch-to-buffer)))
    (funcall switch-func buf)
    (funcall (intern mmode))
    (setq buffer-offer-save nil)))

;; https://www.reddit.com/r/emacs/comments/ac9gsf/question_emacs_way_of_using_windows/
(defun my/window-dedicated (&optional window)
  "Toggle the dedicated flag on a window."
  (interactive)
  (let* ((window (or window (selected-window)))
         (dedicated (not (window-dedicated-p window))))
    (when (called-interactively-p)
      (message (format "%s %sdedicated"
                       (buffer-name (window-buffer window))
                       (if dedicated "" "un"))))
    (set-window-dedicated-p window dedicated)
    dedicated))

(defun my/window-fixed (&optional window)
  "Make a window non-resizable."
  (interactive)
  (let* ((window (or window (selected-window)))
         (new-status (with-selected-window window (not window-size-fixed))))
    (when (called-interactively-p)
      (message (format "%s %sfixed"
                       (buffer-name (window-buffer window))
                       (if new-status "" "un"))))
    (with-selected-window window
      (setq window-size-fixed new-status))
    new-status))

(defun my/copy-file-path (include-line-number)
  (interactive "P")
  (let* ((full-fp (buffer-file-name))
         (prefix (read-directory-name "prefix to strip: " (projectile-project-root)))
         (suffix (if include-line-number (format ":%s" (number-to-string (line-number-at-pos))) ""))
         (fp (concat (string-remove-prefix prefix full-fp) suffix))
         )
    (kill-new fp)
    (message fp)
    t))

(defvar my/useful-files
  '(
    ;; nix
    "default.nix"
    "shell.nix"
    ;; haskell
    "package.yaml"
    "stack.yaml"
    ".hlint.yaml"
    ;; python
    "requirements.txt"
    ;; docker
    "docker-compose.yml"
    "Dockerfile"
    ;; bazel
    "BUILD.bazel"
    ;; generic
    "Makefile"
    ;; github repo
    "README.md"
    ;; emacs
    ".dir-locals.el"))

(defun my/try-open-dominating-file (other-window)
  (interactive "P")
  (let* ((cur-file (or (buffer-file-name) (user-error "Not a file")))
         (paths (seq-filter
                 #'(lambda (pair) (not (null (cdr pair))))
                 (mapcar #'(lambda (fn)
                             (cons fn (locate-dominating-file cur-file fn)))
                         my/useful-files)))
         (file (completing-read "File name: "
                                paths
                                nil nil nil nil nil))
         (dir (cdr (assoc file paths)))
         (find-file-func (if other-window 'find-file-other-window 'find-file)))
    (funcall find-file-func (expand-file-name file (file-name-as-directory dir)))))

(with-eval-after-load 'ivy
  (defun my/try-open-dominating-file-display-transformer (fn)
    (let ((dir (locate-dominating-file (buffer-file-name) fn))
          (max-length (apply 'max (mapcar 'length my/useful-files))))
      (format (format "%%-%ds (in %%s)" max-length)
              fn
              (propertize dir 'face 'font-lock-type-face))))
  (ivy-configure 'my/try-open-dominating-file
    :display-transformer-fn #'my/try-open-dominating-file-display-transformer))

(defun my/line-numbers (relative)
  (interactive "P")
  (if (< emacs-major-version 26)
      (call-interactively 'linum-mode)
    (if display-line-numbers
        (setq display-line-numbers nil)
      (if relative
          (setq display-line-numbers 'relative)
        (setq display-line-numbers t)))))

(defun my/shell-command-on-buffer-or-region (cmd)
  (save-excursion
    (unless (region-active-p)
      (mark-whole-buffer))
    (shell-command-on-region (region-beginning)
                             (region-end)
                             cmd
                             nil
                             t)))
#+END_SRC

* Various configurations
** basic editing

#+BEGIN_SRC emacs-lisp
;; remember last position
(use-package saveplace
  :hook (after-init . save-place-mode))

;; undo tree
(use-package undo-tree
  :ensure t
  :bind ("C-x u" . undo-tree-visualize)
  :diminish undo-tree-mode
  :hook (after-init . global-undo-tree-mode)
  :init
  (setq undo-tree-visualizer-relative-timestamps t
        undo-tree-visualizer-diff t))

;; use column width 80 to fill (e.g. with `M-q'/`gq')
(setq-default fill-column 80)
(defun my/set-mode-fill-width (mode-hook width)
  (add-hook mode-hook `(lambda () (setq fill-column ,width))))
(setq fill-indent-according-to-mode t)

(use-package autorevert
  :hook (after-init . global-auto-revert-mode)
  :diminish auto-revert-mode
  :init
  (setq auto-revert-verbose nil))

(use-package eldoc :diminish eldoc-mode)

(use-package files
  :init
  ;; store all backup and autosave files in
  ;; one dir
  (setq backup-directory-alist
        `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t))))

;; only with this set to nil can org-mode export & open too
;; ... but it also breaks some stuff so it's disabled
;; (setq process-connection-type nil)

;; yesss
(defalias 'yes-or-no-p #'y-or-n-p)

;; Always confirm before closing because I'm stupid
(add-hook
 'kill-emacs-query-functions
 (lambda () (y-or-n-p "Do you really want to exit Emacs? "))
 'append)

;; use spaces
(setq-default indent-tabs-mode nil)

;; always scroll to the end of compilation buffers
;; (setq compilation-scroll-output t)

;; vim-like scrolling (emacs=0)
(setq scroll-conservatively 101)

;; Supress "ad-handle-definition: x got redefined" warnings
(setq ad-redefinition-action 'accept)

;; smooth mouse scrolling
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)) ;; one line at a time
      mouse-wheel-progressive-speed t ;; don't accelerate scrolling
      mouse-wheel-follow-mouse 't) ;; scroll window under mouse

;; turn off because it causes delays in some modes (e.g. coq-mode)
;; TODO: not sure if this makes a difference
(setq smie-blink-matching-inners nil)
;; (setq blink-matching-paren nil)

;; who in their right mind ends sentences with 2 spaces?
(setq sentence-end-double-space nil)

;; Don't autofill when pressing RET
(aset auto-fill-chars ?\n nil)

;; always trim whitespace before saving
;; (add-hook 'before-save-hook 'delete-trailing-whitespace)
(defalias 'dw 'delete-trailing-whitespace)

;; some keymaps
(global-set-key (kbd "M-o") 'other-window)
(global-set-key (kbd "C-c j") 'previous-buffer)
(global-set-key (kbd "C-c k") 'next-buffer)
;; I use that to switch to Greek layout
(global-set-key (kbd "M-SPC") nil)
;; Bind M-\ to just-one-space instead of delete-horizontal-space
(global-set-key (kbd "M-\\") 'just-one-space)
;; proper count-words keybinding
(global-set-key (kbd "M-=") 'count-words)

(use-package newcomment
  :commands (comment-indent comment-kill)
  :bind (("C-;" . my/comment-end-of-line)
         ("C-:" . comment-kill))
  :init
  (setq-default comment-indent-function nil)
  (defvar-local my/comment-offset 2)
  (defun my/comment-end-of-line ()
    "Add an inline comment, 2 spaces after EOL."
    (interactive)
    (let* ((len (- (line-end-position)
                   (line-beginning-position)))
           (comment-column (+ my/comment-offset len)))
      (funcall-interactively 'comment-indent))))

;; DocView
(setq doc-view-continuous t)

;; shr (html rendering)
(make-variable-buffer-local 'shr-width)

(use-package expand-region
  :ensure t
  :bind (("C-=" . er/expand-region)
         ("C-M-=" . er/contract-region)))

(use-package misc
  :bind ("M-Z" . zap-up-to-char))

(use-package subword
  :diminish subword-mode
  :commands (subword-mode)
  :init
  (advice-add 'subword-mode
              :after
              #'(lambda (&optional arg)
                  (setq evil-symbol-word-search subword-mode))))

(use-package outline
  :defer t
  :bind (:map outline-minor-mode-map
              ("<tab>" . my/outline-toggle-heading))
  :diminish outline-minor-mode
  :init
  (defun my/outline-toggle-heading ()
    (interactive)
    (when (outline-on-heading-p)
      (funcall-interactively 'outline-toggle-children))))

;; elisp: ;; -*- eval: (outshine-mode) -*-
(use-package outshine
  :ensure t
  :after outline
  :bind (:map outline-minor-mode-map
              ("<S-iso-lefttab>" . outshine-cycle-buffer))
  :commands (outshine-mode))

(use-package rainbow-mode
  :ensure t
  :commands (rainbow-mode)
  :init
  (setq rainbow-ansi-colors nil
        rainbow-html-colors nil
        rainbow-latex-colors nil
        rainbow-r-colors nil
        rainbow-x-colors nil))

(use-package rainbow-delimiters
  :ensure t
  :hook ((lisp-mode emacs-lisp-mode) . rainbow-delimiters-mode)
  :commands (rainbow-delimiters-mode)
  :diminish)
#+END_SRC

** auth

#+BEGIN_SRC emacs-lisp
(use-package auth-source
  :config
  (add-to-list 'auth-sources (expand-file-name "authinfo.gpg" my/dropbox-dir)))
#+END_SRC

** advise raise-frame with wmctrl

#+begin_src emacs-lisp
(defun my/wmctrl-raise-frame (&optional frame)
  (when (executable-find "wmctrl")
    (let* ((fr (or frame (selected-frame)))
           (name (frame-parameter fr 'name))
           (flag (if (string-equal name my/xmonad-emacs-sp-name) "-R" "-a")))
      ;; catch any exception, otherwise might interfere with terminal emacsclients
      (condition-case ex
          (call-process
           "wmctrl" nil nil nil "-i" flag
           (frame-parameter fr 'outer-window-id))
        ('error nil)))))

(advice-add 'raise-frame :after 'my/wmctrl-raise-frame)
#+end_src

** compilation

#+BEGIN_SRC emacs-lisp
(defvar my/fast-recompile-mode-map (make-sparse-keymap))

(define-minor-mode my/fast-recompile-mode
  "Minor mode for fast recompilation using C-c C-c"
  :lighter " rc"
  :global t
  :keymap my/fast-recompile-mode-map
  (if my/fast-recompile-mode
      (progn
        (put 'my/-old-compilation-ask-about-save 'state compilation-ask-about-save)
        (setq compilation-ask-about-save nil))
    (setq compilation-ask-about-save (get 'my/-old-compilation-ask-about-save 'state))))

(define-key my/fast-recompile-mode-map (kbd "C-c C-c") #'recompile)

(defun my/compile-in-dir ()
  (interactive)
  (let ((default-directory (read-directory-name "Run command in: ")))
    (call-interactively 'compile)))

(setq compilation-scroll-output 'first-error)
#+END_SRC

** Smartparens

Paredit keys:

| key     | opposite | description           | example                         |
|---------+----------+-----------------------+---------------------------------|
| =C-M-f= | =C-M-b=  | forward/backward sexp | =_(...)(...)= <-> =(...)_(...)= |
| =C-M-d= | =C-M-u=  | down-up sexp          | =_(...)= <-> =(_...)=           |
| =C-M-n= | =C-M-p=  | up-down sexp (end)    | =(..._)= <-> =(...)_=           |

#+BEGIN_SRC emacs-lisp
(use-package smartparens-config
  :after smartparens
  :config
  ;; don't create a pair with single quote in minibuffer
  (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)

  ;; because DataKinds
  ;;(with-eval-after-load 'haskell-mode
  ;;  (sp-local-pair 'haskell-mode "'" nil :actions nil))

  ;; indent after inserting any kinds of parens
  (defun my/smartparens-pair-newline-and-indent (id action context)
    (save-excursion
      (newline)
      (indent-according-to-mode))
    (indent-according-to-mode))
  (sp-pair "(" nil :post-handlers
           '(:add (my/smartparens-pair-newline-and-indent "RET")))
  (sp-pair "{" nil :post-handlers
           '(:add (my/smartparens-pair-newline-and-indent "RET")))
  (sp-pair "[" nil :post-handlers
           '(:add (my/smartparens-pair-newline-and-indent "RET")))
  )

(use-package smartparens
  :ensure t
  :hook (after-init . show-smartparens-global-mode)
  :bind (:map smartparens-mode-map
              ;; paredit bindings
              ("C-M-f" . sp-forward-sexp)
              ("C-M-b" . sp-backward-sexp)
              ("C-M-d" . sp-down-sexp)
              ("C-M-u" . sp-backward-up-sexp)
              ("C-M-n" . sp-up-sexp)
              ("C-M-p" . sp-backward-down-sexp)
              ("M-s" . sp-splice-sexp)
              ("M-<up>" . sp-splice-sexp-killing-backward)
              ("M-<down>" . sp-splice-sexp-killing-forward)
              ("M-r" . sp-splice-sexp-killing-around)
              ("M-(" . sp-wrap-round)
              ("M-{" . sp-wrap-curly)
              ("C-)" . sp-forward-slurp-sexp)
              ("C-<right>" . sp-forward-slurp-sexp)
              ("C-}" . sp-forward-barf-sexp)
              ("C-<left>" . sp-forward-barf-sexp)
              ("C-(" . sp-backward-slurp-sexp)
              ("C-M-<left>" . sp-backward-slurp-sexp)
              ("C-{" . sp-backward-barf-sexp)
              ("C-M-<right>" . sp-backward-barf-sexp)
              ("M-S" . sp-split-sexp)
              ;; mine
              ("C-M-k" . sp-kill-sexp)
              ("C-M-w" . sp-copy-sexp)
              )
  :diminish smartparens-mode
  :init
  (setq sp-show-pair-delay 0.2
        ;; avoid slowness when editing inside a comment for modes with
        ;; parenthesized comments (e.g. coq)
        sp-show-pair-from-inside nil
        sp-cancel-autoskip-on-backward-movement nil
        sp-highlight-pair-overlay nil
        sp-highlight-wrap-overlay nil
        sp-highlight-wrap-tag-overlay nil)

  (my/add-hooks '(emacs-lisp-mode-hook clojure-mode-hook)
                (smartparens-strict-mode)
                (evil-smartparens-mode))
  (my/add-hooks '(prog-mode-hook coq-mode-hook comint-mode-hook css-mode-hook)
                (smartparens-mode))
  :config
  (when is-gui
    ;; interferes in terminal
    (define-key smartparens-mode-map (kbd "M-[") 'sp-wrap-square)))

(use-package evil-smartparens
  :ensure t
  :after smartparens
  :diminish evil-smartparens-mode)
#+END_SRC

** Documentation & help

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :hook (after-init . which-key-mode)
  :diminish which-key-mode)
#+END_SRC

** abbrev etc

#+begin_src emacs-lisp
(use-package dabbrev
  :commands (dabbrev-expand)
  :init
  ;; Don't consider punctuation part of word for completion, helps complete
  ;; qualified symbols
  (my/add-hooks
   '(prog-mode-hook)
   (setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_\\|\\sw\\s.")))

;; Testing it out
(use-package hippie-exp
  :bind (("M-/" . hippie-expand))
  :init
  (setq hippie-expand-verbose nil)
  (setq hippie-expand-try-functions-list
        '(try-expand-dabbrev
          try-expand-dabbrev-all-buffers
          try-expand-dabbrev-from-kill
          try-complete-file-name-partially
          try-complete-file-name
          try-expand-all-abbrevs
          try-expand-list
          try-expand-line
          try-complete-lisp-symbol-partially
          try-complete-lisp-symbol)))
#+end_src

** engine-mode

#+BEGIN_SRC emacs-lisp
(use-package engine-mode
  :ensure t
  :hook (after-init . engine-mode)
  :bind-keymap ("C-x /" . engine-mode-map)
  :config
  (defengine google
    "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s"
    :keybinding "g")

  (defengine google-images
    "http://www.google.com/images?hl=en&source=hp&biw=1440&bih=795&gbv=2&aq=f&aqi=&aql=&oq=&q=%s"
    :keybinding "i")

  (defengine google-maps
    "http://maps.google.com/maps?q=%s")

  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
    :keybinding "w")

  (defengine wiktionary
    "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s"
    :keybinding "d")

  (defengine wolfram-alpha
    "http://www.wolframalpha.com/input/?i=%s"
    :keybinding "m")

  (defengine youtube
    "http://www.youtube.com/results?aq=f&oq=&search_query=%s"
    :keybinding "v")

  (defengine hoogle
    "https://hoogle.haskell.org/?hoogle=%s"
    :keybinding "h")

  (defengine stackage
    "https://www.stackage.org/lts/hoogle?q=%s"
    :keybinding "s")

  (defengine haskell-language-extensions
    "https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-%s"
    :keybinding "#")

  (defengine pursuit
    "https://pursuit.purescript.org/search?q=%s"
    :keybinding "p")

  (defengine coq-tactics
    "https://coq.inria.fr/refman/proof-engine/tactics.html#coq:tacn.%s")
  )
#+END_SRC

** browser

#+begin_src emacs-lisp
(use-package browse-url
  :init
  (setq
   browse-url-browser-function
   (cond ((or (executable-find "google-chrome-stable")
              (executable-find "google-chrome")) 'browse-url-chrome)
         ((executable-find "firefox") 'browse-url-firefox)
         (t 'browse-url-default-browser))))
#+end_src

** math input

# http://ergoemacs.org/emacs/xmsi-math-symbols-input.html
# https://github.com/roelvandijk/base-unicode-symbols/blob/master/Prelude/Unicode.hs

#+BEGIN_SRC emacs-lisp
(use-package xah-math-input
  :ensure t
  :hook (after-init . global-xah-math-input-mode)
  :commands (xah-math-input-change-to-symbol)
  :diminish xah-math-input-mode
  :config
  (define-key xah-math-input-keymap (kbd "S-SPC" ) nil)
  (define-key xah-math-input-keymap (kbd "S-C-SPC") 'xah-math-input-change-to-symbol)

  (puthash "::" "∷" xah-math-input-abrvs)
  (puthash "bottom" "⊥" xah-math-input-abrvs))
#+END_SRC

** prettify symbols

#+begin_src emacs-lisp
;; show original symbol when cursor is on it, or right next to it
(setq prettify-symbols-unprettify-at-point 'right-edge)
#+end_src

** recentf

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :hook (after-init . recentf-mode)
  :init
  (setq recentf-max-saved-items 100))
#+END_SRC

** hi-lock & symbol overlay

#+begin_src emacs-lisp
(use-package hi-lock
  :hook (after-init . global-hi-lock-mode)
  :init
  (setq hi-lock-face-defaults
        '(
          "hi-black-b"
          "hi-red-b"
          "hi-green-b"
          "hi-blue-b"
          "hi-green"
          "hi-blue"
          "hi-pink"
          "hi-yellow"
          ))
  (setq hi-lock-auto-select-face t)
  :config
  (define-key hi-lock-map (kbd "M-H") (lookup-key hi-lock-map (kbd "C-x w")))
  ;; TODO: find out why I can't just `define-key'
  (substitute-key-definition
   'highlight-regexp 'my/highlight-regexp hi-lock-map)

  (defun my/highlight-regexp (regexp &optional face)
    (interactive
     (list
      (hi-lock-regexp-okay
       (read-regexp "Regexp to highlight" 'regexp-history-last))
      (hi-lock-read-face-name)))
    (or (facep face) (setq face 'hi-yellow))
    (unless hi-lock-mode (hi-lock-mode 1))
    (hi-lock-set-pattern regexp face nil)))

(use-package symbol-overlay
  :ensure t
  :commands (symbol-overlay-mode)
  :diminish)
#+end_src

** highlight keywords in some modes

#+BEGIN_SRC emacs-lisp
(defface my/special-keyword-face
  '((t (:inherit font-lock-keyword-face)))
  "Face for highlighting special keywords"
  :group 'my/faces)

(defface my/special-comment-keyword-face
  '((t (:inherit font-lock-preprocessor-face)))
  "Face for highlighting special keywords in comments"
  :group 'my/faces)

(defun my/highlight-keyword-in-mode (mode kw &optional in-comment face)
  (let ((fc (or face (if in-comment 'my/special-comment-keyword-face 'my/special-keyword-face)))
        (str (format "\\<\\(%s\\)\\>" kw)))
    (font-lock-add-keywords
     mode
     (if in-comment
         `((,str 1 ,`(quote ,fc) prepend))
       `((,str . ,`(quote ,fc)))))))

(defvar my/comment-keywords
  '("TODO" "NOTE" "FIXME" "WARNING" "HACK" "XXX" "DONE"))

(defun my/highlight-comment-keywords (mode &optional face)
  (dolist (kw my/comment-keywords)
    (my/highlight-keyword-in-mode mode kw t face)))

(dolist
    (mode '(haskell-mode
            literate-haskell-mode
            purescript-mode
            js2-mode
            html-mode
            python-mode
            idris-mode
            agda-mode
            rust-mode
            c-mode
            emacs-lisp-mode
            coq-mode
            markdown-mode
            ))
  (my/highlight-comment-keywords mode))
#+END_SRC

** alignment

#+begin_src emacs-lisp
(use-package align
  :bind ("C-c \\" . align-regexp)
  :config
  (add-hook 'align-load-hook
            (lambda ()
              (add-to-list 'align-rules-list
                           '(haskell-types
                             (regexp . "\\(\\s-+\\)\\(::\\|∷\\)\\s-+")
                             (modes quote (haskell-mode purescript-mode literate-haskell-mode))))
              (add-to-list 'align-rules-list
                           '(haskell-assignment
                             (regexp . "\\(\\s-+\\)=\\s-+")
                             (modes quote (haskell-mode purescript-mode literate-haskell-mode))))
              (add-to-list 'align-rules-list
                           '(haskell-arrows
                             (regexp . "\\(\\s-+\\)\\(->\\|→\\)\\s-+")
                             (modes quote (haskell-mode purescript-mode literate-haskell-mode))))
              (add-to-list 'align-rules-list
                           '(haskell-left-arrows
                             (regexp . "\\(\\s-+\\)\\(<-\\|←\\)\\s-+")
                             (modes quote (haskell-mode purescript-mode literate-haskell-mode))))))
  )
#+end_src

** temp project roots

#+BEGIN_SRC emacs-lisp
(defvar my/temp-project-root nil)

(defun my/get-or-set-temp-root (reset)
  (let* ((reset-root (if reset my/temp-project-root nil))
         (root
          (if (or reset
                  (null my/temp-project-root)
                  (not (file-directory-p my/temp-project-root)))
              (read-directory-name "Temp root dir: " reset-root)
            my/temp-project-root)))
    (setq my/temp-project-root root)))
#+END_SRC

** edit-indirect

#+BEGIN_SRC emacs-lisp
(use-package edit-indirect
  :ensure t
  :commands (edit-indirect-region)
  :bind ("C-c C-'" . my/edit-indirect-region)
  :config
  (add-hook 'edit-indirect-after-creation-hook 'my/edit-indirect-dedent)
  (add-hook 'edit-indirect-before-commit-hook 'my/edit-indirect-indent))

(defun my/edit-indirect-region ()
  (interactive)
  (unless (region-active-p) (user-error "No region selected"))
  (save-excursion
    (let* ((begin (region-beginning))
           (end (region-end))
           (mode (my/select-a-major-mode))
           (edit-indirect-guess-mode-function
            (lambda (_parent _beg _end)
              (funcall (intern mode)))))
      (edit-indirect-region begin end 'display-buffer))))

(defun my/get-buffer-min-leading-spaces (&optional buffer)
  (let* ((buf (or buffer (current-buffer)))
         (ind nil)
         )
    (save-excursion
      (goto-char (point-min))
      (setq ind (org-get-indentation))
      (while (not (or (evil-eobp) (eobp)))
        (unless (string-match-p "\\`\\s-*$" (thing-at-point 'line))
          (setq ind (min ind (org-get-indentation))))
        (ignore-errors (next-line))
        ))
    ind))

(defun my/edit-indirect-dedent ()
  (let ((amount (my/get-buffer-min-leading-spaces)))
    (setq-local my/edit-indirect-dedented-amount amount)
    (save-excursion
      (indent-rigidly (point-min) (point-max) (- amount)))))

(defun my/edit-indirect-indent ()
  (when (boundp 'my/edit-indirect-dedented-amount)
    (save-excursion
      (indent-rigidly (point-min) (point-max) my/edit-indirect-dedented-amount))))
#+END_SRC

** use =pulse= to flash cursor position

#+begin_src emacs-lisp
;; prot
(use-package pulse
  :commands (pulse-momentary-highlight-one-line)
  :bind ("M-ESC" . my/pulse-line)
  :init
  (defun my/pulse-line ()
    "Temporarily highlight the current line."
    (interactive)
    (let ((pulse-delay .06)
          (face (if (facep 'modus-theme-intense-red)
                    'modus-theme-intense-red
                  'hi-red-b)))
      (pulse-momentary-highlight-one-line (point) face))))
#+end_src

* term & eshell
** terms

#+BEGIN_SRC emacs-lisp
(use-package term
  :defer t
  :config
  (my/add-hooks
   '(term-mode-hook)
   (define-key term-raw-map (kbd "M-o") nil)
   (define-key term-raw-map (kbd "M-+") nil))

  ;; automatically close term buffers on EOF
  (defun my/term-exec-hook ()
    (let* ((buff (current-buffer))
           (proc (get-buffer-process buff)))
      (set-process-sentinel
       proc
       `(lambda (process event)
          (if (string= event "finished\n")
              (kill-buffer ,buff))))))
  (add-hook 'term-exec-hook 'my/term-exec-hook))

(use-package comint
  :defer t
  :init
  (setq comint-prompt-read-only t)
  :config
  (defun my/comint-clear-buffer ()
    (interactive)
    (let ((comint-buffer-maximum-size 0))
      (comint-truncate-buffer)))
  (add-hook 'comint-mode-hook
            (lambda ()
              (define-key comint-mode-map (kbd "C-l") 'my/comint-clear-buffer))))
#+END_SRC

** eshell

#+BEGIN_SRC emacs-lisp
(use-package em-hist :after eshell)

(use-package eshell
  :commands (eshell)
  :bind (("C-!" . my/eshell)
         ("<f2>" . my/eshell)
         :map eshell-mode-map
         ("C-l" . my/eshell-clear)
         ("C-c o" . my/eshell-put-last-output-to-buffer)
         ("C-c h" . my/eshell-narrow-output-highlight-regexp))
  :init
  ;; eshell/clear doesn't work anymore because eshell has its own clear function
  (defun my/eshell-clear ()
    (interactive)
    "Clear the eshell buffer."
    (let ((eshell-buffer-maximum-lines 0))
      (eshell-truncate-buffer)))

  (defalias 'eshell/x 'eshell/exit)
  (defalias 'eshell/e 'find-file)
  (defalias 'eshell/ff 'find-file)

  (setq eshell-destroy-buffer-when-process-dies t
        eshell-history-size 1024
        eshell-prompt-regexp "^[^#$]* [#$] ")

  (setq eshell-prompt-function
        (lambda ()
          (concat
           (propertize
            ((lambda (p-lst)
               (if (> (length p-lst) 3)
                   (concat
                    (mapconcat (lambda (elm) (if (zerop (length elm)) ""
                                               (substring elm 0 1)))
                               (butlast p-lst 3)
                               "/")
                    "/"
                    (mapconcat (lambda (elm) elm)
                               (last p-lst 3)
                               "/"))
                 (mapconcat (lambda (elm) elm)
                            p-lst
                            "/")))
             (split-string (my/eshell-prompt-dir (eshell/pwd)) "/"))
            'face
            'font-lock-type-face)
           (or (my/eshell-prompt-git (eshell/pwd)))
           " "
           (propertize "$" 'face 'font-lock-function-name-face)
           (propertize " " 'face 'default))))
  :config
  (add-hook 'eshell-exit-hook 'delete-window)
  ;; Don't ask, just save
  (if (boundp 'eshell-save-history-on-exit)
      (setq eshell-save-history-on-exit t))
  ;; For older(?) version
  (if (boundp 'eshell-ask-to-save-history)
      (setq eshell-ask-to-save-history 'always)))

(use-package em-smart
  :after eshell
  :init
  (setq eshell-where-to-jump 'begin
        eshell-review-quick-commands nil
        eshell-smart-space-goes-to-end t))

(defun my/eshell (&optional dir prompt)
  "Open up a new shell in the directory associated with the current buffer.

The shell is renamed to match that directory to make multiple
eshell windows easier. If DIR is provided, open the shell there. If PROMPT is
non-nil, prompt for the directory instead. With a prefix argument, prompt for
directory."
  (interactive (list nil current-prefix-arg))
  (let* ((parent (if prompt
                     (read-directory-name "Open eshell in: ")
                   (if dir
                       dir
                     (if (buffer-file-name)
                         (file-name-directory (buffer-file-name))
                       default-directory))))
         (height (/ (window-total-height) 3))
         (name (car (last (split-string parent "/" t))))
         (bufname (format "*eshell:%s*" name))
         (default-directory parent))
    (split-window-vertically (- height))
    (other-window 1)
    (let ((eshell-banner-message
           (format "eshell in %s\n\n"
                   (propertize (abbreviate-file-name parent)
                               'face
                               'font-lock-keyword-face))))
      (eshell :new))
    (rename-buffer (generate-new-buffer-name bufname))))

;; stolen from prot
(defun my/eshell-narrow-output-highlight-regexp ()
  (interactive)
  (let ((regexp (read-regexp "Regexp to highlight" "nothing")))
    (narrow-to-region (eshell-beginning-of-output)
                      (eshell-end-of-output))
    (goto-char (point-min))
    (highlight-regexp regexp 'hi-black-b)))

;; stolen from prot
(defun my/eshell-put-last-output-to-buffer ()
  "Produce a buffer with output of last `eshell' command."
  (interactive)
  (let ((eshell-output (kill-region (eshell-beginning-of-output)
                                    (eshell-end-of-output))))
    (with-current-buffer (get-buffer-create  "*last-eshell-output*")
      (erase-buffer)
      (yank)           ; TODO do it with `insert' and `delete-region'?
      (switch-to-buffer-other-window (current-buffer)))))

(defun my/eshell-prompt-dir (pwd)
  (interactive)
  (let* ((home (expand-file-name (getenv "HOME")))
         (home-len (length home)))
    (if (and
         (>= (length pwd) home-len)
         (equal home (substring pwd 0 home-len)))
        (concat "~" (substring pwd home-len))
      pwd)))

(defun my/eshell-prompt-git (cwd)
  "Returns current git branch as a string, or the empty string if
CWD is not in a git repo (or the git command is not found)."
  (interactive)
  (when (and (eshell-search-path "git")
             (locate-dominating-file cwd ".git"))
    (let ((git-output
           (shell-command-to-string
            (concat "cd "
                    cwd
                    " && git branch | grep '\\*' | sed -e 's/^\\* //'"))))
      (concat
       (propertize
        (concat "["
                (if (> (length git-output) 0)
                    (substring git-output 0 -1)
                  "(no branch)")
                )
        'face 'font-lock-string-face)
       (my/git-collect-status cwd)
       (propertize "]" 'face 'font-lock-string-face)
       )
      )))

;; TODO
;; https://github.com/xuchunyang/eshell-git-prompt/blob/master/eshell-git-prompt.el
(defun my/git-collect-status (cwd)
  (when (and (eshell-search-path "git")
             (locate-dominating-file cwd ".git"))
    (let ((git-output
           (split-string
            (shell-command-to-string
             (concat "cd "
                     cwd
                     " && git status --porcelain"))
            "\n" t))
          (untracked 0)
          (modified 0)
          (modified-updated 0)
          (new-added 0)
          (deleted 0)
          (deleted-updated 0)
          (renamed-updated 0)
          (commits-ahead 0) ;; TODO
          (commits-behind 0) ;; TODO
          )
      (dolist (x git-output)
        (pcase (substring x 0 2)
          ("??" (cl-incf untracked))
          ("MM" (progn (cl-incf modified)
                       (cl-incf modified-updated)))
          (" M" (cl-incf modified))
          ("M " (cl-incf modified-updated))
          ("A " (cl-incf new-added))
          (" D" (cl-incf deleted))
          ("D " (cl-incf deleted-updated))
          ("R " (cl-incf renamed-updated))
          ))
      (concat
       (propertize (if (> (+ untracked deleted) 0) "•" "") 'face '(:foreground "salmon3"))
       (propertize (if (> modified 0) "•" "") 'face '(:foreground "goldenrod3"))
       (propertize (if (> modified-updated 0) "•" "") 'face '(:foreground "SeaGreen4"))))))
#+END_SRC

* UI

#+BEGIN_SRC emacs-lisp
;; highlight numbers
(use-package highlight-numbers
  :ensure t
  :hook ((prog-mode haskell-cabal-mode css-mode) . highlight-numbers-mode))

;; show column in modeline
(setq column-number-mode t)

;; disable annoying stuff
(setq ring-bell-function 'ignore
      inhibit-startup-message t
      inhibit-splash-screen t
      initial-scratch-message nil)
(menu-bar-mode -1)
(scroll-bar-mode -1)
(set-window-scroll-bars (minibuffer-window) nil nil)
(tool-bar-mode -1)

(use-package linum
  :if (< emacs-major-version 26)
  :init (setq linum-format 'dynamic))

(use-package hl-line
  ;; :hook (prog-mode . hl-line-mode)
  :commands (hl-line-mode global-hl-line-mode)
  :init
  (setq hl-line-sticky-flag nil))

(use-package display-fill-column-indicator
  :if (>= emacs-major-version 27)
  :commands (display-fill-column-indicator-mode)
  :hook ((python-mode markdown-mode) . display-fill-column-indicator-mode))
#+END_SRC

** highlight trailing whitespace

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :diminish whitespace-mode
  :diminish global-whitespace-mode
  :hook ((prog-mode . whitespace-mode))
  :init
  (setq whitespace-line-column 80
        whitespace-style '(face trailing)))
#+END_SRC

* Theme
** theme loading

#+BEGIN_SRC emacs-lisp
(when (>= emacs-major-version 27)
  (setq custom--inhibit-theme-enable nil))

(defvar my/avail-themes '(wombat))
(defvar my/current-theme 0)

(defvar my/after-set-theme-hook nil
  "Hook called after setting a theme")

(defun my/set-theme (&optional theme)
  (let ((theme (or theme (elt my/avail-themes my/current-theme))))
    (mapc 'disable-theme custom-enabled-themes)
    (if (functionp theme)
        (funcall theme)
      (load-theme theme t))
    (run-hooks 'my/after-set-theme-hook)))

(defun my/toggle-theme ()
  (interactive)
  (let* ((next-theme (mod (1+ my/current-theme) (length my/avail-themes)))
         (theme (elt my/avail-themes next-theme)))
    (setq my/current-theme next-theme)
    (my/set-theme)))

(defun my/refresh-theme ()
  (interactive)
  (my/set-theme))

(use-package color
  :commands (color-darken-name color-lighten-name))
#+END_SRC

** modus themes
*** =modus-vivendi= (dark)

#+begin_src emacs-lisp
(use-package modus-vivendi-theme
  :ensure t
  :defer t
  :init
  (setq modus-vivendi-theme-visible-fringes t
        modus-vivendi-theme-distinct-org-blocks t
        modus-vivendi-theme-rainbow-headings t
        modus-vivendi-theme-scale-headings t
        modus-vivendi-theme-scale-5 1.3
        modus-vivendi-theme-scale-4 1.2
        modus-vivendi-theme-scale-3 1.0
        modus-vivendi-theme-scale-2 1.0
        modus-vivendi-theme-scale-1 1.0)

  (defvar my/modus-vivendi-theme-alt-colors nil)
  (defvar my/modus-vivendi-theme-haskell-distinct-constructor nil)

  (defun my/modus-vivendi-theme ()
    (load-theme 'modus-vivendi t)
    (modus-vivendi-theme-with-color-variables
      (let* ((hl-line (color-darken-name bg-active 3))
             (pink-subtle "#e8b7e8")
             (type
              (if my/modus-vivendi-theme-alt-colors
                  cyan-refine-fg
                magenta-alt))
             (haskell-constructor
              (if my/modus-vivendi-theme-haskell-distinct-constructor
                  `(:foreground ,(if my/modus-vivendi-theme-alt-colors cyan-refine-fg cyan-alt))
                `(:inherit haskell-type-face))))
        (custom-theme-set-faces
         'modus-vivendi
         `(default ((t (:background "#101010" :foreground "#e7e7e7"))))
         `(hl-line ((t (:background ,hl-line))))
         `(region ((t (:background ,cyan-subtle-bg))))
         `(fringe ((t (:background ,(color-lighten-name bg-inactive 3) :foreground ,fg-inactive))))
         `(secondary-selection ((t (:inherit modus-theme-refine-green))))
         `(fill-column-indicator ((t (:foreground ,fg-window-divider-inner))))

         `(mode-line-inactive ((t (:box ,(modus-vivendi-theme-modeline-box
                                          (color-lighten-name bg-active 8)
                                          (color-lighten-name bg-active 12))
                                        ,@(modus-vivendi-theme-modeline-props
                                           bg-dim (color-darken-name fg-inactive 14)
                                           bg-inactive (color-darken-name fg-inactive 12))))))

         `(hi-green-b ((t (:inherit modus-theme-refine-green :weight bold))))
         `(hi-blue-b((t (:inherit modus-theme-refine-blue :weight bold))))
         `(hi-red-b ((t (:inherit modus-theme-refine-red :weight bold))))
         `(hi-black-b ((t (:inherit modus-theme-refine-yellow :weight bold))))

         `(flycheck-fringe-info ((t (:foreground "DeepSkyBlue2"))))
         `(flycheck-fringe-warning ((t (:foreground "orange1"))))
         `(flycheck-fringe-error ((t (:foreground "#fb4933"))))
         `(flycheck-info ((t (:underline (:color "DeepSkyBlue2" :style wave)))))
         `(flycheck-warning ((t (:underline (:color "orange1" :style wave)))))
         `(flycheck-error ((t (:underline (:color "#fb4933" :style wave)))))

         `(org-block ((t (:foreground "#dadada" :background "#0d1c20" :extend t))))
         `(org-block-begin-line ((t (:foreground "#0798db" :background "#003347" :extend t))))
         `(org-block-end-line ((t (:inherit org-block-begin-line))))
         `(org-ellipsis ((t (:underline t))))
         `(org-roam-link ((t (:inherit modus-theme-subtle-cyan :foreground ,cyan-nuanced :underline t))))
         `(org-ref-cite-face ((t (:foreground ,green :underline t))))

         `(font-lock-type-face ((t (:foreground ,type))))
         `(font-lock-preprocessor-face ((t (:foreground ,red-alt))))
         `(font-lock-builtin-face ((t (:foreground ,(color-darken-name fg-special-mild 3)))))

         `(highlight-numbers-number ((t (:inherit font-lock-string-face))))

         `(haskell-pragma-face ((t (:inherit font-lock-constant-face))))
         `(haskell-constructor-face ((t ,haskell-constructor)))

         `(coq-solve-tactics-face ((t (:foreground ,red))))
         `(coq-cheat-face ((t (:inherit hi-red-b))))
         `(coq-button-face ((t (:inherit hi-green-b))))
         `(coq-button-face-pressed ((t (:inherit hi-green-b :background "grey43"))))

         `(proof-tactics-name-face ((t (:foreground ,blue-alt-other))))
         `(proof-error-face ((t (:inherit hi-red-b))))
         `(proof-locked-face ((t (:background "#173333"))))
         `(proof-queue-face ((t (:background ,(color-darken-name red-subtle-bg 10)))))
         `(proof-warning-face ((t (:background ,(color-darken-name yellow-subtle-bg 5)))))
         `(proof-declaration-name-face ((t (:inherit font-lock-function-name-face :weight bold))))

         `(markdown-header-delimiter-face ((t (:foreground ,cyan :weight bold))))
         `(markdown-list-face ((t (:foreground ,cyan))))

         `(rst-adornment ((t (:foreground ,cyan :weight bold))))
         `(rst-block ((t (:foreground ,cyan))))
         `(rst-definition ((t (:foreground ,magenta))))
         `(rst-directive ((t (:foreground ,magenta))))
         `(rst-external ((t (:foreground ,cyan))))
         `(rst-level-1 ((t (:weight bold))))
         `(rst-level-2 ((t (:inherit rst-level-1))))
         `(rst-level-3 ((t (:inherit rst-level-1))))
         `(rst-level-4 ((t (:inherit rst-level-1))))
         `(rst-level-5 ((t (:inherit rst-level-1))))
         `(rst-level-6 ((t (:inherit rst-level-1))))
         `(rst-literal ((t (:foreground ,fg-special-mild))))
         `(rst-reference ((t (:inherit link))))
         `(rst-transition ((t (:foreground ,red))))
         )
        (custom-theme-set-variables
         'modus-vivendi
         `(coq-highlighted-hyps-bg ,green-subtle-bg))))))
#+end_src

*** =modus-operandi= (light)

#+begin_src emacs-lisp
(use-package modus-operandi-theme
  :ensure t
  :defer t
  :init
  (setq modus-operandi-theme-visible-fringes t
        modus-operandi-theme-distinct-org-blocks t
        modus-operandi-theme-rainbow-headings t
        modus-operandi-theme-scale-headings t
        modus-operandi-theme-scale-5 1.3
        modus-operandi-theme-scale-4 1.2
        modus-operandi-theme-scale-3 1.0
        modus-operandi-theme-scale-2 1.0
        modus-operandi-theme-scale-1 1.0)

  (defvar my/modus-operandi-theme-haskell-distinct-constructor nil)

  (defun my/modus-operandi-theme ()
    (load-theme 'modus-operandi t)
    (modus-operandi-theme-with-color-variables
      (let ((cyan-more-subtle-bg (color-lighten-name cyan-subtle-bg 5))
            (cyan-more-intense (color-darken-name cyan-intense 5))
            (cyan-light (color-darken-name cyan-intense-bg 13))
            (haskell-constructor
             (if my/modus-operandi-theme-haskell-distinct-constructor
                 'font-lock-variable-name-face
               'haskell-type-face))
            (haskell-operator
             (if my/modus-operandi-theme-haskell-distinct-constructor
                 'font-lock-constant-face
               'font-lock-variable-name-face)))
        (custom-theme-set-faces
         'modus-operandi
         `(region ((t (:background ,bg-special-mild))))
         `(secondary-selection ((t (:inherit modus-theme-special-mild))))
         `(fill-column-indicator ((t (:foreground ,bg-tab-bar))))

         `(mode-line-inactive ((t (:box ,(modus-operandi-theme-modeline-box
                                          (color-darken-name bg-active 6)
                                          (color-darken-name bg-active 10))
                                        ,@(modus-operandi-theme-modeline-props
                                           bg-dim (color-lighten-name fg-inactive 15)
                                           bg-inactive (color-lighten-name fg-inactive 15))))))

         `(hi-green-b ((t (:inherit modus-theme-refine-green :weight bold))))
         `(hi-blue-b ((t (:inherit modus-theme-refine-blue :weight bold))))
         `(hi-red-b ((t (:inherit modus-theme-refine-red :weight bold))))
         `(hi-black-b ((t (:inherit modus-theme-refine-yellow :weight bold))))

         `(flycheck-fringe-info ((t (:foreground "DeepSkyBlue2"))))
         `(flycheck-fringe-warning ((t (:foreground "orange1"))))
         `(flycheck-fringe-error ((t (:foreground "#fb4933"))))
         `(flycheck-info ((t (:underline (:color "DeepSkyBlue2" :style wave)))))
         `(flycheck-warning ((t (:underline (:color "orange1" :style wave)))))
         `(flycheck-error ((t (:underline (:color "#fb4933" :style wave)))))

         `(org-ellipsis ((t (:underline t))))
         `(org-roam-link ((t (:background ,cyan-more-subtle-bg :foreground ,cyan-more-intense :underline t))))

         `(haskell-pragma-face ((t (:inherit font-lock-variable-name-face))))
         `(haskell-constructor-face ((t (:inherit ,haskell-constructor))))
         `(haskell-operator-face ((t (:inherit ,haskell-operator))))

         `(coq-cheat-face ((t (:inherit hi-red-b))))

         `(markdown-pre-face ((t (:foreground ,cyan))))
         `(markdown-header-delimiter-face ((t (:foreground ,cyan-light :weight bold))))
         `(markdown-list-face ((t (:foreground ,cyan-light))))

         `(rst-adornment ((t (:foreground ,cyan-light :weight bold))))
         `(rst-block ((t (:foreground ,green))))
         `(rst-definition ((t (:foreground ,magenta))))
         `(rst-directive ((t (:foreground ,magenta))))
         `(rst-external ((t (:foreground ,cyan))))
         `(rst-level-1 ((t (:weight bold))))
         `(rst-level-2 ((t (:inherit rst-level-1))))
         `(rst-level-3 ((t (:inherit rst-level-1))))
         `(rst-level-4 ((t (:inherit rst-level-1))))
         `(rst-level-5 ((t (:inherit rst-level-1))))
         `(rst-level-6 ((t (:inherit rst-level-1))))
         `(rst-literal ((t (:foreground ,cyan))))
         `(rst-reference ((t (:inherit link))))
         `(rst-transition ((t (:foreground ,red))))
         )))))
#+end_src

** zenburn theme (low contrast)

#+begin_src emacs-lisp
(use-package zenburn-theme
  :ensure t
  :defer t
  :init
  (setq zenburn-use-variable-pitch nil
        zenburn-scale-org-headlines t
        zenburn-height-minus-1 1.0
        zenburn-height-plus-4 1.2
        zenburn-height-plus-3 1.0
        zenburn-height-plus-2 1.0
        zenburn-height-plus-1 1.0)

  (defun my/zenburn-theme ()
    (load-theme 'zenburn t)
    (zenburn-with-color-variables
      (custom-theme-set-faces
       'zenburn
       ;; `(region ((t (:background ,zenburn-bg+2))))
       `(vertical-border ((t (:foreground "#a5a5a5"))))
       `(fringe ((t (:background "#484848"))))
       `(hl-line ((t (:background ,zenburn-bg+05))))
       `(fill-column-indicator ((t (:foreground ,zenburn-bg+2))))
       `(compilation-info ((t (:foreground ,zenburn-green+3 :weight bold))))
       `(isearch ((t (:foreground ,zenburn-blue+2 :background ,zenburn-blue-5 :weight bold))))
       `(lazy-highlight ((t (:foreground ,zenburn-green+2 :background ,zenburn-bg+2 :weight bold))))
       `(mode-line ((t
                     (:box
                      (:line-width -1 :color nil :style released-button)
                      :foreground ,zenburn-green+3 :background ,zenburn-bg+05))))
       `(mode-line-inactive ((t
                              (:box
                               (:line-width -1 :color nil :style released-button)
                               :foreground ,zenburn-green-2 :background ,zenburn-bg-05))))
       `(mode-line-buffer-id ((t (:weight bold))))
       `(persp-selected-face ((t (:foreground ,zenburn-yellow-2 :weight bold))))

       `(font-lock-comment-delimiter-face ((t (:inherit font-lock-comment-face))))
       `(font-lock-keyword-face ((t (:foreground ,zenburn-yellow-1 :weight bold))))

       `(diff-hl-insert ((t (:foreground "#789c78" :background "#3c543c"))))
       `(diff-hl-change ((t (:foreground "#79b3b5" :background "#425f61"))))
       `(diff-hl-delete ((t (:foreground "#ab8080" :background "#694848"))))

       `(diredfl-dir-name ((t (:foreground ,zenburn-blue+1 :weight bold))))
       `(diredfl-dir-heading ((t (:foreground ,zenburn-blue-1))))

       `(org-block ((t (:background "#444444" :extend t))))
       `(org-block-begin-line ((t (:background "#4b4b4b" :foreground ,zenburn-fg-05 :slant italic :extend t))))
       `(org-block-end-line ((t (:inherit org-block-begin-line))))
       `(org-roam-link ((t (:foreground ,zenburn-green+3 :background ,zenburn-bg+1 :underline t))))

       `(coq-cheat-face ((t (:background ,zenburn-red-6 :foreground ,zenburn-red+2 :weight bold))))
       `(coq-button-face ((t (:foreground ,zenburn-green+2 :background ,zenburn-bg+05))))
       `(coq-button-face-pressed ((t (:foreground ,zenburn-green+4 :background ,zenburn-bg+2))))

       `(proof-locked-face ((t (:background ,(color-darken-name zenburn-blue-5 4)))))
       `(proof-warning-face ((t (:background ,(color-darken-name zenburn-yellow-2 35)))))
       `(proof-error-face ((t (:background ,zenburn-red-6 :foreground ,zenburn-red+2))))
       `(proof-tactics-name-face ((t (:inherit font-lock-constant-face))))

       `(rst-level-1 ((t (:inherit rst-adornment))))
       `(rst-level-2 ((t (:inherit rst-level-1))))
       `(rst-level-3 ((t (:inherit rst-level-1))))
       `(rst-level-4 ((t (:inherit rst-level-1))))
       `(rst-level-5 ((t (:inherit rst-level-1))))
       `(rst-level-6 ((t (:inherit rst-level-1))))

       `(my/elfeed-blue ((t (:foreground ,zenburn-blue+1))))
       `(my/elfeed-cyan ((t (:foreground ,zenburn-blue-1))))
       `(my/elfeed-olive ((t (:foreground ,zenburn-green))))
       `(my/elfeed-yellow ((t (:foreground ,zenburn-yellow))))
       `(my/elfeed-magenta ((t (:foreground ,zenburn-magenta))))
       `(my/elfeed-red ((t (:foreground ,zenburn-red))))
       `(elfeed-search-date-face ((t (:foreground ,zenburn-orange))))
       )
      (custom-theme-set-variables
       'zenburn
       `(coq-highlighted-hyps-bg ,zenburn-bg+2)))))
#+end_src

* Font

#+BEGIN_SRC emacs-lisp
(defvar my/avail-fonts '(("Monospace" 12)))
(defvar my/current-font 0)
(defvar my/current-font-size nil)
(defvar my/font-size-step 0.5)

(defvar my/after-set-font-hook nil
  "Hook called after updating fonts")

(defun my/set-font (&optional spec)
  (let* ((spec (if (null spec) (elt my/avail-fonts my/current-font) spec))
         (name (car spec))
         (size (cadr spec))
         (spacing (or (caddr spec) 0)))
    (set-face-font 'default (format "%s-%s" name size))
    (setq line-spacing spacing)
    (setq-default line-spacing spacing)
    (run-hooks 'my/after-set-font-hook)))

(defun my/toggle-font ()
  (interactive)
  (let ((next-font (mod (1+ my/current-font) (length my/avail-fonts))))
    (setq my/current-font-size nil)
    (my/set-font (elt my/avail-fonts next-font))
    (setq my/current-font next-font)))

(defun my/refresh-font ()
  (interactive)
  (setq my/current-font-size nil)
  (my/set-font (elt my/avail-fonts my/current-font)))

;; NOTE: trying this out
(defun my/change-font-size (&optional dec)
  (let* ((spec (elt my/avail-fonts my/current-font))
         (name (car spec))
         (size (or my/current-font-size (cadr spec))))
    (setq my/current-font-size
          (if dec
              (- size my/font-size-step)
            (+ size my/font-size-step)))
    (my/set-font (list name my/current-font-size))))

(global-set-key (kbd "C-+") #'(lambda () (interactive) (my/change-font-size)))
(global-set-key (kbd "C--") #'(lambda () (interactive) (my/change-font-size :dec)))
(global-set-key (kbd "C-x C-0") #'my/refresh-font)

;; size & scaling
;; (setq text-scale-mode-step 1.05)
;; (define-key global-map (kbd "C-+") 'text-scale-increase)
;; (define-key global-map (kbd "C--") 'text-scale-decrease)
#+END_SRC

* VCS
** vc

Common prefix is =C-x v=

Some useful commands:

| key            | name                | description                                       |
|----------------+---------------------+---------------------------------------------------|
| C-x v C-h      | -                   | show help for vc-related actions                  |
| C-x v p        | =my/vc-project=     | run =vc-dir= in repo root                         |
| C-x v v        | =vc-next-action=    | next logical action in a repo (init, add, commit) |
| C-x v d /or/ = | =vc-diff=           | show diff for current file                        |
| C-x v D        | =vc-root-diff=      | show diff for whole repo                          |
| C-x v a        | =vc-annotate=       | show history, color-coded                         |
| C-x v h        | =vc-region-history= | show history (buffer or region)                   |
| C-x v l        | =vc-print-log=      | show log for current file                         |
| C-x v +        | =vc-update=         | pull                                              |
| C-x v P        | =vc-push=           | push                                              |

In =vc-git-log-edit-mode=:

| key     | name                   | description   |
|---------+------------------------+---------------|
| C-c C-c | =log-edit-done=        | save commit   |
| C-c C-k | =log-edit-kill-buffer= | cancel commit |

#+BEGIN_SRC emacs-lisp
(use-package vc
  :bind (("C-x v p" . my/vc-project)
         ("C-x v d" . vc-diff))
  :init
  ;; prot
  (defun my/vc-project ()
    (interactive)
    (vc-dir (vc-root-dir)))
  :config
  (add-hook 'vc-git-log-edit-mode-hook 'auto-fill-mode)
  (define-key diff-mode-map (kbd "M-o") nil))

(use-package vc-git
  :init
  (setq vc-git-print-log-follow t))

(use-package vc-annotate
  :bind (("C-x v a" . vc-annotate)
         :map vc-annotate-mode-map
         ("t" . vc-annotate-toggle-annotation-visibility))
  :init
  (setq vc-annotate-display-mode 'scale))
#+END_SRC

** magit

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :commands (magit-status
             magit-dispatch-popup
             magit-blame-addition
             magit-log-buffer-file)
  :bind (("C-x g" . magit-status)
         ("C-x M-g" . magit-dispatch-popup))
  :init
  (defalias 'magb 'magit-blame-addition)
  (defalias 'gl   'magit-log-buffer-file)
  (defalias 'magl 'magit-log-buffer-file)
  :config
  (add-hook 'magit-blame-mode-hook
            (lambda ()
              (if (or (not (boundp 'magit-blame-mode))
                      magit-blame-mode)
                  (evil-emacs-state)
                (evil-exit-emacs-state)))))

;; most stuff copied from prot
(use-package magit-diff
  :after magit
  :init
  (setq magit-diff-refine-hunk t))

(use-package git-commit
  :after magit
  :init
  (setq git-commit-summary-max-length 50)
  (setq git-commit-style-convention-checks
        '(non-empty-second-line
          overlong-summary-line)))

(use-package magit-repos
  :after magit
  :commands (magit-list-repositories)
  :init
  (setq magit-repository-directories
        '(("~/projects" . 1)
          ("~/job/projects" . 1))))

(use-package magit-todos
  :ensure t
  :after magit
  :config
  (magit-todos-mode))
#+END_SRC

** ediff

#+begin_src emacs-lisp
(use-package ediff
  :commands (ediff-files
             ediff-files3
             ediff-buffers
             ediff-buffers3
             smerge-ediff)
  :init
  (setq ediff-keep-variants nil
        ediff-make-buffers-readonly-at-startup nil
        ediff-show-clashes-only t
        ediff-split-window-function 'split-window-horizontally
        ediff-window-setup-function 'ediff-setup-windows-plain))
#+end_src

** git-timemachine

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :ensure t
  :commands (git-timemachine)
  :config
  (add-hook
   'git-timemachine-mode-hook
   '(lambda () (evil-local-mode -1))))
#+END_SRC

** diff-hl & git-gutter+

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :ensure t
  :if is-gui
  :hook ((after-init . global-diff-hl-mode)
         (dired-mode . diff-hl-dired-mode))
  :config
  ;; https://github.com/dgutov/diff-hl#magit
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))

(use-package git-gutter+
  :ensure t
  :unless is-gui
  :diminish
  :hook (after-init . global-git-gutter+-mode))
#+END_SRC

** Helpers

#+BEGIN_SRC emacs-lisp
(defun my/git-blame-current-line ()
  "Runs `git blame` on the current line and
   adds the commit id to the kill ring"
  (interactive)
  (let* ((line-number (save-excursion
                        (goto-char (point-at-bol))
                        (+ 1 (count-lines 1 (point)))))
         (line-arg (format "%d,%d" line-number line-number))
         (commit-buf (generate-new-buffer "*git-blame-line-commit*")))
    (call-process "git" nil commit-buf nil
                  "blame" (buffer-file-name) "-L" line-arg)
    (let* ((commit-id (with-current-buffer commit-buf
                        (buffer-substring 1 9)))
           (log-buf (generate-new-buffer "*git-blame-line-log*")))
      (kill-new commit-id)
      (call-process "git" nil log-buf nil
                    "log" "-1" "--pretty=%h   %an   %s" commit-id)
      (with-current-buffer log-buf
        (message "Line %d: %s"
                 line-number
                 (replace-regexp-in-string "\n\\'" "" (buffer-string))))
      (kill-buffer log-buf))
    (kill-buffer commit-buf)))

(global-set-key (kbd "M-L") #'my/git-blame-current-line)
#+END_SRC

* keybindings
** keybind to command mapping

#+BEGIN_SRC emacs-lisp
(setq my/leader-keys
      '(
        ("SPC" display-fill-column-indicator-mode)

        ("a" align-regexp)

        ;; dired
        ("dn" find-name-dired)
        ("dg" find-grep-dired)
        ("dv" my/git-grep-dired)

        ;; errors
        ("el" my/toggle-flycheck-error-list)

        ;; browsing/files
        ("fc" my/copy-file-path)
        ("fd" pwd)
        ("fp" my/try-open-dominating-file)
        ("fs" my/create-scratch-buffer-with-mode)

        ;; git/vc
        ("gb" my/git-blame-current-line)

        ("h"  help)

        ;; insert
        ("iu" counsel-unicode-char)

        ;; project
        ("pa" counsel-projectile-ag)
        ("pr" counsel-projectile-rg)
        ("ps" my/rg-project-or-ask)
        ("pt" my/counsel-ag-todos-global)

        ;; show/display
        ("sd" pwd)
        ;; find/search
        ("sa" ag)
        ("sr" rg)
        ("sca" counsel-ag)
        ("scr" counsel-rg)
        ("sr" rgrep)

        ;; toggle
        ("t8" display-fill-column-indicator-mode)
        ("tc" global-company-mode)
        ("tf" my/toggle-font)
        ("tg" global-diff-hl-mode)
        ("tl" my/line-numbers)
        ("to" symbol-overlay-mode)
        ("th" hl-line-mode)
        ("ts" flycheck-mode)
        ("tt" my/toggle-theme)
        ("tw" toggle-truncate-lines)

        ;; ui
        ("uh" rainbow-mode)
        ("um" (lambda () (interactive) (call-interactively 'tool-bar-mode) (call-interactively 'menu-bar-mode)))
        ("up" rainbow-delimiters-mode)

        ;; windows
        ("wf" my/window-fixed)
        ("wd" my/window-dedicated)

        ;; theme
        ("Ts" counsel-load-theme)

        ("Q" evil-local-mode)
        ))
#+END_SRC

** setup keybindings

#+begin_src emacs-lisp
(define-prefix-command 'my/leader-map)

;; (define-key ctl-x-map "m" 'my/leader-map)
(define-prefix-command 'my/leader-map)
(global-set-key (kbd "C-c m") 'my/leader-map)

(dolist (i my/leader-keys)
  (let ((k (car i))
        (f (cadr i)))
    (define-key my/leader-map (kbd k) f)))

(define-prefix-command 'my/major-mode-map)

(if is-gui
    (progn
      ;; distinguish `C-m` from `RET`
      (define-key input-decode-map [?\C-m] [C-m])
      ;; distinguish `C-i` from `TAB`
      ;; (define-key input-decode-map [?\C-i] [C-i])
      (global-set-key (kbd "C-c <C-m>") 'my/leader-map)
      (setq my/major-mode-map-key "<C-m>"))
  (setq my/major-mode-map-key "C-c m m"))

;; on hold
;; (defun my/define-major-mode-keys (hook &rest combinations)
;;   "Bind all pairs of (key . function) under `my/major-mode-map-key'
;;
;; The keys are bound after `hook'."
;;   (add-hook
;;    hook
;;    `(lambda ()
;;       (let ((map (make-sparse-keymap)))
;;         (local-set-key (kbd ,my/major-mode-map-key) map)
;;         (dolist (comb (quote ,combinations))
;;           (define-key map (kbd (car comb)) (cdr comb)))))))

(defun my/define-major-mode-key (mode key func)
  (let* ((map-symbol (intern (format "my/%s-map" mode)))
         (hook (intern (format "%s-hook" mode)))
         (map
          (if (boundp map-symbol)
              (symbol-value map-symbol)
            (progn
              (let ((map- (make-sparse-keymap)))
                (add-hook
                 hook
                 `(lambda ()
                    (local-set-key (kbd ,my/major-mode-map-key) (quote ,map-))))
                (set (intern (format "my/%s-map" mode)) map-))))))
    (define-key map (kbd key) func)
    (evil-leader/set-key-for-mode mode (kbd (format "m %s" key)) func)))

(if is-gui
    (global-set-key (kbd "<C-m>") 'my/major-mode-map)
  (global-set-key (kbd "C-c m m") 'my/major-mode-map))
#+end_src

* evil-mode
** evil-mode setup

#+BEGIN_SRC emacs-lisp
(use-package evil-leader
  :hook (evil-local-mode . evil-leader-mode)
  :ensure t
  :config
  ;; (global-evil-leader-mode)
  (evil-leader/set-leader "<SPC>")
  (dolist (i my/leader-keys)
    (let ((k (car i))
          (f (cadr i)))
      (evil-leader/set-key k f))))

(use-package evil-visualstar
  :hook (evil-local-mode . evil-visualstar-mode)
  :ensure t)

(use-package evil
  :ensure t
  :hook ((prog-mode
          text-mode
          haskell-cabal-mode
          bibtex-mode
          coq-mode easycrypt-mode phox-mode
          conf-unix-mode
          conf-colon-mode
          conf-space-mode
          conf-windows-mode
          conf-toml-mode)
         . evil-local-mode)
  :init
  (setq evil-want-C-i-jump nil
        evil-intercept-esc t
        evil-respect-visual-line-mode t
        evil-mode-line-format '(before . mode-line-front-space))
  ;; (setq evil-move-cursor-back nil)  ;; works better with lisp navigation
  :config
  (defun my/make-emacs-mode (mode)
    "Make `mode' use emacs keybindings."
    (delete mode evil-insert-state-modes)
    (add-to-list 'evil-emacs-state-modes mode))

  (global-set-key (kbd "<f5>") 'evil-local-mode)

  ;; don't need C-n, C-p
  (define-key evil-insert-state-map (kbd "C-n") nil)
  (define-key evil-insert-state-map (kbd "C-p") nil)

  ;; magit
  (evil-define-key 'normal magit-blame-mode-map (kbd "q") 'magit-blame-quit)

  ;; intercept ESC when running in terminal
  (evil-esc-mode)

  ;; move search result to center of the screen
  (defadvice evil-search-next
      (after advice-for-evil-search-next activate)
    (evil-scroll-line-to-center (line-number-at-pos)))

  (defadvice evil-search-previous
      (after advice-for-evil-search-previous activate)
    (evil-scroll-line-to-center (line-number-at-pos)))

  ;; this is needed to be able to use C-h
  (global-set-key (kbd "C-h") 'help)
  (define-key evil-normal-state-map (kbd "C-h") 'undefined)
  (define-key evil-insert-state-map (kbd "C-h") 'undefined)
  (define-key evil-visual-state-map (kbd "C-h") 'undefined)

  (define-key evil-emacs-state-map (kbd "C-h") 'help)
  (define-key evil-insert-state-map (kbd "C-k") nil)

  (define-key evil-normal-state-map (kbd "M-.") nil)

  (define-key evil-normal-state-map (kbd "C-h") 'evil-window-left)
  (define-key evil-normal-state-map (kbd "C-j") 'evil-window-down)
  (define-key evil-normal-state-map (kbd "C-k") 'evil-window-up)
  (define-key evil-normal-state-map (kbd "C-l") 'evil-window-right)

  (define-key evil-normal-state-map (kbd ";") 'evil-ex)
  (define-key evil-visual-state-map (kbd ";") 'evil-ex)
  (evil-ex-define-cmd "sv" 'evil-window-split)

  (define-key evil-normal-state-map (kbd "C-p") 'counsel-projectile-find-file)

  (define-key evil-insert-state-map (kbd "C-M-i") 'company-complete)

  (define-key evil-visual-state-map (kbd "<") #'(lambda ()
                                                  (interactive)
                                                  (progn
                                                    (call-interactively 'evil-shift-left)
                                                    (execute-kbd-macro "gv"))))

  (define-key evil-visual-state-map (kbd ">") #'(lambda ()
                                                  (interactive)
                                                  (progn
                                                    (call-interactively 'evil-shift-right)
                                                    (execute-kbd-macro "gv"))))

  ;; redefine so that $ doesn't include the EOL char
  (setq my/evil-$-include-eol nil)
  (evil-define-motion evil-end-of-line (count)
    "Move the cursor to the end of the current line.

If COUNT is given, move COUNT - 1 lines downward first."
    :type inclusive
    (move-end-of-line count)
    (when evil-track-eol
      (setq temporary-goal-column most-positive-fixnum
            this-command 'next-line))
    (unless (and (evil-visual-state-p) my/evil-$-include-eol)
      (evil-adjust-cursor)
      (when (eolp)
        ;; prevent "c$" and "d$" from deleting blank lines
        (setq evil-this-type 'exclusive))))

  ;; https://github.com/emacs-evil/evil-surround/issues/141
  (defmacro my/evil-define-text-object (name key start-regex end-regex)
    (let ((inner-name (make-symbol (concat "evil-inner-" name)))
          (outer-name (make-symbol (concat "evil-a-" name))))
      `(progn
         (evil-define-text-object ,inner-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count nil))
         (evil-define-text-object ,outer-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count t))
         (define-key evil-inner-text-objects-map ,key #',inner-name)
         (define-key evil-outer-text-objects-map ,key #',outer-name))))
  )
#+END_SRC

** evil packages that can be used without evil-mode

#+BEGIN_SRC emacs-lisp
(use-package evil-nerd-commenter
  :ensure t
  :bind ("M-;" . evilnc-comment-or-uncomment-lines)
  :init
  ;; evilnc toggles instead of commenting/uncommenting
  (setq evilnc-invert-comment-line-by-line t))

(use-package evil-surround
  :ensure t
  :hook (after-init . global-evil-surround-mode)
  :config
  (evil-define-key 'visual evil-surround-mode-map "s" 'evil-surround-region)
  (defconst my/mark-active-alist
    `((mark-active
       ,@(let ((m (make-sparse-keymap)))
           (define-key m (kbd "C-c s") 'evil-surround-region)
           m))))
  (add-to-list 'emulation-mode-map-alists 'my/mark-active-alist))
#+END_SRC

** terminal cursor

#+begin_src emacs-lisp
;; in <user-emacs-directory>/lisp
(use-package term-cursor
  :if is-term
  :hook (after-init . global-term-cursor-mode))
#+end_src

* Hybrid input mode

# Copied directly from spacemacs

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'evil
  (defcustom hybrid-mode-default-state 'normal
    "Value of `evil-default-state' for hybrid-mode."
    :group 'my
    :type 'symbol)

  (defcustom hybrid-mode-enable-evilified-state t
    "If non nil then evilified states is enabled in buffer supporting it."
    :group 'my
    :type 'boolean)

  (defvar hybrid-mode-default-state-backup evil-default-state
    "Backup of `evil-default-state'.")

  (defadvice evil-insert-state (around hybrid-insert-to-hybrid-state disable)
    "Forces Hybrid state."
    (evil-hybrid-state))

  (defadvice evil-evilified-state (around hybrid-evilified-to-hybrid-state disable)
    "Forces Hybrid state."
    (if (equal -1 (ad-get-arg 0))
        ad-do-it
      (if hybrid-mode-enable-evilified-state
          ad-do-it
        ;; seems better to set the emacs state instead of hybrid for evilified
        ;; buffers
        (evil-emacs-state))))

  (define-minor-mode hybrid-mode
    "Global minor mode to replace insert state by hybrid state."
    :global t
    :lighter ""
    :group 'my
    (if hybrid-mode
        (enable-hybrid-editing-style)
      (disable-hybrid-editing-style)))

  (defun enable-hybrid-editing-style ()
    "Enable the hybrid editing style."
    (setq hybrid-mode-default-state-backup evil-default-state
          evil-default-state hybrid-mode-default-state)
    ;; replace evil states by `hybrid state'
    (ad-enable-advice 'evil-insert-state
                      'around 'hybrid-insert-to-hybrid-state)
    (ad-enable-advice 'evil-evilified-state
                      'around 'hybrid-evilified-to-hybrid-state)
    (ad-activate 'evil-insert-state)
    (ad-activate 'evil-evilified-state)
    ;; key bindings hooks for dynamic switching of editing styles
    (run-hook-with-args 'spacemacs-editing-style-hook 'hybrid)
    ;; initiate `hybrid state'
    )

  (defun disable-hybrid-editing-style ()
    "Disable the hybrid editing style (reverting to 'vim style)."
    (setq evil-default-state hybrid-mode-default-state-backup)
    ;; restore evil states
    (ad-disable-advice 'evil-insert-state
                       'around 'hybrid-insert-to-hybrid-state)
    (ad-disable-advice 'evil-evilified-state
                       'around 'hybrid-evilified-to-hybrid-state)
    (ad-activate 'evil-insert-state)
    (ad-activate 'evil-evilified-state)
    ;; restore key bindings
    (run-hook-with-args 'spacemacs-editing-style-hook 'vim)
    ;; restore the states
    )

  ;; This code is from evil insert state definition, any change upstream
  ;; should be reflected here
  ;; see https://github.com/emacs-evil/evil/blob/56e92f7cb4e04e665670460093b41f58446b7a2b/evil-states.el#L108
  (evil-define-state hybrid
    "Hybrid state for hybrid mode."
    :tag " <I> "
    :cursor (bar . 2)
    :message "-- HYBRID --"
    :entry-hook (evil-start-track-last-insertion)
    :exit-hook (evil-cleanup-insert-state evil-stop-track-last-insertion)
    :input-method t
    (cond
     ((evil-hybrid-state-p)
      (add-hook 'post-command-hook #'evil-maybe-remove-spaces)
      (add-hook 'pre-command-hook #'evil-insert-repeat-hook)
      (setq evil-maybe-remove-spaces t)
      (unless (eq evil-want-fine-undo t)
        (evil-start-undo-step)))
     (t
      (remove-hook 'post-command-hook #'evil-maybe-remove-spaces)
      (remove-hook 'pre-command-hook #'evil-insert-repeat-hook)
      (evil-maybe-remove-spaces t)
      (setq evil-insert-repeat-info evil-repeat-info)
      (evil-set-marker ?^ nil t)
      (unless (eq evil-want-fine-undo t)
        (evil-end-undo-step))
      (when evil-move-cursor-back
        (when (or (evil-normal-state-p evil-next-state)
                  (evil-motion-state-p evil-next-state))
          (evil-move-cursor-back))))))

  (define-key evil-hybrid-state-map [escape] 'evil-normal-state)

  ;; Override stock evil function `evil-insert-state-p'
  (defun evil-insert-state-p (&optional state)
    "Whether the current state is insert."
    (and evil-local-mode
         (memq (or state evil-state) '(insert hybrid))))

  (define-key evil-hybrid-state-map [escape] 'evil-normal-state)
  ;; (define-key evil-hybrid-state-map (kbd "C-w") 'evil-delete-backward-word)
  )
#+END_SRC

* Spell checking

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :commands (flyspell-mode flyspell-prog-mode)
  :config
  (add-hook 'flyspell-mode-hook
            (lambda () (add-hook 'hack-local-variables-hook 'flyspell-buffer))))
#+END_SRC

* Buffer & window management
** ibuffer

#+begin_src emacs-lisp
(use-package ibuffer
  :init
  ;; `/ R` to toggle showing these groups
  ;; `/ \` to disable
  (setq-default ibuffer-saved-filter-groups
                `(("Default"
                   ("rg" (name . "\*rg.*\*"))
                   ("Dired" (mode . dired-mode))
                   ("Scratch" (name . "\*scratch.*"))
                   ("Temporary" (name . "\*.*\*"))
                   )))
  (setq ibuffer-show-empty-filter-groups nil)
  :config
  (define-key ibuffer-mode-map (kbd "M-o") nil)
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (add-hook 'ibuffer-mode-hook #'(lambda () (ibuffer-auto-mode 1))))
#+end_src

** avy

#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :bind (("C-c i" . avy-goto-char-timer)))
#+END_SRC

** ace-window

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :bind ("C-c o" . ace-window)
  :init
  (setq aw-dispatch-always nil
        aw-keys (string-to-list "asdfghjkl;"))
  (my/add-hooks
   '(term-mode-hook)
   (define-key term-raw-map (kbd "C-c o") #'ace-window)))
#+END_SRC

** buffer-move

#+BEGIN_SRC emacs-lisp
(use-package buffer-move
  :ensure t
  :bind (("<C-S-up>" . buf-move-up)
         ("<C-S-down>" . buf-move-down)
         ("<C-S-left>" . buf-move-left)
         ("<C-S-right>" . buf-move-right)))
#+END_SRC

** zoom

#+begin_src emacs-lisp
(use-package zoom
  :ensure t
  :bind ("M-+" . zoom)
  :init
  (defun my/zoom-size ()
    (let* ((total-w (frame-width))
           (total-h (frame-height))
           (focus-w (max 100 (/ total-w 4)))
           (focus-h (max 65 (/ total-h 3)))
           (rest-w 20)
           (rest-h 10)
           (remain-w (abs (- total-w rest-w)))
           (remain-h (abs (- total-h rest-h)))
           (final-w (min focus-w remain-w))
           (final-h (min focus-h remain-h))
           )
      (cons final-w final-h)
      ))
  (setq zoom-size 'my/zoom-size))
#+end_src

* eww

#+begin_src emacs-lisp
(use-package eww
  :commands (eww)
  :bind (:map eww-mode-map
              ("q" . my/eww-quit))
  :config
  (defun my/eww-quit ()
    (interactive)
    (quit-window :kill)
    (unless (one-window-p) (delete-window))))
#+end_src

* dired

#+BEGIN_SRC emacs-lisp
(use-package dired
  :bind (:map dired-mode-map
              ("j" . dired-next-line)
              ("J" . dired-next-dirline)
              ("k" . dired-previous-line)
              ("K" . dired-prev-dirline)
              ("h" . backward-char)
              ("l" . forward-char)
              ("C-c n" . my/dired-find-file-ace)
              ("M-j" . my/dired-file-jump-from-here)
              ("M-u" . dired-up-directory)
              ("C-c C-q" . my/dired-kill-all-buffers))
  :init
  ;; hide files being edited & flycheck files from dired
  (setq dired-omit-files "\\`[.]?#\\|\\`.flycheck_"
        dired-omit-verbose nil)
  (setq dired-hide-details-hide-symlink-targets nil)
  :config
  (add-hook 'dired-mode-hook #'auto-revert-mode)
  (add-hook 'dired-mode-hook #'dired-omit-mode)

  (define-key dired-mode-map
    (kbd "C-c v")
    (my/control-function-window-split
     dired-find-file-other-window
     nil 0))
  (define-key dired-mode-map
    (kbd "C-c s")
    (my/control-function-window-split
     dired-find-file-other-window
     0 nil)))

(use-package dired-sidebar
  :ensure t
  :commands (dired-sidebar-hide-sidebar
             dired-sidebar-showing-sidebar-p
             dired-sidebar-jump-to-sidebar
             dired-sidebar-toggle-sidebar
             dired-sidebar-toggle-with-current-directory)
  :bind (("C-\"" . my/dired-sidebar-smart-toggle)
         :map dired-sidebar-mode-map
         ("M-u" . dired-sidebar-up-directory))
  :init
  (setq dired-sidebar-theme 'none))

(defun my/dired-sidebar-smart-toggle (curdir)
  (interactive "P")
  (if (eq major-mode 'dired-sidebar-mode)
      (dired-sidebar-hide-sidebar)
    (if (dired-sidebar-showing-sidebar-p)
        (dired-sidebar-jump-to-sidebar)
      (if curdir
          (dired-sidebar-toggle-with-current-directory)
        (dired-sidebar-toggle-sidebar)))))

(use-package dired-subtree
  :ensure t
  :after dired
  :bind (:map dired-mode-map
              ("<tab>" . dired-subtree-toggle)
              ("TAB" . dired-subtree-toggle)))

(use-package dired-filter
  :ensure t
  :after dired)

(use-package dired-git-info
  :ensure t
  :after dired
  :bind (:map dired-mode-map (")" . dired-git-info-mode))
  :commands (dired-git-info-mode))

;; more detailed colors
(use-package diredfl
  :ensure t
  :hook (dired-mode . diredfl-mode))

(defun my/dired-find-file-ace ()
  (interactive)
  (let ((find-file-run-dired t)
        (fname (dired-get-file-for-visit)))
    (if (ace-select-window)
        (find-file fname))))

(defun my/dired-file-jump-from-here ()
  (interactive)
  (let ((find-file-run-dired t)
        (fname (dired-get-file-for-visit)))
    (my/counsel-file-jump-from-here fname)))

(defun my/dired-kill-all-buffers ()
  (interactive)
  (mapc (lambda (buf)
          (when (eq 'dired-mode
                    (buffer-local-value 'major-mode buf))
            (kill-buffer buf)))
        (buffer-list)))

(use-package dired-x
  :after dired
  :init
  (if is-mac (setq dired-use-ls-dired nil)))
#+END_SRC

#+begin_src emacs-lisp
;; https://gist.github.com/surajacharya/4127526
(defun my/git-grep-dired (repo wildcards regexp)
  "Find Git-controlled files in DIR with a name like WILDCARDS containing a regexp REGEXP and start Dired on output."
  (interactive "DGit-grep (directory): \nsGit-grep (filename wildcard(s), e.g. *.xml): \nsGit-grep (grep regexp): ")
  (setq repo (file-name-as-directory (expand-file-name repo)))
  (switch-to-buffer (concat "*Git Grep " repo "*"))
  (fundamental-mode)
  (setq buffer-read-only nil)
  (erase-buffer)
  (setq default-directory repo)
  (let ((cmd (format "git --git-dir %s/.git ls-files -z%s | xargs -0 grep -lZ -- %s | xargs -0 ls -l"
                     repo
                     (apply 'concat (mapcar (lambda (s) (concat " " (shell-quote-argument s))) (split-string wildcards)))
                     (shell-quote-argument regexp))))
    (insert " " cmd "\n " repo ":\n")
    (call-process-shell-command (concat cmd " | sed -e 's/^/ /g'") nil t))
  (dired-mode)

  ;; (dired-build-subdir-alist)
  ;; From find-dired:
  ;; Set subdir-alist so that Tree Dired will work:
  (if (fboundp 'dired-simple-subdir-alist)
      ;; will work even with nested dired format (dired-nstd.el,v 1.15
      ;; and later)
      (dired-simple-subdir-alist)
    ;; else we have an ancient tree dired (or classic dired, where
    ;; this does no harm)
    (set (make-local-variable 'dired-subdir-alist)
         (list (cons default-directory (point-min-marker)))))
  (goto-line 2))
#+end_src

* regex replace
** re-builder (useful for debugging)

#+begin_src emacs-lisp
(use-package re-builder
  :commands (re-builder)
  :init
  (setq reb-re-syntax 'string))
#+end_src

** visual-regexp-steroids

#+begin_src emacs-lisp
(use-package visual-regexp-steroids
  :ensure t
  :bind (("M-%" . vr/replace)
         ("M-S-%" . vr/query-replace))
  :init
  (setq vr/engine 'python
        vr/match-separator-use-custom-face t))
#+end_src

* nix

#+BEGIN_SRC emacs-lisp
(use-package nix-mode
  :ensure t
  :mode (("\\.nix\\'" . nix-mode))
  :init
  (setq nix-nixfmt-bin "nixpkgs-fmt")
  :config
  (my/add-hooks '(nix-mode-hook) (subword-mode 1))
  (my/define-major-mode-key 'nix-mode "s" 'my/nix-format-and-save)
  (my/define-major-mode-key 'nix-mode "m" 'my/nix-mark-multiline-string)
  (define-key nix-mode-map (kbd "C-c '") 'my/nix-edit-indirect-multiline-string))

(defun my/nix-format-and-save ()
  (interactive)
  (nix-format-buffer)
  (save-buffer))

(defun my/nix-mark-multiline-string ()
  (interactive)
  (deactivate-mark)
  (re-search-backward "''$" nil t)
  (next-line)
  (beginning-of-line 1)
  (call-interactively 'set-mark-command)
  (re-search-forward "^\s*''" nil t)
  (previous-line)
  (end-of-line 1))

(defun my/nix-edit-indirect-multiline-string ()
  (interactive)
  (my/nix-mark-multiline-string)
  (my/edit-indirect-region))
#+END_SRC

* direnv

#+begin_src emacs-lisp
(use-package direnv
  :ensure t
  :if (executable-find "direnv")
  :hook (after-init . direnv-mode)
  :init
  (setq direnv-show-paths-in-summary nil
        direnv-always-show-summary nil)
  (unless (fboundp 'file-attribute-size)
    (defun file-attribute-size (attrs) (elt attrs 7))))
#+end_src

* haskell

#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :ensure t
  :mode (("\\.hs\\'" . haskell-mode)
         ("\\.lhs\\'" . literate-haskell-mode)
         ("\\.cabal\\'" . haskell-cabal-mode)
         ("\\.c2hs\\'" . haskell-c2hs-mode)
         ("\\.hcr\\'" . ghc-core-mode)
         ("\\.dump-simpl\\'" . ghc-core-mode))
  :init
  (setq haskell-align-imports-pad-after-name t
        haskell-hoogle-command "hoogle --count=100"
        haskell-interactive-popup-errors nil
        ;; choices: auto, ghci, cabal-repl, cabal-new-repl, stack-ghci
        ;; cabal-new-repl is the one to use with nix-shell & direnv
        haskell-process-type 'cabal-new-repl
        )

  (with-eval-after-load 'evil
    (my/evil-define-text-object "haskell-inline-comment" "#" "{- " " -}"))

  ;; TODO: sort out this shit
  (with-eval-after-load 'smartparens
    (with-eval-after-load 'haskell-mode
      (sp-local-pair 'haskell-mode "'" nil :actions nil)))

  :config
  (my/highlight-keyword-in-mode 'haskell-mode "error" nil 'font-lock-preprocessor-face)
  (my/highlight-keyword-in-mode 'haskell-mode "undefined" nil 'font-lock-preprocessor-face)

  (my/define-major-mode-key 'haskell-mode "aa" 'my/haskell-align-and-sort-everything)
  (my/define-major-mode-key 'haskell-mode "ai" 'my/haskell-align-and-sort-imports)
  (my/define-major-mode-key 'haskell-mode "al" 'my/haskell-align-and-sort-language-extensions)
  (my/define-major-mode-key 'haskell-mode "c" 'projectile-compile-project)
  (my/define-major-mode-key 'haskell-mode "d" 'my/haskell-open-haddock-documentation)
  (my/define-major-mode-key 'haskell-mode "h" 'hoogle)
  (my/define-major-mode-key 'haskell-mode "i" 'my/haskell-insert-import)
  (my/define-major-mode-key 'haskell-mode "l" 'my/haskell-insert-language-extension)
  (my/define-major-mode-key 'haskell-mode "o" 'my/haskell-insert-ghc-option)
  (my/define-major-mode-key 'haskell-mode "r" 'my/haskell-insert-ghcid-repl-statement)
  (my/define-major-mode-key 'haskell-mode "s" 'my/haskell-format-and-save)
  (my/define-major-mode-key 'haskell-mode "/" 'engine/search-hoogle)
  (my/define-major-mode-key 'haskell-mode "?" 'engine/search-stackage)
  (my/define-major-mode-key 'haskell-mode "#" 'engine/search-haskell-language-extensions)

  (my/add-hooks
   '(haskell-mode-hook)
   (setq evil-shift-width 2)
   (push '(?# . ("{- " . " -}")) evil-surround-pairs-alist)
   (haskell-decl-scan-mode)
   (subword-mode 1)
   )
  )

(use-package ormolu
  :ensure t
  :commands (ormolu-format
             ormolu-format-buffer
             ormolu-format-region
             ormolu-format-on-save-mode)
  :init
  (setq ormolu-extra-args
        '("-o" "-XTypeApplications"
          "-o" "-XInstanceSigs"
          "-o" "-XBangPatterns"
          "-o" "-XPatternSynonyms"
          "-o" "-XUnicodeSyntax"
          )))

(defvar my/haskell-align-stuff t)
(defvar my/haskell-use-ormolu nil)

(defun my/haskell-format-brittany ()
  (interactive)
  (my/format-and-save "brittany"))

(defun my/haskell-format-and-save (use-ormolu)
  "Formats the import statements using haskell-stylish and saves
the current file."
  (interactive "P")
  (save-buffer)
  (if (or use-ormolu my/haskell-use-ormolu)
      (ormolu-format-buffer)
    (progn
      (my/haskell-align-and-sort-imports)
      (my/haskell-align-and-sort-language-extensions)))
  (save-buffer))

(defun my/haskell-align-and-sort-imports ()
  (interactive)
  (save-excursion
    (goto-char 0)
    (let ((n-runs 0)
          (max-runs 10))
      (while (and (< n-runs max-runs)
                  (haskell-navigate-imports))
        (progn
          (setq n-runs (1+ n-runs))
          (when my/haskell-align-stuff (call-interactively 'haskell-align-imports))
          (call-interactively 'haskell-sort-imports)))
      (if (>= n-runs max-runs)
          (message "Sorting/aligning imports probably timed out")))))

(defun my/-haskell-mark-language-extensions ()
  (interactive)
  (deactivate-mark)
  (goto-char 0)
  (re-search-forward "^{-# LANGUAGE" nil t)
  (beginning-of-line 1)
  (call-interactively 'set-mark-command)
  (while (re-search-forward "^{-# LANGUAGE" nil t)
    nil)
  (end-of-line 1))

(defun my/haskell-align-and-sort-language-extensions ()
  (interactive)
  (save-excursion
    (when my/haskell-align-stuff
      (my/-haskell-mark-language-extensions)
      (align-regexp (region-beginning) (region-end) "\\(\\s-*\\)#-"))
    (my/-haskell-mark-language-extensions)
    (sort-lines nil (region-beginning) (region-end))))

(defun my/haskell-insert-language-extension ()
  (interactive)
  (let* ((all-exts
          (split-string (shell-command-to-string "ghc --supported-languages")))
         (ext
          (completing-read "extension: "
                           all-exts
                           nil nil nil nil nil)))
    (save-excursion
      (goto-char 0)
      (re-search-forward "^{-#" nil t)
      (beginning-of-line 1)
      (open-line 1)
      (insert (format "{-# LANGUAGE %s #-}" ext))
      (my/haskell-align-and-sort-language-extensions))))

(defun my/haskell-insert-ghc-option ()
  (interactive)
  (let* ((all-opts
          (split-string (shell-command-to-string "ghc --show-options")))
         (ext
          (completing-read "option: "
                           all-opts
                           nil nil nil nil nil)))
    (save-excursion
      (goto-char 0)
      (re-search-forward "^module" nil t)
      (beginning-of-line 1)
      (open-line 1)
      (insert (format "{-# OPTIONS_GHC %s #-}" ext)))))

(defun my/haskell-align-and-sort-everything ()
  (interactive)
  (my/haskell-align-and-sort-imports)
  (my/haskell-align-and-sort-language-extensions))

(defun my/haskell-insert-ghcid-repl-statement (new-line)
  (interactive "P")
  (setq current-prefix-arg nil)
  (when new-line
    (end-of-line 1)
    (call-interactively 'newline))
  (beginning-of-line 1)
  (call-interactively 'delete-horizontal-space)
  (insert "-- $> "))

(defun my/haskell-open-haddock-documentation (use-eww)
  (interactive "P")
  (let ((url "https://haskell-haddock.readthedocs.io/en/latest/markup.html"))
    (if use-eww
        (eww url)
      (browse-url url))))

(defvar my/ghc-source-path (expand-file-name "~/sources/ghc/"))

(defun my/visit-ghc-tags-table ()
  (interactive)
  (let ((tags (expand-file-name "TAGS" my/ghc-source-path)))
    (if (file-exists-p tags)
        (visit-tags-table tags)
      (error "No TAGS file found in ghc source directory"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(use-package intero
  :ensure t
  :after haskell-mode
  :commands (intero-mode-blacklist)
  :hook (haskell-mode . intero-mode-blacklist)
  :diminish intero-mode
  :init
  (setq intero-blacklist '("~/.xmonad"))
  :config
  ;; pretty print (use :pretty, :prettyl, :no-pretty in ghci)
  ;; this has to be installed in every repo until I find a solution
  ;; (setq intero-extra-ghci-options '("-package" "pretty-simple"))

  ;; don't auto insert matching single quotes in haskell mode, since I
  ;; mostly use them for promoted data types
  (define-key intero-mode-map (kbd "M-.") nil)
  (sp-local-pair 'intero-repl-mode "'" nil :actions nil)

  (flycheck-add-next-checker 'intero '(t . haskell-hlint)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(use-package dante
  :ensure t
  :after haskell-mode
  :commands (dante-mode)
  :hook (haskell-mode . dante-mode)
  :init
  (add-hook 'dante-mode-hook
            '(lambda () (flycheck-add-next-checker
                         'haskell-dante
                         '(warning . haskell-hlint)))))
#+END_SRC

* purescript

#+BEGIN_SRC emacs-lisp
(use-package purescript-mode
  :ensure t
  :mode ("\\.purs\\'" . purescript-mode)
  :init
  (setq purescript-indent-offset 2
        purescript-align-imports-pad-after-name t)
  :config
  (my/define-major-mode-key 'purescript-mode "a" 'my/purescript-sort-and-align-imports)
  (my/define-major-mode-key 'purescript-mode "i" 'purescript-navigate-imports)
  (my/define-major-mode-key 'purescript-mode "s" 'my/purescript-format-and-save)
  (my/define-major-mode-key 'purescript-mode "/" 'engine/search-pursuit)
  (add-hook
   'purescript-mode-hook
   (lambda ()
     (setq evil-shift-width 2)
     (turn-on-purescript-indentation)
     (turn-on-purescript-decl-scan)
     ;; (turn-on-purescript-font-lock)
     (push '(?# . ("{- " . " -}")) evil-surround-pairs-alist)
     (subword-mode 1)
     (make-variable-buffer-local 'find-tag-default-function)
     (setq find-tag-default-function (lambda () (current-word t t)))
     ))
  ;; xref for purescript works a bit weird with qualified identifiers
  ;; (define-key purescript-mode-map (kbd "M-.")
  ;; #'(lambda () (interactive) (xref-find-definitions (current-word t t))))
  )

(defvar my/purescript-align-stuff t)

(defun my/purescript-sort-and-align-imports ()
  (interactive)
  (save-excursion
    (goto-line 1)
    (while (purescript-navigate-imports)
      (progn
        (purescript-sort-imports)
        (when my/purescript-align-stuff (purescript-align-imports))))
    (purescript-navigate-imports-return)))

(defun my/purescript-format-and-save ()
  "Formats the import statements using haskell-stylish and saves
the current file."
  (interactive)
  (my/purescript-sort-and-align-imports)
  (save-buffer))

;; This needs to exist in the `load-path'
;; (use-package custom-purescript-font-lock
;;   :after purescript-mode)

;; copy these into the purescript-mode definition
;; (setq-local font-lock-defaults
;;             '((purescript-font-lock-keywords)
;;               nil nil nil nil
;;               (font-lock-syntactic-face-function
;;                . purescript-syntactic-face-function)
;;               (parse-sexp-lookup-properties . t)
;;               (font-lock-extra-managed-props . (composition purescript-type))))
;; (setq-local font-lock-multiline t)
#+END_SRC

* python

#+BEGIN_SRC emacs-lisp
(use-package python
  :mode ("\\.py\\'" . python-mode)
  :init
  (setq python-shell-prompt-detect-failure-warning nil)
  :config
  (my/add-hooks
   '(python-mode-hook)
   (setq-default flycheck-disabled-checkers
                 (append flycheck-disabled-checkers
                         '(python-pycompile))))
  (defun my/python-format-and-save ()
    (interactive)
    (blacken-buffer)
    (py-isort-before-save)
    (save-buffer))
  (my/define-major-mode-key 'python-mode "s" 'my/python-format-and-save))

(use-package blacken
  :ensure t
  :if (executable-find "black")
  :after python
  :commands (blacken-mode blacken-buffer)
  :diminish
  :init
  (setq blacken-line-length 79))

(use-package py-isort
  :ensure t
  :if (executable-find "isort")
  :after python
  :commands (py-isort-buffer py-isort-before-save))

(define-minor-mode my/python-format-on-save-mode
  "Minor mode for autoformatting python buffers on save."
  :lighter " pyf"
  :global nil
  (if my/python-format-on-save-mode
      (if (eq major-mode 'python-mode)
          (progn
            (blacken-mode +1)
            (add-hook 'before-save-hook #'py-isort-before-save nil :local))
        (progn
          (setq my/python-format-on-save-mode nil)
          (user-error "Not a python-mode buffer")))
    (progn
      (blacken-mode -1)
      (remove-hook 'before-save-hook #'py-isort-before-save :local))))

(use-package elpy
  :ensure t
  :hook ((python-mode . elpy-enable))
  :diminish
  :init
  (setq elpy-modules '(elpy-module-sane-defaults
                       elpy-module-company
                       elpy-module-eldoc
                       elpy-module-pyvenv))
  (setq python-shell-interpreter "ipython"
        python-shell-interpreter-args "-i --simple-prompt"))

(defun my/mode-line-venv ())
(use-package pyvenv
  :ensure t
  :after python
  :commands (pyvenv-workon)
  :config
  (defun my/mode-line-venv ()
    (if (string= major-mode "python-mode")
        (let ((venv (if (null pyvenv-virtual-env-name)
                        "-"
                      pyvenv-virtual-env-name)))
          (format "(%s) " venv)
          )
      "")))

(defun eshell/workon (arg) (pyvenv-workon arg))
(defun eshell/deactivate () (pyvenv-deactivate))
#+END_SRC

* js/ts/html/css

#+BEGIN_SRC emacs-lisp
(use-package rjsx-mode
  :ensure t
  :mode (("\\.jsx?\\'" . rjsx-mode))
  :init
  (setq js2-mode-show-strict-warnings nil)
  :config
  (my/define-major-mode-key 'rjsx-mode "s" 'my/prettier-and-save)
  (my/add-hooks
   '(rjsx-mode-hook)
   (setq evil-shift-width 2)
   (define-key js2-mode-map (kbd "C-c C-f") nil)))

(use-package typescript-mode
  :ensure t
  :mode (("\\.ts\\'" . typescript-mode))
  :init
  (setq typescript-indent-level 2)
  :config
  (my/define-major-mode-key 'typescript-mode "s" 'my/prettier-and-save)
  (my/add-hooks
   '(typescript-mode-hook)
   (subword-mode 1)
   (setq evil-shift-width 2)))

(use-package web-mode
  :ensure t
  :mode (("\\.html\\'" . web-html-mode)
         ("\\.tsx\\'" . web-tsx-mode))
  :init
  (setq web-mode-markup-indent-offset 2
        web-mode-css-indent-offset 2
        web-mode-code-indent-offset 2
        web-mode-attr-indent-offset 2)
  (define-derived-mode web-tsx-mode web-mode "web-tsx")
  (define-derived-mode web-html-mode web-mode "web-html")
  :config
  ;; web-tsx-mode
  (my/define-major-mode-key 'web-tsx-mode "s" 'my/prettier-and-save)
  (my/add-hooks '(web-tsx-mode) (subword-mode 1)))

(use-package css-mode
  :mode (("\\.css\\'" . css-mode))
  :init
  (setq css-indent-offset 2
        css-fontify-colors nil))

(use-package js
  :commands (js-mode)
  :init
  (setq js-indent-level 2))

;; (use-package prettier-js
;;   :ensure t
;;   :commands (prettier-js prettier-js-mode my/prettier-and-save)
;;   :init
;;   (setq prettier-js-args '("--trailing-comma" "es5"
;;                            "--tab-width" "2"
;;                            "--semi" "false"
;;                            "--single-quote" "false")))

(defun my/prettier-and-save ()
  (interactive)
  (unless (executable-find "prettier")
    (user-error "`prettier' executable not found"))
  (let* ((fn (file-name-nondirectory buffer-file-name)))
    (my/format-and-save "prettier" "--stdin" "--stdin-filepath" fn))
  (save-buffer))

(use-package emmet-mode
  :ensure t
  :commands (emmet-expand-line)
  :bind (:map web-html-mode-map
              ("<C-return>" . emmet-expand-line)
              :map html-mode-map
              ("<C-return>" . emmet-expand-line)
              :map css-mode-map
              ("<C-return>" . emmet-expand-line))
  :hook ((web-html-mode html-mode css-mode) . emmet-mode))
#+END_SRC

* Lisps
** all lisps

#+BEGIN_SRC emacs-lisp
;; expand macros in another window
(define-key
  lisp-mode-map
  (kbd "C-c C-m")
  #'(lambda () (interactive) (macrostep-expand t)))

(my/add-hooks
 '(lisp-mode-hook emacs-lisp-mode-hook lisp-interaction-mode-hook)
 (eldoc-mode))
#+END_SRC

** emacs lisp

#+BEGIN_SRC emacs-lisp
(use-package elisp-mode
  :mode (("\\.el\\'" . emacs-lisp-mode)
         ("\\.elc\\'" . elisp-byte-code-mode))
  :config
  (defun my/emacs-lisp-format-and-save ()
    (interactive)
    (my/indent-region-or-buffer)
    (save-buffer))

  (my/define-major-mode-key 'emacs-lisp-mode "s" #'my/emacs-lisp-format-and-save))
#+END_SRC

* coq & proof-general

#+BEGIN_SRC emacs-lisp
(use-package proof-general
  :ensure t
  :init
  (setq proof-splash-enable nil
        proof-script-fly-past-comments t))

(use-package holes
  :ensure proof-general
  :after proof-general coq-mode
  :commands (holes-mode)
  :diminish)

(use-package coq-mode
  :ensure proof-general
  :mode (("\\.v\\'" . coq-mode))
  :bind (:map coq-mode-map
              ("C-c ." . proof-electric-terminator-toggle)
              ("M-e" . forward-paragraph)
              ("M-a" . backward-paragraph)
              ("M-RET" . proof-goto-point)
              ("M-n" . proof-assert-next-command-interactive)
              ("M-p" . proof-undo-last-successful-command))
  :init
  (setq coq-one-command-per-line nil
        coq-compile-before-require t)
  :config
  (my/add-hooks
   '(my/after-set-theme-hook)
   (when (fboundp 'coq-highlight-selected-hyps)
     (coq-highlight-selected-hyps)))
  (my/add-hooks
   '(coq-mode-hook)
   (setq evil-shift-width 2)
   (push '(?# . ("(* " . " *)")) evil-surround-pairs-alist)
   (undo-tree-mode 1)
   (whitespace-mode 1))

  (defun my/coq-browse-stdlib ()
    (interactive)
    (browse-url "https://coq.inria.fr/library/"))

  (my/define-major-mode-key 'coq-mode "t" 'engine/search-coq-tactics)
  (my/define-major-mode-key 'coq-mode "i" 'my/coq-browse-stdlib)
  ;; use yas-expand instead
  (define-key coq-mode-map (kbd "<C-return>") nil))
#+END_SRC

* ocaml

#+begin_src emacs-lisp
(use-package tuareg
  :ensure t
  :mode ("\\.ml[ip]?\\'" . tuareg-mode))
#+end_src

* agda

#+begin_src emacs-lisp
;; currently managed by nixos (emacsPackages.agda2-mode)
(use-package agda2-mode
  :mode ("\\.l?agda\\'" . agda2-mode)
  :config
  (my/add-hooks
   '(agda2-mode-hook)
   (activate-input-method "Agda")))
#+end_src

* rust

#+begin_src emacs-lisp
(use-package rust-mode
  :ensure t
  :mode (("\\.rs\\'" . rust-mode)))

(use-package cargo
  :ensure t
  :after rust-mode
  :hook (rust-mode . cargo-minor-mode)
  :diminish cargo-minor-mode)

(use-package flycheck-rust
  :ensure t
  :after (rust-mode flycheck)
  :init
  (with-eval-after-load 'rust-mode
    (add-hook 'flycheck-mode-hook #'flycheck-rust-setup)))

(use-package racer
  :ensure t
  :after rust-mode
  :hook (rust-mode . racer-mode)
  :diminish racer-mode
  :init
  (setq racer-rust-src-path (expand-file-name "rust/src/" "~/sources")))
#+end_src

* markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :bind (:map markdown-mode-map
              ("M-a" . beginning-of-defun)
              ("M-e" . end-of-defun)
              ("TAB" . my/markdown-toggle-heading)
              ("<tab>" . my/markdown-toggle-heading))
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode)
         ("\\.page\\'" . gfm-mode))
  :init
  (setq markdown-asymmetric-header t
        markdown-enable-wiki-links t
        markdown-wiki-link-fontify-missing t
        markdown-enable-math t
        markdown-gfm-use-electric-backquote nil
        markdown-list-indent-width 2
        markdown-command "pandoc --highlight-style=pygments --standalone"
        markdown-css-paths `(,(expand-file-name "static/github.css" user-emacs-directory)))
  :config
  (if (executable-find "marked")
      (setq markdown-command "marked"))
  (my/add-hooks
   '(markdown-mode-hook)
   (auto-fill-mode 1)
   (whitespace-mode +1)
   (push '(?# . ("<!-- " . " -->")) evil-surround-pairs-alist))

  (defun my/markdown-toggle-heading ()
    (interactive)
    (when (markdown-heading-at-point)
      (outline-toggle-children))))

(use-package markdown-toc
  :ensure t
  :after markdown-mode
  :commands (markdown-toc-refresh-toc
             markdown-toc-generate-toc
             markdown-toc-generate-or-refresh-toc)
  :init
  (defalias 'mtoc 'markdown-toc-generate-or-refresh-toc))
#+END_SRC

* LaTeX

#+BEGIN_SRC emacs-lisp
(use-package tex-mode
  :ensure auctex
  :mode (("\\.tex\\'" . latex-mode))
  :init
  (defvar-local my/texcount nil)
  (defun my/texcount-update ()
    (let ((fname (buffer-file-name)))
      (when (and (eq major-mode 'latex-mode)
                 (not (null fname)))
        (setq-local my/texcount
                    (string-trim
                     (shell-command-to-string
                      (format "texcount -sum -brief -total %s" fname)))))))
  (setq TeX-brace-indent-level 0
        LaTeX-item-indent 0
        LaTeX-indent-level 2)
  :config
  (my/add-hooks
   '(LaTeX-mode-hook)
   (smartparens-mode)
   (whitespace-mode)
   (when (executable-find "texcount")
     (my/texcount-update)
     (add-hook 'after-save-hook #'my/texcount-update nil t)))

  (defun my/mode-line-extra-latex-mode ()
    (if (null my/texcount)
        "(-)"
      (let ((face (if (buffer-modified-p)
                      'compilation-warning
                    'compilation-info)))
        (format "(%s)"
                (propertize my/texcount
                            'face
                            face))))))

(use-package latex-preview-pane
  :ensure t
  :after tex-mode
  :commands (latex-preview-pane-mode
             latex-preview-pane-enable))
#+END_SRC

* Other prog modes
** idris

#+BEGIN_SRC emacs-lisp
(use-package idris-mode
  :ensure t
  :mode ("\\.idr\\'" . idris-mode))
#+END_SRC

** c/c++

#+BEGIN_SRC emacs-lisp
(setq c-default-style "linux"
      c-basic-offset 4)
#+END_SRC

** dhall

#+BEGIN_SRC emacs-lisp
(use-package dhall-mode
  :ensure t
  :mode ("\\.dhall\\'" . dhall-mode)
  :init
  (setq dhall-format-at-save nil
        dhall-format-arguments '("--ascii"))

  (with-eval-after-load 'smartparens
    (with-eval-after-load 'dhall-mode
      (sp-local-pair 'dhall-mode "\\(" ")")))

  :config
  (defun my/dhall-format-and-save ()
    (interactive)
    (dhall-format-buffer)
    (save-buffer))

  (my/add-hooks
   '(dhall-mode-hook)
   (setq indent-tabs-mode nil
         evil-shift-width 2))
  (my/define-major-mode-key 'dhall-mode "s" #'my/dhall-format-and-save))
#+END_SRC

** bazel

#+begin_src emacs-lisp
(use-package bazel-mode
  :ensure t
  :mode (("\\.bazel\\'" . bazel-mode)
         ("\\.bzl\\'" . bazel-mode))
  :config
  (defun my/bazel-format-and-save ()
    (interactive)
    (let* ((fn (file-name-nondirectory buffer-file-name))
           (ext (file-name-extension fn))
           (tp (cond
                ((string= fn "BUILD.bazel") "build")
                ((string= ext "bzl") "bzl")
                (t (user-error (format "Not a bazel file extension: %s" ext))))))
      (my/format-and-save "buildifier" "--type" tp))
    (save-buffer))
  (my/define-major-mode-key 'bazel-mode "s" #'my/bazel-format-and-save))
#+end_src

** nginx

#+begin_src emacs-lisp
(use-package nginx-mode
  :ensure t
  :mode (("nginx\\.conf\\'" . nginx-mode)
         ("nginx\\.conf\\.template\\'" . nginx-mode)))
#+end_src

** terraform

#+begin_src emacs-lisp
(use-package terraform-mode
  :ensure t
  :mode ("\\.tf\\'" . terraform-mode)
  :config
  (defun my/terraform-format-and-save ()
    (interactive)
    (terraform-format-buffer)
    (save-buffer))
  (my/define-major-mode-key 'terraform-mode "s" #'my/terraform-format-and-save))
#+end_src

** docker

#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :ensure t
  :mode ("Dockerfile.*" . dockerfile-mode))
#+END_SRC

** elasticsearch

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '(".es\\'" . js-mode))
#+end_src

** json

#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :ensure t
  :mode (("\\.json\\'" . json-mode)
         ("\\.json.tmpl\\'" . json-mode))
  :config
  (defun my/json-format-and-save ()
    (interactive)
    (json-mode-beautify)
    (save-buffer))
  (my/define-major-mode-key 'json-mode "s" #'my/json-format-and-save))
#+END_SRC

** yaml

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :ensure t
  :mode (("\\.ya?ml\\'" . yaml-mode)
         ("\\.ya?ml.template\\'" . yaml-mode)))

(use-package flycheck-yamllint
  :ensure t
  :after (flycheck yaml-mode)
  :commands (flycheck-yamllint-setup)
  :hook (yaml-mode . flycheck-yamllint-setup))
#+END_SRC

** conf

#+begin_src emacs-lisp
;; add env files to conf-mode alist
(add-to-list 'auto-mode-alist '(".env\\'" . conf-mode))
(add-to-list 'auto-mode-alist '(".env.local\\'" . conf-mode))
(add-to-list 'auto-mode-alist '("env\\.example\\'" . conf-mode))
#+end_src

** reStructuredText

#+BEGIN_SRC emacs-lisp
(use-package rst
  :mode ("\\.rst\\'" . rst-mode)
  :bind (:map rst-mode-map
              ("M-a" . rst-backward-section)
              ("M-e" . rst-forward-section))
  :init
  (setq rst-indent-width 2)
  :config
  (my/add-hooks
   '(rst-mode-hook)
   (setq evil-shift-width rst-indent-width)))
#+END_SRC

** asciidoc

#+BEGIN_SRC emacs-lisp
(use-package adoc-mode
  :ensure t
  :mode ("\\.adoc\\'" . adoc-mode))
#+END_SRC

* Other major modes
** elfeed

#+BEGIN_SRC emacs-lisp
(use-package elfeed-web
  :ensure t
  :commands (elfeed-web-start)
  :after elfeed)

(use-package elfeed
  :ensure t
  :commands (elfeed)
  :bind (:map elfeed-search-mode-map
              ("U" . elfeed-update)
              ("o" . my/elfeed-search-other-window)
              ("q" . my/elfeed-kill-buffer-close-window-dwim)
              ("e" . my/elfeed-show-eww)
              ("x" . my/elfeed-org-capture)
              ("h" . backward-char)
              ("j" . next-line)
              ("k" . previous-line)
              ("l" . forward-char)
              :map elfeed-show-mode-map
              ("i" . my/elfeed-hide-images)
              ("e" . my/elfeed-show-eww)
              ("q" . my/elfeed-kill-buffer-close-window-dwim)
              ("h" . backward-char)
              ("j" . next-line)
              ("k" . previous-line)
              ("l" . forward-char)
              ("w" . forward-word)
              ("b" . backward-word))
  :init
  (setq elfeed-db-directory (expand-file-name "elfeed" my/dropbox-emacs-dir)
        elfeed-use-curl t
        elfeed-curl-max-connections 10
        elfeed-search-clipboard-type 'CLIPBOARD
        elfeed-search-filter "@10-days-ago +unread"
        elfeed-search-title-max-width 100
        elfeed-search-title-min-width 30
        elfeed-search-trailing-width 30)
  (setq my/elfeed-org-capture-default-filename (expand-file-name "saved-elfeed-posts.org" my/org-directory))
  :config
  (defun my/elfeed-hide-images (tog)
    (interactive "P")
    (let ((shr-inhibit-images (not tog)))
      (elfeed-show-refresh)))

  ;; prot
  (defun my/elfeed-search-other-window (&optional arg)
    (interactive "P")
    (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                      elfeed-show-entry
                    (elfeed-search-selected :ignore-region)))
           (link (elfeed-entry-link entry))
           (win (selected-window)))
      (with-current-buffer (get-buffer "*elfeed-search*")
        (unless (one-window-p)              ; experimental
          (delete-other-windows win))
        (split-window win (/ (frame-height) 3) 'below)
        (other-window 1)
        (if arg
            (progn
              (when (eq major-mode 'elfeed-search-mode)
                (elfeed-search-untag-all-unread))
              (my/elfeed-show-eww link))
          (elfeed-search-show-entry entry)))))

  (defun my/elfeed-show-eww (&optional link)
    (interactive)
    (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                      elfeed-show-entry
                    (elfeed-search-selected :ignore-region)))
           (link (if link link (elfeed-entry-link entry))))
      (eww link)
      (add-hook 'eww-after-render-hook 'eww-readable nil t)))

  (defun my/elfeed-kill-buffer-close-window-dwim ()
    (interactive)
    (let ((win (selected-window)))
      (cond ((eq major-mode 'elfeed-show-mode)
             (elfeed-kill-buffer)
             (unless (one-window-p) (delete-window win))
             (switch-to-buffer "*elfeed-search*"))
            ((eq major-mode 'elfeed-search-mode)
             (if (one-window-p)
                 (elfeed-search-quit-window)
               (delete-other-windows win))))))

  (defun my/elfeed-org-capture-get-tags (entry)
    (let* ((all-tags (elfeed-entry-tags entry))
           (tags (seq-filter '(lambda (tag) (not (eq tag 'unread))) all-tags))
           (tags-str (mapcar '(lambda (tag) (format "%s" tag)) tags)))
      (if (null tags)
          ""
        (concat ":" (string-join tags-str ":") ":"))))

  (defvar my/elfeed-org-capture-entry nil)
  (defun my/elfeed-org-capture (immediate)
    (interactive "P")
    (let ((my/elfeed-org-capture-entry (elfeed-search-selected :ignore-region))
          (template (if immediate "E" "e")))
      (org-capture nil template)))

  (add-hook 'elfeed-show-mode-hook #'(lambda () (setq-local shr-width 100)))

  (add-hook 'elfeed-new-entry-hook
            (elfeed-make-tagger :before "2 weeks ago"
                                :remove 'unread))

  ;; (add-hook 'elfeed-search-update-hook #'elfeed-db-save)
  (add-hook 'elfeed-update-init-hooks #'elfeed-db-save)

  (defface my/elfeed-important
    '((t (:foreground "salmon")))
    "Elfeed unread"
    :group 'my/faces)
  (push '(important my/elfeed-important) elfeed-search-face-alist)

  ;; get feeds from personal dir
  (load-file (expand-file-name "lisp/elfeed-feeds.el" my/dropbox-emacs-dir)))
#+END_SRC

** pdf tools

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :ensure t
  :defer t
  :magic ("%PDF" . pdf-view-mode)
  :bind (:map pdf-view-mode-map
              ("j" . pdf-view-next-line-or-next-page)
              ("k" . pdf-view-previous-line-or-previous-page)
              ("h" . image-backward-hscroll)
              ("l" . image-forward-hscroll)
              ("C-s" . isearch-forward)
              ("ss" . my/pdf-view-remove-margins-mode)
              ("cc" . pdf-cache-clear-data)
              )
  :init
  (setq pdf-view-display-size 'fit-page
        pdf-view-midnight-colors '("#b3dfdd" . "#0a3749")
        ;; cache stuff, testing
        pdf-cache-image-limit 15
        pdf-cache-prefetch-delay 2
        )
  ;; remove cached images after x seconds
  (setq image-cache-eviction-delay 15)
  :config
  (pdf-tools-install :no-query)

  (defun my/mode-line-extra-pdf-view-mode ()
    (let ((cur (number-to-string (pdf-view-current-page)))
          (tot (or (ignore-errors (number-to-string (pdf-cache-number-of-pages)))
                   "???")))
      (format "(%s/%s)" cur tot)))

  (define-minor-mode my/pdf-view-remove-margins-mode
    "Minor mode for removing margins from every pdf page."
    :lighter " pdf-margins"
    (if (not (eq major-mode 'pdf-view-mode))
        (user-error "Not in a pdf-view-mode buffer")
      (if my/pdf-view-remove-margins-mode
          (progn
            (pdf-view-set-slice-from-bounding-box)
            (add-hook 'pdf-view-after-change-page-hook #'pdf-view-set-slice-from-bounding-box))
        (progn
          (pdf-view-reset-slice)
          (remove-hook 'pdf-view-after-change-page-hook #'pdf-view-set-slice-from-bounding-box)))))
  )

(use-package pdf-outline
  :defer t
  :bind (:map pdf-outline-buffer-mode-map
              ("<backtab>" . outline-hide-sublevels)))
#+END_SRC

** erc

#+BEGIN_SRC emacs-lisp
(use-package erc
  :defer t
  :commands (erc my/erc-freenode)
  :init
  (setq erc-rename-buffers t
        erc-prompt-for-nickserv-password nil
        erc-autojoin-timing 'ident
        erc-fill-function 'erc-fill-static
        erc-fill-static-center 22
        erc-server-reconnect-attempts 5
        erc-server-reconnect-timeout 3
        erc-interpret-mirc-color t
        erc-lurker-hide-list '("JOIN" "PART" "QUIT")
        erc-autojoin-channels-alist '(("freenode.net" "#haskell"))
        erc-fill-column 80
        my/erc-default-nick "runforestrun")
  :config
  (defun my/erc-freenode (select-nick)
    (interactive "P")
    (let ((nick
           (if select-nick
               (read-string "Nick: ")
             my/erc-default-nick)))
      (erc :server "irc.freenode.net" :port 6667 :nick nick)))

  (defun my/erc-preprocess (string)
    "Avoids channel flooding."
    (string-trim (replace-regexp-in-string "\n+" " " str)))

  (defun my/erc-switch-to-buffer ()
    (interactive)
    (let ((read-buffer-function nil))
      (call-interactively 'erc-switch-to-buffer)))
  (define-key erc-mode-map (kbd "C-c C-b") 'my/erc-switch-to-buffer))

;; https://www.reddit.com/r/emacs/comments/8ml6na/tip_how_to_make_erc_fun_to_use/
(use-package erc-hl-nicks
  :ensure t
  :after erc
  :init
  (setq erc-hl-nicks-skip-nicks '("so" "So" "bind" "hackage")))
#+END_SRC

** lilypond

#+begin_src emacs-lisp
;; on NixOS this is available when lilypond is installed
;; TODO: make it work outside NixOs
(use-package lilypond-mode
  :mode ("\\.ly\\'" . LilyPond-mode)
  :init
  (defalias 'lilypond-mode 'LilyPond-mode))
#+end_src

* Searching & jumping
** isearch

=C-h k C-s= to get a help menu for isearch

Some useful isearch keys (before starting the search):

| key   | description                |
|-------+----------------------------|
| M-s . | isearch for thing at point |

And while inside a search:

| key     | description                                   |
|---------+-----------------------------------------------|
| C-w     | add next word to search                       |
| C-e     | add until EOL to search                       |
| M-e     | edit search in minibuffer (commit with =RET=) |
| M-s o   | run =occur=                                   |
| M-s r   | toggle regexp search                          |
| M-s .   | mark whole thing for search                   |
| M-s h r | highlight current search (=hi-lock=)          |
| M-%     | run =query-replace= on search term            |
| C-M-%   | run =query-replace-regexp= on search term     |
| C-l     | =recenter=                                    |

And some custom additions (mostly stolen from Protesilaos):

| where     | key         | description                                   |
|-----------+-------------+-----------------------------------------------|
| in search | C-SPC       | mark search and exit                          |
| in search | C-RET       | exit search, but move point to the other side |
| in search | <backspace> | delete failing part, one char or exit         |

Other useful stuff:

- When exiting a search (with =RET=), =C-x C-x= will mark from where the search started to where
  it finished.

#+BEGIN_SRC emacs-lisp
(use-package isearch
  :diminish
  :bind (:map isearch-mode-map
              ("C-l" . recenter)
              ("C-SPC" . my/isearch-mark-and-exit)
              ("<C-return>" . my/isearch-other-end)
              ("<backspace>" . my/isearch-abort-dwim))
  :init
  (setq search-whitespace-regexp ".*?"  ;; spaces match anything
        isearch-lax-whitespace t  ;; the default
        isearch-regex-lax-whitespace nil
        isearch-yank-on-move 'shift
        isearch-allow-scroll 'unlimited
        isearch-lazy-count t  ;; show match count and current match index
        lazy-count-prefix-format nil
        lazy-count-suffix-format " (%s/%s)")
  :config
  ;; prot
  (defun my/isearch-mark-and-exit ()
    (interactive)
    (push-mark isearch-other-end t 'activate)
    (setq deactivate-mark nil)
    (isearch-done))

  (defun my/isearch-other-end ()
    (interactive)
    (isearch-done)
    (when isearch-other-end
      (goto-char isearch-other-end)))

  (defun my/isearch-abort-dwim ()
    "Delete failed `isearch' input, single char, or cancel search.

This is a modified variant of `isearch-abort' that allows us to
perform the following, based on the specifics of the case: (i)
delete the entirety of a non-matching part, when present; (ii)
delete a single character, when possible; (iii) exit current
search if no character is present and go back to point where the
search started."
    (interactive)
    (if (eq (length isearch-string) 0)
        (isearch-cancel)
      (isearch-del-char)
      (while (or (not isearch-success) isearch-error)
        (isearch-pop-state)))
    (isearch-update))

  ;; https://www.reddit.com/r/emacs/comments/b7yjje/isearch_region_search/
  (defun my/isearch-region (&optional not-regexp no-recursive-edit)
    "If a region is active, make this the isearch default search pattern."
    (interactive "P\np")
    (when (use-region-p)
      (let ((search (buffer-substring-no-properties
                     (region-beginning)
                     (region-end))))
        (deactivate-mark)
        (isearch-yank-string search))))

  (advice-add 'isearch-forward :after 'my/isearch-region)
  (advice-add 'isearch-forward-regexp :after 'my/isearch-region)
  (advice-add 'isearch-backward :after 'my/isearch-region)
  (advice-add 'isearch-backward-regexp :after 'my/isearch-region)

  (with-eval-after-load 'evil
    (dolist (st '(normal visual))
      (evil-global-set-key st (kbd "gs") 'isearch-forward)
      (evil-global-set-key st (kbd "gr") 'isearch-backward)))
  )
#+END_SRC

** rg

#+BEGIN_SRC emacs-lisp
(use-package rg
  :ensure t
  :commands (rg my/rg-project-or-ask)
  :bind (("C-c g" . my/rg-project-or-ask)
         :map rg-mode-map
         ("m" . rg-menu)
         ("s" . my/rg-save-search-as-name)
         ("N" . my/rg-open-ace-window)
         ("C-n" . next-line)
         ("C-p" . previous-line)
         ("j" . next-line)
         ("k" . previous-line)
         ("M-n" . rg-next-file)
         ("M-p" . rg-prev-file))
  :init
  (setq rg-group-result t
        rg-ignore-case 'smart)
  (setq rg-custom-type-aliases
        '(("coq" . "*.v")))
  (defalias 'rgp 'my/rg-project-or-ask)
  :config
  (rg-define-toggle "--multiline --multiline-dotall" "u")
  (rg-define-toggle "--word-regexp" "w")
  (rg-define-toggle "--files-with-matches" "L")

  (rg-define-search my/rg-org-directory
    :query ask
    :format regexp
    :files "org"
    :dir my/org-directory
    :confirm prefix)

  ;; prot
  ;; https://protesilaos.com/dotemacs/#h:31622bf2-526b-4426-9fda-c0fc59ac8f4b
  (rg-define-search my/rg-project-or-ask
    :query ask
    :format regexp
    :files "all"
    :dir (or (projectile-project-root)
             (read-directory-name "rg in: "))
    :confirm prefix)

  (defun my/rg-save-search-as-name ()
    "Save `rg' buffer, naming it after the current search query."
    (interactive)
    (let ((pattern (rg-search-pattern rg-cur-search)))
      (rg-save-search-as-name (concat "«" pattern "»"))))

  (defun my/rg-open-ace-window (&optional event)
    (interactive)
    (flet ((pop-to-buffer (buf &rest args)
                          (let ((pop-up-windows nil))
                            (if (get-buffer-window buf)
                                (while (not (equal buf (current-buffer)))
                                  (other-window 1))
                              (progn
                                (ace-window nil)
                                (switch-to-buffer buf))))))
          (compile-goto-error event)))
  )

#+END_SRC

** imenu-list

#+BEGIN_SRC emacs-lisp
(use-package imenu-list
  :ensure t
  :bind ("C-|" . my/imenu-list-smart-toggle)
  :config

  (defun my/imenu-list-jump-to-window ()
    "Jump to imenu-list window if visible, otherwise create it and jump."
    (interactive)
    (if (get-buffer-window imenu-list-buffer-name)
        (select-window (get-buffer-window imenu-list-buffer-name))
      (progn
        (imenu-list-minor-mode)
        (select-window (get-buffer-window imenu-list-buffer-name)))))

  (defun my/imenu-list-smart-toggle ()
    "If imenu-list window doesn't exist, create it and jump. If if does but
it is not the current buffer, jump there. If it exists and it's the current
buffer, close it."
    (interactive)
    (if (eq (current-buffer) (get-buffer imenu-list-buffer-name))
        (imenu-list-quit-window)
      (my/imenu-list-jump-to-window)))

  (setq imenu-list-size 40))
#+END_SRC

** mark

#+BEGIN_SRC emacs-lisp
(defun my/goto-line-show ()
  "Show line numbers temporarily, while prompting for the line number input."
  (interactive)
  (let ((cur display-line-numbers))
    (unwind-protect
        (progn
          (setq display-line-numbers t)
          (call-interactively #'goto-line))
      (setq display-line-numbers cur))))

(global-set-key (kbd "M-g M-g") 'my/goto-line-show)

(define-key prog-mode-map (kbd "M-a") 'beginning-of-defun)
(define-key prog-mode-map (kbd "M-e") 'end-of-defun)

(defun my/push-mark-no-activate ()
  "Pushes `point' to `mark-ring' and does not activate the region
   Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
  (interactive)
  (push-mark (point) t nil)
  (message "Pushed mark to ring"))

(global-set-key (kbd "C-`") 'my/push-mark-no-activate)

(defun my/jump-to-mark ()
  "Jumps to the local mark, respecting the `mark-ring' order.
  This is the same as using \\[set-mark-command] with the prefix argument."
  (interactive)
  (set-mark-command 1))

(global-set-key (kbd "M-`") 'my/jump-to-mark)
#+END_SRC

** anzu

#+BEGIN_SRC emacs-lisp
(use-package anzu
  :ensure t
  :hook (after-init . global-anzu-mode)
  :diminish
  :init
  (setq anzu-mode-lighter ""))

(use-package evil-anzu
  :ensure t
  :after (evil anzu))
#+END_SRC

* company

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :diminish company-mode
  :bind (("C-M-i" . company-complete)
         :map company-active-map
         ("C-p" . company-select-previous)
         ("C-n" . company-select-next)
         ("C-f" . company-show-location)
         ("TAB" . company-complete-common-or-cycle)
         ("<tab>" . company-complete-common-or-cycle)
         ("<escape>" . company-abort))
  :hook ((after-init . global-company-mode)
         (global-company-mode . company-quickhelp-mode))
  :init
  (setq company-dabbrev-downcase nil
        company-minimum-prefix-length 3
        company-idle-delay 0.4)
  :config
  (setq company-backends (delete 'company-dabbrev company-backends))
  (setq company-backends (delete 'company-capf company-backends))
  (add-to-list 'company-backends 'company-elisp)
  (add-to-list 'company-backends 'company-anaconda)
  (add-to-list 'company-backends 'company-files))

(use-package company-quickhelp
  :ensure t
  :after company)

(use-package company-anaconda
  :ensure t
  :after (company anaconda-mode))
#+END_SRC

* flycheck

#+BEGIN_SRC emacs-lisp
(defun my/mode-line-flycheck ())

(use-package flycheck
  :ensure t
  :diminish flycheck-mode
  :bind (("C-c ! t" . flycheck-mode))
  :hook (after-init . global-flycheck-mode)
  :init
  (setq flycheck-temp-prefix ".flycheck"
        flycheck-emacs-lisp-load-path 'inherit
        flycheck-check-syntax-automatically '(save mode-enabled)
        ;; to check while typing:
        ;; flycheck-check-syntax-automatically '(save idle-change new-line mode-enabled)
        )
  :config
  (defun my/toggle-flycheck-error-list ()
    (interactive)
    (-if-let (window (flycheck-get-error-list-window))
        (quit-window nil window)
      (flycheck-list-errors)))

  (add-to-list 'display-buffer-alist
               `(,(rx bos "*Flycheck errors*" eos)
                 (display-buffer-reuse-window
                  display-buffer-in-side-window)
                 (side            . bottom)
                 (reusable-frames . visible)
                 (window-height   . 0.33)))

  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(javascript-jshint haskell-ghc haskell-stack-ghc)))
  (flycheck-add-mode 'javascript-eslint 'web-mode)
  (flycheck-add-mode 'javascript-eslint 'js2-mode)

  ;; modeline stuff
  (defface modeline-flycheck-error
    '((t (:foreground "#e05e5e" :distant-foreground "#e05e5e")))
    "Face for flycheck error feedback in the modeline."
    :group 'modeline-flycheck)
  (defface modeline-flycheck-warning
    '((t (:foreground "#bfb03d" :distant-foreground "#bfb03d")))
    "Face for flycheck warning feedback in the modeline."
    :group 'modeline-flycheck)
  (defface modeline-flycheck-info
    '((t (:foreground "DeepSkyBlue3" :distant-foreground "DeepSkyBlue3")))
    "Face for flycheck info feedback in the modeline."
    :group 'modeline-flycheck)
  (defface modeline-flycheck-ok
    '((t (:foreground "SeaGreen3" :distant-foreground "SeaGreen3")))
    "Face for flycheck ok feedback in the modeline."
    :group 'modeline-flycheck)

  (defvar modeline-flycheck-bullet "•%s")

  (defun my/mode-line-flycheck-state (state)
    (let* ((counts (flycheck-count-errors flycheck-current-errors))
           (errorp (flycheck-has-current-errors-p state))
           (err (or (cdr (assq state counts)) "?"))
           (running (eq 'running flycheck-last-status-change))
           (face (intern (format "modeline-flycheck-%S" state))))
      (if (or errorp running)
          (propertize (format modeline-flycheck-bullet err) 'face face))))

  (defun my/mode-line-flycheck ()
    (let* ((ml-error (my/mode-line-flycheck-state 'error))
           (ml-warning (my/mode-line-flycheck-state 'warning))
           (ml-info (my/mode-line-flycheck-state 'info))
           (ml-status (concat ml-error ml-warning ml-info)))
      (if (null ml-status) "" (concat " " ml-status " ")))))
#+END_SRC

* projectile

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :hook (after-init . projectile-mode)
  :bind-keymap ("C-c p" . projectile-command-map)
  :diminish projectile-mode
  :init
  (setq projectile-completion-system 'ivy
        projectile-mode-line-function
        '(lambda () (format " P[%s]" (or (projectile-project-name) "-")))))

(use-package perspective
  :ensure t
  :hook (after-init . persp-mode)
  :bind (("M-N" . persp-next)
         ("M-P" . persp-prev)
         ("M-J" . persp-switch))
  :config
  ;; accidentally changing perspectives while in the minibuffer messes things up
  ;; using `ignore' (rather than nil) makes these keys do nothing
  (add-hook 'minibuffer-setup-hook
            '(lambda ()
               (dolist (k '("M-N" "M-P" "M-J"))
                 (local-set-key (kbd k) 'ignore))))
  (advice-add 'persp-switch
              :after
              #'(lambda (n &optional r)
                  (message (persp-name (persp-curr)))))
  ;; emacs window title
  (setq frame-title-format
        '("" invocation-name "@" system-name
          (:eval (when persp-mode (format "[%s]" (persp-name (persp-curr))))))))

(use-package persp-projectile
  :ensure t
  :after (perspective projectile))
#+END_SRC

#+begin_src emacs-lisp
;; override chosen project names
(defvar my/projectile-project-name-overrides '())

(defun my/projectile-add-to-project-name-overrides (proj name)
  (add-to-list
   'my/projectile-project-name-overrides
   `(,(file-name-as-directory (expand-file-name proj)) . ,name)))

(defun my/projectile-override-project-name (orig &rest args)
  (let* ((dir (file-name-as-directory (expand-file-name (car args))))
         (match (assoc dir my/projectile-project-name-overrides))
         (name (if (null match) nil (cdr match))))
    (if (null name)
        (apply orig args)
      name)))

(advice-add 'projectile-default-project-name :around #'my/projectile-override-project-name)

;; usage:
;; (dolist (override '(
;;                     ("/path/to/my/project" . "some-name")
;;                     ("/other/project" . "some-other-name")
;;                     ))
;;   (let ((proj (car override))
;;         (name (cdr override)))
;;     (my/projectile-add-to-project-name-overrides proj name)))
#+end_src

* ivy/counsel/swiper

#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  :ensure t
  :after projectile
  :bind (:map projectile-command-map
              ("f" . counsel-projectile-find-file)
              ("s" . counsel-projectile-rg)
              ("b" . counsel-projectile-switch-to-buffer))
  :init
  (setq projectile-switch-project-action 'counsel-projectile-find-file))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/swiper (fuzzy)
  (interactive "P")
  (if fuzzy
      (let* ((temp-builders
              (copy-alist ivy-re-builders-alist))
             (ivy-re-builders-alist
              (add-to-list 'temp-builders
                           '(swiper . ivy--regex-fuzzy))))
        (swiper))
    (swiper)))

(defun my/swiper-fuzzy-or-all (all)
  (interactive "P")
  (if all
      (swiper-all)
    (my/swiper :fuzzy)))

(defun my/swiper-isearch (fuzzy)
  (interactive "P")
  (if fuzzy
      (let* ((temp-builders
              (copy-alist ivy-re-builders-alist))
             (ivy-re-builders-alist
              (add-to-list 'temp-builders
                           '(swiper-isearch . ivy--regex-fuzzy))))
        (swiper-isearch))
    (swiper-isearch)))

(use-package swiper
  :ensure t
  :bind (("C-c f" . my/swiper-fuzzy-or-all))
  :commands (swiper swiper-isearch swiper-all swiper-multi))

;; better fuzzy matching
(use-package flx
  :ensure t
  :after ivy)

;; mostly to bring recently used M-x targets at the top
;; (trying out instead of `smex`)
(use-package amx
  :ensure t
  :after ivy
  :init
  (setq amx-backend 'auto
        amx-save-file (expand-file-name "amx-items" user-emacs-directory)
        amx-history-length 50
        amx-show-key-bindings nil)
  :config
  (amx-mode +1))

(defun my/ivy-reset-builders ()
  (setq ivy-re-builders-alist
        '((swiper               . ivy--regex-plus)
          (swiper-isearch       . ivy--regex-plus)
          (ivy-bibtex           . ivy--regex-ignore-order)
          (counsel-unicode-char . ivy--regex-ignore-order)
          (insert-char          . ivy--regex-ignore-order)
          (ucs-insert           . ivy--regex-ignore-order)
          (counsel-unicode-char . ivy--regex-ignore-order)
          (counsel-ag           . ivy--regex-ignore-order)  ;; NOTE: testing
          (counsel-rg           . ivy--regex-ignore-order)
          (t                    . ivy--regex-fuzzy))))

(defun my/counsel-rg-in ()
  (interactive)
  (counsel-rg nil (read-directory-name "rg in: ") ""))

(defun my/counsel-file-jump-temp-root (reset)
  (interactive "P")
  (my/get-or-set-temp-root reset)
  (let ((current-prefix-arg nil))
    (counsel-file-jump nil my/temp-project-root)))

(defun my/counsel-rg-temp-root (reset)
  (interactive "P")
  (my/get-or-set-temp-root reset)
  (let ((current-prefix-arg nil))
    (counsel-rg "" my/temp-project-root)))

(defun my/set-temp-root-and-jump (dir)
  (setq my/temp-project-root dir)
  (my/counsel-file-jump-temp-root nil))

(defun my/counsel-file-jump-from-here (path)
  (interactive)
  (let ((dir (if (file-directory-p path)
                 path
               (file-name-directory path))))
    (counsel-file-jump "" dir)))

(use-package counsel
  :ensure t
  :after ivy
  :bind (("M-x" . counsel-M-x)
         ("M-i" . counsel-imenu)
         ("C-x C-f" . counsel-find-file)
         ("C-x f" . counsel-file-jump)
         ("C-x r b" . counsel-bookmark)
         ("C-x C-a" . counsel-recentf)
         ("C-c s" . my/counsel-rg-in)
         ("C-S-p" . my/counsel-file-jump-temp-root)
         ("C-S-s" . my/counsel-rg-temp-root)
         :map org-mode-map
         ("M-i" . counsel-outline)
         :map help-map
         ("f" . counsel-describe-function)
         ("o" . counsel-describe-symbol)
         ("u" . counsel-describe-face)
         ("v" . counsel-describe-variable))
  :diminish
  :init
  (setq counsel-rg-base-command "rg --with-filename --no-heading --line-number --color never -S %s"
        counsel-ag-base-command "ag --vimgrep --nocolor --nogroup %s")
  :config
  (my/ivy-reset-builders)
  (setq ivy-initial-inputs-alist nil) ;; no ^ initially
  ;; counsel-ag
  ;; S-SPC doesn't work properly in counsel-ag anyway
  ;; NOTE: this also applies to rg
  (define-key counsel-ag-map (kbd "S-SPC") nil)

  (dolist (action '(counsel-find-file counsel-file-jump counsel-recentf))
    (ivy-set-actions
     action
     `(
       ("s"
        ,(my/control-function-window-split
          find-file-other-window
          0 nil)
        "split horizontally")
       ("v"
        ,(my/control-function-window-split
          find-file-other-window
          nil 0)
        "split vertically")
       ("n"
        ,(my/execute-f-with-hook
          find-file
          ace-select-window)
        "select window")
       ("e"
        my/eshell
        "eshell")
       ("j"
        my/counsel-file-jump-from-here
        "jump")
       ("J"
        my/set-temp-root-and-jump
        "set temp root and jump")
       ("r"
        (lambda (dir) (counsel-rg nil dir))
        "counsel-rg")
       )))

  (dolist (action '(counsel-projectile-find-file projectile-recentf))
    (ivy-set-actions
     action
     `(("s"
        ,(my/control-function-window-split
          counsel-projectile-find-file-action-other-window
          0 nil)
        "split horizontally")
       ("v"
        ,(my/control-function-window-split
          counsel-projectile-find-file-action-other-window
          nil 0)
        "split vertically")
       ("n"
        ,(my/execute-f-with-hook
          counsel-projectile-find-file-action
          ace-select-window)
        "select window")
       ("R"
        (lambda (f) (projectile-recentf))
        "recent files")
       ("e"
        (lambda (f) (my/eshell (projectile-expand-root f)))
        "eshell")
       )))

  ;; also applies to counsel-projectile-ag
  (dolist (action '(counsel-ag counsel-rg))
    (ivy-set-actions
     action
     '(("v"
        (lambda (x) (split-window-right) (windmove-right) (counsel-git-grep-action x))
        "split vertically")
       ("s"
        (lambda (x) (split-window-below) (windmove-down) (counsel-git-grep-action x))
        "split horizontally")
       ("n"
        (lambda (x) (ace-select-window) (counsel-git-grep-action x))
        "select window")
       ))))

(defun my/ivy-yank-current-region-or-word (&optional qual)
  "Insert current region, if it's active, otherwise the current word,into
the minibuffer."
  (interactive "P")
  (let (text)
    (with-ivy-window
      (unwind-protect
          (setq text
                (if (region-active-p)
                    (buffer-substring-no-properties (region-beginning) (region-end))
                  (current-word t (not qual))))))
    (when text (insert text))))

(use-package ivy
  :ensure t
  :diminish ivy-mode
  :hook (after-init . ivy-mode)
  :bind (("C-c r" . ivy-resume)
         ("C-x b" . ivy-switch-buffer)
         :map ivy-minibuffer-map
         ("M-j" . my/ivy-yank-current-region-or-word)
         ("M-r" . ivy-rotate-preferred-builders)
         ("C-l" . ivy-call-and-recenter)
         ("C-o" . ivy-minibuffer-grow)
         ("C-S-o" . ivy-minibuffer-shrink))
  :init
  (setq ivy-use-virtual-buffers nil
        ivy-count-format "(%d/%d) "
        ivy-magic-tilde nil
        ivy-initial-inputs-alist nil)
  :config
  (my/ivy-reset-builders)

  ;; minibuffer actions for specific commands
  (ivy-set-actions
   'ivy-switch-buffer
   `(("s"
      ,(my/control-function-window-split
        ivy--switch-buffer-other-window-action
        0 nil)
      "split horizontally")
     ("v"
      ,(my/control-function-window-split
        ivy--switch-buffer-other-window-action
        nil 0)
      "split vertically")
     ("n"
      ,(my/execute-f-with-hook
        (lambda (b) (switch-to-buffer b nil 'force-same-window))
        ace-select-window)
      "select window")
     ("k" kill-buffer "kill buffer")
     ))

  (ivy-set-actions
   'projectile-switch-project
   '(("d"
      dired
      "Open Dired in project's directory")
     ("v"
      projectile-vc
      "Open project root in vc-dir or magit")
     ("r"
      projectile-remove-known-project
      "Remove project(s)"))))

(use-package ivy-xref  ;; currently in lisp/ because of patches
  :commands (ivy-xref-show-xrefs)
  :init (setq xref-show-xrefs-function 'ivy-xref-show-xrefs)
  :after ivy)
#+END_SRC

* yasnippet

#+BEGIN_SRC emacs-lisp
(use-package yasnippet-snippets
  :ensure t
  :after yasnippet
  :config
  (yas-reload-all))

(use-package yasnippet
  :ensure t
  :bind (("C-c y" . yas-expand)
         ("<C-return>" . yas-expand))
  :diminish (yas-global-mode yas-minor-mode)
  :config
  ;; NOTE: the reason for not putting it in `after-init-hook' is to defer
  ;; loading until it `yas-expand' has been run the first time
  (yas-global-mode +1))
#+END_SRC

* org-mode

#+BEGIN_SRC emacs-lisp
;; this is the same as doing org-babel-load-languages
(use-package ob-python :commands (org-babel-execute:python))
(use-package ob-sql :commands (org-babel-execute:sql))
(use-package ob-lilypond
  :commands (org-babel-execute:lilypond)
  :custom
  (org-babel-lilypond-commands '("lilypond -daux-files=#f" "xdg-open" "xdg-open"))
  :config
  (defun my/org-lilypond-preprocess-block (args)
    (let* ((defaults (string-join
                      '("\\layout{"
                        "#(layout-set-staff-size 25)"
                        "}"
                        "\\paper{"
                        "indent=0\\mm"
                        "line-width=200\\mm"
                        "oddFooterMarkup=##f"
                        "oddHeaderMarkup=##f"
                        "bookTitleMarkup=##f"
                        "scoreTitleMarkup=##f"
                        "}"
                        )
                      "\n"))
           (body (car args))
           (newbody (format "%s\n%s" defaults body))
           (params (cadr args)))
      (list newbody params)))
  (advice-add 'org-babel-execute:lilypond
              :filter-args
              'my/org-lilypond-preprocess-block))

;; use this bookmark:
;; javascript:location.href='org-protocol://capture?template=r'+
;;   '&url='+encodeURIComponent(location.href)+
;;   '&title='+encodeURIComponent(document.title)+
;;   '&body='+encodeURIComponent(window.getSelection())
(require 'org-protocol)
;; Without this, quitting an org-protocol capture results in re-opening
;; the link with another mimeapp (firefox), and might result in an
;; infinite loop. This still deletes the client, but it does so cleanly.
;; TODO: think of a better way
(advice-add 'server-return-error
            :override
            '(lambda (proc err)
               (message "exiting client")
               (server-delete-client proc)))

(use-package org-capture
  :after org
  :commands (org-capture)
  :bind (("C-c c" . org-capture))
  :config
  (setq org-capture-templates
        '(("r"
           "Web link (roam)"
           entry
           (file my/org-roam-find-filename)
           "* %^{Title|%:description} %U\nSource: %a \n\n%i")
          ("e"
           "Elfeed"
           entry
           (file my/org-roam-find-filename)
           "* %U %(car (elfeed-entry-id my/elfeed-org-capture-entry)) - \
%(elfeed-entry-title my/elfeed-org-capture-entry) \
%(my/elfeed-org-capture-get-tags my/elfeed-org-capture-entry)
%(elfeed-entry-link my/elfeed-org-capture-entry)")
          ("E"
           "Elfeed (immediate)"
           entry
           (file my/elfeed-org-capture-default-filename)
           "* %U %(car (elfeed-entry-id my/elfeed-org-capture-entry)) - \
%(elfeed-entry-title my/elfeed-org-capture-entry) \
%(my/elfeed-org-capture-get-tags my/elfeed-org-capture-entry)
%(elfeed-entry-link my/elfeed-org-capture-entry)"
           :immediate-finish t)
          ("i"
           "Immediate note"
           entry
           (file my/org-roam-find-filename)
           "* %U %:description\n%i"
           :immediate-finish t)
          ("l"
           "Link to file"
           entry
           (file my/org-roam-find-filename)
           "* TODO %?\n%a\n\n%i")
          ("c"
           "Code comment"
           entry
           (file my/org-roam-find-filename)
           "* TODO %?\n%a\n\n#+begin_src %^{Language}\n%i#+end_src\n\n"))))

(use-package org-indent
  :after org
  :hook (org-mode . org-indent-mode)
  :commands (org-indent-mode)
  :diminish)

(use-package org-agenda
  :after org
  :bind (("C-c a" . org-agenda))
  :init
  (setq org-agenda-custom-commands
        '(("c" "Simple agenda view"
           ((tags "PRIORITY=\"A\""
                  ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-overriding-header "High-priority unfinished tasks:")))
            (agenda "")
            (alltodo "")))))
  (setq org-agenda-files (list my/org-directory
                               (expand-file-name "papers" my/org-directory)
                               (expand-file-name "orgzly" my/org-directory))))

(use-package org-src
  :after org
  :init
  (setq org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-src-window-setup 'other-window
        org-src-preserve-indentation t))

(use-package ox
  :after org
  :init
  (setq org-export-with-toc nil
        org-export-with-section-numbers 1))

(use-package org
  :mode ("\\.org\\'" . org-mode)
  :bind (("C-c l" . org-store-link)
         ("C-c &" . org-mark-ring-goto))
  :init
  (setq org-directory my/org-directory
        org-default-notes-file (expand-file-name "notes.org" org-directory)
        org-log-done 'time
        org-confirm-babel-evaluate nil
        org-clock-into-drawer nil
        org-keep-stored-link-after-insertion t
        org-edit-src-content-indentation 0
        org-src-window-setup 'other-window
        org-adapt-indentation nil
        org-ellipsis "…"
        org-tags-column -80
        org-image-actual-width nil
        org-startup-with-inline-images t
        org-blank-before-new-entry '((heading . nil) (plain-list-item . nil))
        org-todo-keywords '((sequence "TODO" "IN PROGRESS" "|" "DONE"))
        org-todo-keyword-faces '(("IN PROGRESS" . (:foreground "DarkOrange3" :weight bold)))
        org-link-frame-setup '((file . find-file)))

  ;; templates
  (setq org-structure-template-alist
        '(("s" . "src")
          ("e" . "example")
          ("q" . "quote")
          ("v" . "verse")
          ("ht" . "export html")
          ("la" . "export latex")
          ("b" . "src bash")
          ("el" . "src emacs-lisp")
          ("h" . "src haskell")
          ("p" . "src python")))

  (setq org-tempo-keywords-alist
        '(("I" . "INDEX")
          ("L" . "LATEX")
          ("T" . "TITLE")
          ("H" . "HTML")))

  ;; refile
  (setq org-refile-targets '((nil . (:maxlevel . 1)))
        org-refile-use-outline-path 'file
        org-outline-path-complete-in-steps nil)
  ;; format string used when creating CLOCKSUM lines and when generating a
  ;; time duration (avoid showing days)
  (setq org-time-clocksum-format
        '(:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t))

  :config
  (require 'org-tempo nil :noerror)

  (my/define-major-mode-key 'org-mode "c" 'org-cliplink)
  (my/define-major-mode-key 'org-mode "it" 'my/org-insert-date-today)
  (my/define-major-mode-key 'org-mode "tl" 'org-toggle-link-display)
  (my/define-major-mode-key 'org-mode "tm" 'my/org-toggle-markup)

  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)

  (my/set-mode-fill-width 'org-mode-hook 100)
  (my/add-hooks
   '(org-mode-hook)
   (define-key org-mode-map (kbd "TAB") 'org-cycle)
   (define-key org-mode-map (kbd "<tab>") 'org-cycle)
   (evil-define-key 'normal org-mode-map (kbd "TAB") 'org-cycle)
   (evil-define-key 'normal org-mode-map (kbd "<tab>") 'org-cycle))

  ;; kill any "unsaved" fontification buffer that might cause a save prompt when quitting emacs
  (advice-add 'save-buffers-kill-terminal
              :before
              #'my/org-kill-fontification-buffers))

(defun my/org-insert-date-today (active)
  (interactive "P")
  (org-insert-time-stamp (current-time) nil (not active)))

(defun my/org-toggle-markup ()
  (interactive)
  (setq org-hide-emphasis-markers (not org-hide-emphasis-markers))
  (font-lock-fontify-buffer :interactively))

(defun my/org-export-conf ()
  (interactive)
  (let ((org-export-with-toc t)
        (org-export-with-section-numbers 1)
        (org-html-htmlize-output-type 'css)
        (org-html-head-extra
         (string-join
          '("<link href=\"/htmlize.css\" rel=\"stylesheet\">"
            "<link href=\"/readtheorg.css\" rel=\"stylesheet\">"
            ) "\n")))
    (with-temp-buffer
      (insert-file (expand-file-name "configuration.org" user-emacs-directory))
      (org-export-to-file 'html (expand-file-name "docs/index.html" user-emacs-directory)))))

(defun my/org-kill-fontification-buffers (&optional silent)
  (mapc
   #'kill-buffer
   (seq-filter
    (lambda (buf)
      (string-match "^\\ \\*org-src-fontification:.*\\*$" (buffer-name buf)))
    (buffer-list))))

(use-package org-cliplink
  :ensure t
  :after org
  :bind (:map org-mode-map
              ("C-c C-S-l" . org-cliplink))
  :init
  (setq org-cliplink-max-length 80))

(use-package org-bullets
  :ensure t
  :if is-gui
  :after org
  :hook (org-mode . org-bullets-mode)
  :init
  (setq org-bullets-bullet-list (append '("◉") (make-list 7 "○"))
        org-hide-leading-stars t))

(use-package htmlize
  :ensure t
  :defer t
  :init
  (setq org-html-htmlize-output-type 'inline-css))
#+END_SRC

* org-roam

#+BEGIN_SRC emacs-lisp
(use-package org-roam
  :ensure t
  :hook (after-init . org-roam-mode)
  :diminish
  :bind (:map org-roam-mode-map
              ("C-c n b" . org-roam-switch-to-buffer)
              ("C-c n f" . org-roam-find-file)
              ("C-c n g" . org-roam-graph)
              ("C-c n j" . org-roam-dailies-today)
              ("C-c n J" . org-roam-dailies-date)
              ("C-c n l" . org-roam)
              ("C-c n s" . my/org-roam-rg)
              ("C-c n S" . my/rg-org-directory)
              ("C-c n u" . org-roam-unlinked-references)
              ("C-c n x" . org-roam-jump-to-index)
              ("C-c n !" . my/org-roam-refresh)
              :map org-mode-map
              ("C-c n I" . org-roam-insert)
              ("C-c n i" . org-roam-insert-immediate))
  :init
  (setq org-roam-directory my/org-directory
        org-roam-db-location (expand-file-name "org-roam.db" user-emacs-directory)
        org-roam-index-file "home.org"
        org-roam-link-title-format "%s")
  (setq org-roam-graph-viewer
        (or (executable-find "google-chrome-stable")
            (executable-find "google-chrome")
            (executable-find "firefox"))
        org-roam-graph-exclude-matcher '("index.org" "theindex.org" "home.org"))
  (setq org-roam-dailies-capture-templates
        '(("d" "daily" plain (function org-roam-capture--get-point)
           ""
           :immediate-finish t
           :file-name "daily-%<%Y-%m-%d>"
           :head "#+TITLE: %<%A, %d %b %Y>\n\n- tags :: [[file:daily.org][daily notes]]\n")
          ))
  :config
  (add-to-list 'org-refile-targets '(org-roam--list-all-files . (:maxlevel . 1)))
  (add-hook 'org-roam-backlinks-mode-hook 'org-indent-mode)
  (my/add-hooks
   '(org-mode-hook)
   (when (and (buffer-file-name)
              (org-roam--org-roam-file-p (buffer-file-name)))
     (add-hook 'before-save-hook #'my/org-roam-add-roam-tags-property nil t)))
  (with-eval-after-load 'evil
    (evil-define-key 'visual org-mode-map (kbd "[[") 'org-roam-insert-immediate))
  ;; don't show tags in `org-roam-find-file'
  (advice-add 'org-roam--get-title-path-completions
              :filter-return
              #'my/org-roam-process-title-path-completions)
  (add-to-list 'org-tempo-keywords-alist '("ra" . "ROAM_ALIAS"))
  (add-to-list 'org-tempo-keywords-alist '("rt" . "ROAM_TAGS")))

(use-package org-roam-protocol
  :after org-roam)

(use-package company-org-roam
  :ensure t
  :after company org-roam
  :config
  (push 'company-org-roam company-backends))

(use-package org-roam-server
  :ensure t
  :commands (org-roam-server-mode)
  :init
  (setq org-roam-server-port 25002))

;; this is in lisp/ for now
(use-package my-org-roam-publish
  :after org-roam
  :commands (my/org-roam-publish)
  :bind (:map org-roam-mode-map
              ("C-c n p" . my/org-roam-publish)
              ("C-c n P" . my/org-roam-publish-current-file)))

(defun my/org-roam-refresh ()
  (interactive)
  (org-roam-db-build-cache :force)
  (org-roam-buffer--update-maybe :redisplay))

(defun my/org-roam-rg-transformer (str)
  (if (string-match "\\`\\([^:]+\\):\\([^:]+\\):" str)
      (let* ((parts (split-string str ":"))
             (path (elt parts 0))
             (line (elt parts 1))
             (match (string-join (cddr parts) ":"))
             (abspath (concat org-roam-directory path))
             (roam-title (org-roam--get-title-or-slug abspath)))
        (format "%s:%s:%s"
                (propertize roam-title 'face 'ivy-grep-info)
                (propertize line 'face 'ivy-grep-line-number)
                match))
    str))

(defun my/org-roam-rg ()
  (interactive)
  ;; this is required, otherwise the transformers alist that will be edited when
  ;; counsel initializes will be the temporary one :/
  ;; TODO: find a better way
  (unless (featurep 'counsel) (require 'counsel))
  (let ((ivy--display-transformers-alist '((counsel-rg . my/org-roam-rg-transformer))))
    (counsel-rg "" org-roam-directory "-g '*.org'")))

(defun my/org-roam-process-title-path-completions (completions)
  (mapc
   '(lambda (x)
      (let ((str (car x)))
        (setcar x (replace-regexp-in-string "\\((.*)\\) " "" str))))
   (copy-alist completions)))

(defun my/org-roam-filename-from-title (title)
  (let* ((tmpl (concat org-roam-capture--file-name-default "-${slug}"))
         (slug (org-roam--title-to-slug title)))
    (string-trim (org-roam-capture--fill-template tmpl `((slug . ,slug))))))

(defun my/org-roam-find-filename ()
  (let* ((completions (org-roam--get-title-path-completions))
         (title (org-roam-completion--completing-read "File: " completions))
         (filename (plist-get (cdr (assoc title completions)) :path)))
    (if (null filename)
        (let* ((create-fn (concat (my/org-roam-filename-from-title title) ".org"))
               (key (format "#+TITLE: %s\n\n" title)))
          (setq filename (expand-file-name create-fn org-roam-directory))
          (write-region key nil filename)
          (org-roam-db-build-cache :force)))
    filename))

(defun my/org-roam-extract-tags ()
  (let ((tags nil))
    (org-element-map (org-element-parse-buffer) 'plain-list
      (lambda (lst)
        (when (eq (org-element-property :type lst) 'descriptive)
          (org-element-map lst 'item
            (lambda (item)
              (let* ((maybe-tag (elt (org-element-property :tag item) 0))
                     (tag (and (stringp maybe-tag)
                               (substring-no-properties (elt (org-element-property :tag item) 0)))))
                (when (and tag
                           (string-equal tag "tags"))
                  (org-element-map item 'paragraph
                    (lambda (par)
                      (org-element-map par 'link
                        (lambda (link)
                          (add-to-list 'tags (substring-no-properties (elt link 2)))))))))))))
      nil :first-only)
    (reverse tags)))

(defun my/org-roam-add-roam-tags-property ()
  (let* ((tags (my/org-roam-extract-tags))
         (tags-str ""))
    (dolist (tag tags)
      (setq tags-str
            (concat tags-str
                    (format " \"%s\"" tag))))
    (save-excursion
      (goto-char (point-min))
      (if (re-search-forward "^#\\+ROAM_TAGS" nil t)
          (progn
            (beginning-of-line 1)
            (kill-line))
        (goto-char (point-min))
        (re-search-forward "^$")
        (newline)
        (previous-line))
      (if tags
          (insert (format "#+ROAM_TAGS:%s" tags-str))
        (kill-line)))))
#+END_SRC

* org-download

#+begin_src emacs-lisp
(use-package org-download
  :ensure t
  :after org
  :hook (org-mode . org-download-enable)
  :init
  (setq org-download-method 'directory
        org-download-screenshot-method "scrot -s %s"
        org-download-image-dir "~/Pictures/Screenshots/"
        org-download-heading-lvl nil)
  :config
  (defalias 'scrot 'org-download-screenshot))
#+end_src

* org-ref, org-noter & bibtex

#+begin_src emacs-lisp
(defvar my/dropbox-papers-dir (expand-file-name "papers/" my/dropbox-dir)
  "Dropbox papers directory")

(defvar my/dropbox-papers-bibtex (expand-file-name "papers.bib" my/dropbox-papers-dir)
  "Dropbox bibtex bibliography file")

(use-package bibtex
  :mode (("\\.bib\\'" . bibtex-mode))
  :bind (:map bibtex-mode-map
              ("C-c C-c" . my/bibtex-format-and-clean-entry))
  :init
  (setq bibtex-autokey-year-length 4
        bibtex-autokey-name-year-separator "-"
        bibtex-autokey-year-title-separator "-"
        bibtex-autokey-titleword-separator "-"
        bibtex-autokey-titlewords 2
        bibtex-autokey-titlewords-stretch 1
        bibtex-autokey-titleword-length 5)
  :config
  (defun my/bibtex-format-and-clean-entry ()
    (interactive)
    (call-interactively 'bibtex-fill-entry)
    (call-interactively 'bibtex-clean-entry)
    (call-interactively 'org-ref-clean-bibtex-entry)))

(use-package bibtex-completion
  :ensure t
  :after helm-bibtex
  :init
  (setq bibtex-completion-library-path (list my/dropbox-papers-dir)
        bibtex-completion-pdf-field "file"
        bibtex-completion-bibliography (list my/dropbox-papers-bibtex)
        bibtex-completion-notes-path (expand-file-name "papers/" my/org-directory)
        bibtex-completion-notes-template-multiple-files (string-join '("#+TITLE: [Paper] ${author-or-editor} (${year}): ${title}"
                                                                       "#+ROAM_KEY: cite:${=key=}\n\n"
                                                                       )
                                                                     "\n")))

(use-package biblio-core
  :ensure t
  :defer t
  :bind (:map biblio-selection-mode-map
              ("a" . my/biblio-append-bibtex-to-papers))
  :config
  (defun my/-biblio-append-bibtex-to-papers (bibtex entry)
    (find-file-other-window my/dropbox-papers-bibtex)
    (goto-char (point-max))
    (newline)
    (newline)
    (insert bibtex))
  (defun my/biblio-append-bibtex-to-papers ()
    (interactive)
    (biblio--selection-forward-bibtex #'my/-biblio-append-bibtex-to-papers)))

(use-package helm
  :ensure t
  :defer t
  :init
  (setq helm-display-function #'display-buffer)
  (add-to-list 'display-buffer-alist
               '("\\`\\*helm"
                 (display-buffer-in-side-window)
                 (inhibit-same-window . t)
                 (window-height . 0.4))))

(use-package helm-bibtex
  :ensure t
  :bind (("C-c n r" . helm-bibtex)))

(use-package org-ref
  :ensure t
  :bind (:map org-mode-map
              ("C-c ]" . org-ref-helm-insert-cite-link))
  :after org
  :init
  (setq org-ref-default-bibliography (list my/dropbox-papers-bibtex)
        org-ref-pdf-directory my/dropbox-papers-dir
        org-ref-notes-function 'org-ref-notes-function-many-files
        org-ref-cite-completion-function 'org-ref-ivy-cite))

(use-package org-noter
  :ensure t
  :commands (org-noter)
  :after org
  :init
  (setq org-noter-always-create-frame nil)
  (setq my/org-roam-noter-heading-name "Interleaved notes")
  (defun my/org-roam-noter ()
    "Start org-noter for current notes file, creating the headline if not found."
    (interactive)
    (let ((pos (save-excursion
                 (goto-char 0)
                 (re-search-forward
                  (format "^* %s" my/org-roam-noter-heading-name)
                  nil
                  t))))
      (if pos
          (progn
            (goto-char pos)
            (beginning-of-line 1)
            (org-noter))
        (let* ((ref (cdr (org-roam--extract-ref)))
               (pdf-name (format "%s.pdf" ref))
               (pdf-path (expand-file-name pdf-name my/dropbox-papers-dir))
               (pdf-path-rel (file-relative-name pdf-path))
               (props
                (string-join `(":PROPERTIES:"
                               ,(format ":NOTER_DOCUMENT: %s" pdf-path-rel)
                               ":END:") "\n")))
          (insert (format "* %s" my/org-roam-noter-heading-name))
          (org-set-tags '("org_noter"))
          (org-return)
          (insert props)
          (org-noter))))))
#+end_src

* deft

#+begin_src emacs-lisp
(use-package deft
  :ensure t
  :after org-roam
  :bind (("C-c n d" . deft)
         ("<f8>" . deft)
         ("C-x <f8>" . deft-find-file)
         :map deft-mode-map
         ("C-c C-g" . my/deft-refresh))
  :init
  (setq deft-directory my/org-directory
        deft-recursive t
        deft-file-limit 50
        deft-extensions '("org")
        deft-ignore-file-regexp "index.org\\|theindex.org"
        deft-use-filter-string-for-filename t
        deft-file-naming-rules '((noslash . "_")
                                 (nospace . "_")
                                 (case-fn . downcase)))
  (defun my/deft-refresh ()
    (interactive)
    (my/org-roam-refresh)
    (deft-refresh))

  :config
  (advice-add 'deft-new-file-named :filter-args '(lambda (n) (mapcar 'my/org-roam-filename-from-title n))))

#+end_src

* modeline
** Selected window & focused frame

#+BEGIN_SRC emacs-lisp
;; is window selected?
(defvar my/-selected-window nil)
;; (add-hook 'post-command-hook '(lambda () (setq my/-selected-window (selected-window))))
(add-hook 'post-command-hook
          '(lambda ()
             (when (not (minibuffer-window-active-p (selected-window)))
               (setq my/-selected-window (selected-window)))))
(add-hook 'buffer-list-update-hook '(lambda () (force-mode-line-update t)))

;; is emacs focused?
(defvar my/-focused-in t)
(add-hook 'focus-in-hook '(lambda () (setq my/-focused-in t)))
(add-hook 'focus-out-hook '(lambda () (setq my/-focused-in nil)))

(defun my/current-window-active-p ()
  (and my/-focused-in
       (eq my/-selected-window (selected-window))))
#+END_SRC

** Regular modeline

#+BEGIN_SRC emacs-lisp
(setq-default mode-line-format
              '("%e"
                mode-line-front-space
                ;; evil-mode-line-tag
                mode-line-mule-info
                mode-line-client mode-line-modified mode-line-remote
                mode-line-frame-identification mode-line-buffer-identification " "
                mode-line-position
                (vc-mode vc-mode)
                (:eval (my/mode-line-flycheck))
                (:eval (my/mode-line-venv))
                mode-line-modes mode-line-misc-info mode-line-end-spaces))

(defun my/mode-line-window-info ()
  (let* ((dedicated (window-dedicated-p))
         (fixed window-size-fixed)
         (pad (if (or dedicated fixed) " " "")))
    (format "%s%s%s%s"
            pad
            (if dedicated "×" "")
            (if fixed "+" "")
            pad)))

(setq mode-line-misc-info
      (cons '(:eval (my/mode-line-window-info)) mode-line-misc-info))
#+END_SRC

** Experimental new modeline

#+BEGIN_SRC emacs-lisp
;; for the position hud
(use-package powerline
  :ensure t
  :commands (pl/render powerline-hud))

;; TODO: make it better
(defun my/split-mode-line-render (left right-wide right-narrow right-super-narrow)
  (let* ((fmt-left (format-mode-line left))
         (available-width (- (window-total-width)
                             (+ (length fmt-left)
                                (length (format-mode-line right-wide)))))
         (right right-wide))
    (when (< available-width 0)  ;; narrow
      (setq right right-narrow)
      (setq available-width (- (window-total-width)
                               (+ (length fmt-left)
                                  (length (format-mode-line right-narrow))))))
    (when (< available-width 0)  ;; super narrow
      (setq right right-super-narrow)
      (setq available-width (- (window-total-width)
                               (+ (length fmt-left)
                                  (length (format-mode-line right-super-narrow))))))
    (append left
            (list (format (format "%%%ds" available-width) ""))
            right)))

(defun my/mode-line-hud ()
  (let* ((active (eq my/-selected-window (selected-window)))
         (face0 (if active 'powerline-active0 'powerline-inactive0))
         (face2 (if active 'powerline-active2 'powerline-inactive2)))
    (pl/render (powerline-hud face0 face2))))

(defun my/mode-line-vc ()
  (let ((fname (buffer-file-name)))
    (if (or (null fname) (null vc-mode))
        nil
      (let ((br (let ((backend (vc-backend fname)))
                  (substring vc-mode (+ (if (eq backend 'Hg) 2 3) 2))))
            (st (pcase (vc-state fname)
                  ('up-to-date (propertize "✓" 'face '(:inherit compilation-info :weight bold)))
                  ('edited (propertize "•" 'face 'compilation-warning))
                  ('added (propertize "+" 'face '(:inherit compilation-info :weight bold)))
                  ('removed (propertize "✗" 'face '(:inherit compilation-error :weight bold)))
                  ('missing (propertize "?" 'face '(:inherit compilation-error :weight bold)))
                  (_ "?"))))
        (format "%s %s "
                (truncate-string-to-width br 21 nil nil "…")
                st)))))

(defun my/mode-line-region-info ()
  (when mark-active
    (let* ((evilp (and (featurep 'evil) (or evil-local-mode evil-mode)))
           (beg (if evilp evil-visual-beginning (region-beginning)))
           (end (if evilp evil-visual-end (region-end)))
           (lines (count-lines beg end))
           (words (count-words beg end))
           (chars (abs (- beg end)))
           (l (propertize "l" 'face 'compilation-info))
           (w (propertize "w" 'face 'compilation-warning))
           (c (propertize "c" 'face 'compilation-error)))
      (propertize (format "%s:%s %s:%s %s:%s" l lines w words c chars)))))

(defun my/mode-line-position ()
  (let* ((ln "%2l")
         (col-tmpl "%2c")
         (cur-col (current-column))
         (col (if (>= cur-col fill-column)
                  (propertize col-tmpl 'face 'compilation-warning)
                col-tmpl)))
    (format "(%s,%s) " ln col)))

(defun my/mode-line-server ()
  (when server-mode
    (propertize " srv " 'face 'compilation-info)))

(defvar my/input-method-color-mappings
  '(("greek" . (:foreground "black" :background "DeepSkyBlue2"))
    ("TeX" . (:foreground "black" :background "MediumOrchid"))
    ("Agda" . (:foreground "black" :background "SpringGreen4"))))

(defun my/mode-line-input-method ()
  (let ((input-method current-input-method))
    (unless (null input-method)
      (let ((face (or (cdr (assoc input-method my/input-method-color-mappings))
                      '(:foreground "black" :background "red3"))))
        (concat " "
                (propertize input-method 'face face))))))

(defun my/mode-line-major-mode-extra ()
  (let ((func (intern (format "my/mode-line-extra-%s" major-mode))))
    (when (fboundp func)
      (funcall func))))

(setq global-mode-string (delete '(:eval (persp-mode-line)) global-mode-string))
(setcar mode-line-position "")

(setq-default
 mode-line-format
 '((:eval
    (my/split-mode-line-render
     ;; left
     (quote
      ("%e" " "
       ;; mode-line-mule-info
       mode-line-modified "  "
       mode-line-buffer-identification " "
       ;; mode-line-modes
       (:eval (string-remove-suffix "-mode" (format "%s" major-mode)))
       (:eval (my/mode-line-input-method))
       (:eval mode-line-process) " "
       (:eval (my/mode-line-major-mode-extra))
       (:eval (my/mode-line-window-info))
       (:eval (my/mode-line-flycheck)) " "
       (:eval (my/mode-line-region-info))
       ))
     ;; right
     (quote
      (
       (:eval (my/mode-line-vc))
       (:eval minor-mode-alist) " "
       (:eval (my/mode-line-server))
       (:eval (frame-parameter nil 'persp--modestring)) "  "
       (:eval (my/mode-line-venv))
       (:eval (my/mode-line-position))
       (:eval (my/mode-line-hud)) "  "
       ))
     ;; right if too narrow
     (quote
      ((:eval (my/mode-line-vc))
       (:eval (frame-parameter nil 'persp--modestring)) "  "
       (:eval (my/mode-line-position))
       (:eval (my/mode-line-hud)) "  "
       ))
     ;; right if super narrow
     (quote
      ((:eval (frame-parameter nil 'persp--modestring)) "  "
       (:eval (my/mode-line-position))
       (:eval (my/mode-line-hud)) "  "
       ))
     ))))

;; evil-mode-line-tag
;; mode-line-mule-info
;; mode-line-client
;; mode-line-remote
;; (vc-mode vc-mode)
;; mode-line-modes
;; mode-line-misc-info
;; (:eval minor-mode-alist)
;; (:eval (my/mode-line-venv))
#+END_SRC

** Powerline

#+BEGIN_SRC emacs-lisp :tangle no
;; local for now
(use-package powerline-default-evil-theme
  :commands (powerline-default-evil-theme)
  :config
  (add-to-list
   'powerline-default-evil-theme-state-faces
   '(hybrid . powerline-active0-evil-insert)))

(use-package powerline
  :ensure t
  :after flycheck
  :if is-gui
  :init
  (setq powerline-display-buffer-size nil)
  (setq powerline-display-mule-info nil)
  (setq flycheck-mode-line '(:eval (my/mode-line-flycheck)))
  (setq global-mode-string
        (append global-mode-string '((:eval (my/mode-line-venv)))))
  (setq global-mode-string
        (cons '(:eval (if (window-dedicated-p) "× " "")) global-mode-string))
  :config
  (powerline-default-evil-theme)
  ;; (powerline-default-theme)
  (diminish-undo 'flycheck-mode)
  (add-hook 'my/after-set-theme-hook 'powerline-reset)
  (add-hook 'my/after-set-font-hook 'powerline-reset)
  ;; Try this to see if it fixes powerline hiccups
  (defun powerline-selected-window-active ()
    "Return whether the current window is active."
    (my/current-window-active-p))
  )
#+END_SRC

* Setup
** Per-workstation setup

#+BEGIN_SRC emacs-lisp
(defvar my/after-init-hook nil "Hook called after initialization")
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; these have to be paths to projects that projectile recognizes (e.g. git)
(defvar my/start-up-projects '())

(defun my/open-start-up-projects ()
  (unless (null my/start-up-projects)
    (let ((projectile-switch-project-action 'projectile-dired))
      (dolist (proj my/start-up-projects)
        (projectile-persp-switch-project proj)))
    (persp-switch "main")))

(add-hook 'my/after-init-hook 'my/open-start-up-projects)

;; usage:
;; (add-to-list 'my/start-up-projects "/path/to/some/project")
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; https://nicolas.petton.fr/blog/per-computer-emacs-settings.html
(defvar my/hosts-dir (expand-file-name (expand-file-name "hosts/" user-emacs-directory)))
(defvar my/hostname (substring (shell-command-to-string "hostname") 0 -1))
(let* ((host-file (concat my/hosts-dir "init-" my/hostname ".el")))
  (load-file host-file))
#+END_SRC

** Performance

#+BEGIN_SRC emacs-lisp
;; stolen from doom
(defun my/defer-garbage-collection-h ()
  (setq gc-cons-threshold 100000000))

(defun my/restore-garbage-collection-h ()
  ;; Defer it so that commands launched immediately after will enjoy the
  ;; benefits.
  (run-at-time
   1 nil (lambda () (setq gc-cons-threshold 800000))))

(add-hook 'minibuffer-setup-hook #'my/defer-garbage-collection-h)
(add-hook 'minibuffer-exit-hook #'my/restore-garbage-collection-h)
#+END_SRC

** Global setup

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
;; (load custom-file 'noerror)

;; make underlines show under mode-line (cleaner)
(setq x-underline-at-descent-line t)

(my/set-theme)
(my/set-font)

(setq linum-format 'dynamic)

(setq default-input-method "greek")

(hybrid-mode)
(winner-mode)

(run-hooks 'my/after-init-hook)
#+END_SRC

** custom

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 ;; '(anzu-mode-line ((t (:inherit mode-line :foreground "magenta" :weight bold))))
 ;; '(anzu-mode-line-no-match ((t (:inherit mode-line :foreground "red" :weight bold))))
 '(fixed-pitch ((t nil)))
 ;; '(flycheck-info ((t (:underline (:color "DeepSkyBlue2" :style wave)))))
 ;; '(flycheck-fringe-info ((t (:foreground "DeepSkyBlue2"))))
 ;; '(flycheck-warning ((t (:underline (:color "orange1" :style wave)))))
 ;; '(flycheck-fringe-warning ((t (:foreground "orange1"))))
 ;; '(flycheck-error ((t (:underline (:color "red1" :style wave)))))
 ;; '(flycheck-fringe-error ((t (:foreground "#FB4933"))))
 ;; '(whitespace-trailing ((t (:background "#602020"))))
 )

(dolist (val '((eval . (setq flycheck-disabled-checkers
                             (append flycheck-disabled-checkers
                                     (quote
                                      (intero)))))
               (haskell-hoogle-command . "stack hoogle -- --count=100")
               (projectile-tags-command . "npm run etags")
               (projectile-tags-command . "fast-tags -e -R .")
               (projectile-tags-command . "fast-tags -e -R -o %s --exclude=\"%s\" \"%s\"")
               (psc-ide-output-directory . "build/")
               (my/use-intero . t)
               (my/haskell-align-stuff . nil)
               (my/haskell-use-ormolu . t)
               (my/purescript-align-stuff . nil)
               (org-download-image-dir . "~/Dropbox/emacs/org-roam/static/images")
               ))
  (add-to-list 'safe-local-variable-values val))
#+END_SRC

# end of configuration.org
