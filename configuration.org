* Variables and PATH
   
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (expand-file-name "~/.emacs.d/lisp"))
(add-to-list 'load-path (expand-file-name "~/.emacs.d/custom"))
(add-to-list 'custom-theme-load-path
             (expand-file-name "~/.emacs.d/custom-themes/"))

(setq my/path
      '(
        "/usr/local/bin"
        "~/bin"
        "~/.local/bin"
        ))

(dolist (pth my/path)
  (add-to-list 'exec-path (expand-file-name pth))
  (setenv "PATH" (concat (expand-file-name pth)
                         path-separator
                         (getenv "PATH"))))

(setq user-full-name "Alex Peitsinis"
      user-mail-address "alexpeitsinis@gmail.com"
      auth-sources '("~/.authinfo.gpg"))

(defvar is-mac (eq system-type 'darwin)
  "Whether emacs is running in mac or not")
#+END_SRC
   
* Various utility functions

#+BEGIN_SRC emacs-lisp
(defmacro comment (&rest body)
  "Comment out one or more s-expressions."
  nil)

(defmacro my/add-hooks (hooks &rest body)
  `(dolist (hook ,hooks)
     (add-hook hook (lambda () ,@body))))

(defmacro my/execute-f-with-hook (f winf)
  `(lambda (&rest args)
     (interactive)
     (,winf)
     (apply (quote ,f) args)))

(defmacro my/control-function-window-split (f height width)
  `(lambda (&rest args)
     (interactive)
     (let ((split-height-threshold ,height)
           (split-width-threshold ,width))
       (apply (quote ,f) args))))

;; what it says
(defun my/revert-all-buffers ()
  "Refresh all open file buffers without confirmation.
Buffers in modified (not yet saved) state in emacs will not be reverted. They
will be reverted though if they were modified outside emacs.
Buffers visiting files which do not exist any more or are no longer readable
will be killed."
  (interactive)
  (dolist (buf (buffer-list))
    (let ((filename (buffer-file-name buf)))
      ;; Revert only buffers containing files, which are not modified;
      ;; do not try to revert non-file buffers like *Messages*.
      (when (and filename
                 (not (buffer-modified-p buf)))
        (if (file-readable-p filename)
            ;; If the file exists and is readable, revert the buffer.
            (with-current-buffer buf
              (revert-buffer :ignore-auto :noconfirm :preserve-modes))
          ;; Otherwise, kill the buffer.
          (let (kill-buffer-query-functions) ; No query done when killing buffer
            (kill-buffer buf)
            (message "Killed non-existing/unreadable file buffer: %s" filename))))))
  (message "Finished reverting buffers containing unmodified files."))

;; read file as string
(defun my/read-file-contents (path)
  (with-temp-buffer
    (insert-file-contents (expand-file-name path))
    (buffer-string)))

;; read file lines into a list
(defun my/read-file-into-list (file-path)
  "Return a list of lines of a file at `file-path'."
  (with-temp-buffer
    (insert-file-contents file-path)
    (split-string (buffer-string) "\n" t)))

;; do `reg' when called, `alt' when called with C-u
(defmacro my/defun-with-alt (reg alt)
  `(lambda (u)
     (interactive "P")
     (if (null u)
         (,reg)
       (,alt))))

(defun my/create-scratch-buffer-with-mode (other-window)
  "Create a new scratch buffer and select major mode to use.

With a prefix argument, open the buffer using `switch-to-buffer-other-window'."
  (interactive "P")
  (let* ((mmode
          (completing-read "buffer mode: "
                           (apropos-internal "-mode$")
                           nil nil nil nil
                           (symbol-name initial-major-mode)))
         (buf (generate-new-buffer (concat "*scratch" "-" mmode "*")))
         (switch-func (if other-window 'switch-to-buffer-other-window 'switch-to-buffer)))
    (funcall switch-func buf)
    (funcall (intern mmode))
    (setq buffer-offer-save nil)))

;; Thanks Tikhon Jelvis
(defun my/file-name-at-point (add-to-kill-ring)
  "Prompts the user for a file path using the standard C-x C-f
interface and inserts it at point."
  (interactive "P")
  (let ((action (if add-to-kill-ring 'kill-new 'insert))
        (path (read-file-name "file path: ")))
    (apply action (list path))))
(global-set-key (kbd "C-c f") 'my/file-name-at-point)

;; https://www.reddit.com/r/emacs/comments/ac9gsf/question_emacs_way_of_using_windows/
(defun my/window-dedicated (&optional window)
  "Toggle the dedicated flag on a window."
  (interactive)
  (let* ((window (or window (selected-window)))
         (dedicated (not (window-dedicated-p window))))
    (when (called-interactively-p)
      (message (format "%s %sdedicated"
                       (buffer-name (window-buffer window))
                       (if dedicated "" "un"))))
    (set-window-dedicated-p window dedicated)
    dedicated))

(defun my/copy-file-path (include-line-number)
  "Copy current file path to the clipboard and show it in the minibuffer.

If projectile is enabled and the file belongs in a project, copy the path
relative to the project root. Otherwise, copy the path, abbreviating the user's
home directory.

With a prefix argument, append the current line, separating it from the file
path with a colon."
  (interactive "P")
  (let* ((file-name (buffer-file-name))
         (suffix
          (if include-line-number
              (concat ":"
                      (number-to-string (line-number-at-pos)))
            ""))
         (file-path
          (concat
           (if (and (featurep 'projectile) (projectile-project-p))
               (string-remove-prefix (projectile-project-root) file-name)
             (abbreviate-file-name file-name))
           suffix))
         (current-prefix-arg nil))
    (kill-new file-path)
    (message file-path)))

(defvar my/useful-files
  '(
    ;; haskell
    "package.yaml"
    "stack.yaml"
    "shell.nix"
    ".hlint.yaml"
    ;; docker
    "docker-compose.yml"
    "Dockerfile"
    ;; bazel
    "BUILD.bazel"
    ;; git
    "README.md"
    ;; emacs
    ".dir-locals.el"))

(defun my/try-open-dominating-file (file)
  "Search up the file path of current file a file named FILE, and open it if it
exists.

If FILE is not provided, prompt for the filename.
With a prefix argument, open using `find-file-other-window'."
  (interactive (list (completing-read "File name: "
                                      my/useful-files
                                      nil nil nil nil nil)))
  (let ((dir (locate-dominating-file (buffer-file-name) file))
        (find-file-func (if current-prefix-arg 'find-file-other-window 'find-file)))
    (if dir
        (funcall find-file-func (concat (file-name-as-directory dir) file))
      (message "No matching file not found"))))

(defun my/line-numbers (arg)
  (interactive "P")
  (if (< emacs-major-version 26)
      (call-interactively 'linum-mode)
    (if display-line-numbers
        (setq display-line-numbers nil)
      (if arg
          (setq display-line-numbers 'relative)
        (setq display-line-numbers t)))))
#+END_SRC

* Package management
   
#+BEGIN_SRC emacs-lisp
(require 'package)
(add-to-list 'package-archives
             '("melpa" . "https://melpa.org/packages/")
             '("MELPA Stable" . "https://stable.melpa.org/packages/"))
(when (< emacs-major-version 24)
  ;; For important compatibility libraries like cl-lib
  (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/")))

;; activate installed packages
(package-initialize)
(setq package-enable-at-startup nil)
(unless (package-installed-p 'use-package)
  (package-install 'use-package))

;; Can be used to debug slow packages
;; (setq use-package-minimum-reported-time 0.05
;;       use-package-verbose t)

(eval-when-compile
  (require 'use-package))

(use-package cl :ensure t)
(use-package diminish :ensure t)
#+END_SRC
   
* Various configurations
** TODO sort these
   
#+BEGIN_SRC emacs-lisp
;; remember last position
(if (<= emacs-major-version 24)
    (use-package saveplace
       :ensure t
       :config
       (setq-default save-place t))
  (save-place-mode 1))

(defun display-startup-echo-area-message ()
  (message (format "Emacs started in %s" (emacs-init-time))))

;; undo tree
(use-package undo-tree
  :ensure t
  :bind ("C-x u" . undo-tree-visualize)
  :diminish undo-tree-mode
  :config
  (setq undo-tree-visualizer-relative-timestamps t
        undo-tree-visualizer-diff t)
  (global-undo-tree-mode))

;; use column width 80 to fill (e.g. with gq)
(setq-default fill-column 79)
(defun my/set-mode-fill-width (mode-hook width)
  (add-hook mode-hook `(lambda () (setq fill-column ,width))))

(use-package autorevert :diminish auto-revert-mode)
(use-package eldoc :diminish eldoc-mode)

;; store all backup and autosave files in
;; one dir
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))

;; only with this set to nil can org-mode export & open too
(setq process-connection-type nil)

;; yesss
(defalias 'yes-or-no-p #'y-or-n-p)

;; Always confirm before closing because I'm stupid
(add-hook
 'kill-emacs-query-functions
 (lambda () (y-or-n-p "Do you really want to exit Emacs? "))
 'append)

;; use spaces
(setq-default indent-tabs-mode nil)

;; always scroll to the end of compilation buffers
(setq compilation-scroll-output t)

;; vim-like scrolling (emacs=0)
(setq scroll-conservatively 101)

;; smooth scrolling
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)) ;; one line at a time
      mouse-wheel-progressive-speed t ;; don't accelerate scrolling
      mouse-wheel-follow-mouse 't) ;; scroll window under mouse

;; turn off because it causes delays in some modes (e.g. coq-mode)
(setq smie-blink-matching-inners nil)
;; (setq blink-matching-paren nil)

;; who in their right mind ends sentences with 2 spaces?
(setq sentence-end-double-space nil)

;; some keymaps
(global-set-key (kbd "M-o") 'other-window)
;; I use that to switch to Greek layout
(global-set-key (kbd "M-SPC") nil)
;; used in help
(define-key 'help-command (kbd "C-l") 'find-library)
(define-key 'help-command (kbd "C-k") 'find-function-on-key)
(define-key 'help-command (kbd "C-f") 'find-function)
(define-key 'help-command (kbd "C-p") 'find-function-at-point)
(define-key 'help-command (kbd "C-v") 'find-variable)

;; flyspell on pure text buffers
;; (dolist (hook '(text-mode-hook change-log-mode-hook log-edit-mode-hook))
;;   (add-hook hook (lambda () (flyspell-mode 1))))

;; add env files to conf-mode alist
(add-to-list 'auto-mode-alist '(".env\\'" . conf-mode))
(add-to-list 'auto-mode-alist '(".env.local\\'" . conf-mode))
(add-to-list 'auto-mode-alist '("env\\.example\\'" . conf-mode))

;; DocView
(setq doc-view-continuous t)

(defun my/indent-region-or-buffer ()
  "Indent a region if selected, otherwise the whole buffer."
  (interactive)
  (save-excursion
    (if (region-active-p)
        (progn
          (indent-region (region-beginning) (region-end))
          (message "Indented selected region."))
      (progn
        (indent-region (point-min) (point-max))
        (message "Indented buffer.")))))

(use-package smartparens
  :ensure t
  :defer t
  :commands (sp-split-sexp sp-newline sp-up-sexp)
  :diminish smartparens-mode
  :init
  (defun my/smartparens-pair-newline (id action context)
    (save-excursion
      (newline)
      (indent-according-to-mode)))

  (defun my/smartparens-pair-newline-and-indent (id action context)
    (my/smartparens-pair-newline id action context)
    (indent-according-to-mode))

  (setq sp-show-pair-delay 0.2
        ;; fix paren highlighting in normal mode
        sp-show-pair-from-inside t
        sp-cancel-autoskip-on-backward-movement nil
        sp-highlight-pair-overlay nil
        sp-highlight-wrap-overlay nil
        sp-highlight-wrap-tag-overlay nil)

  (use-package evil-smartparens
    :ensure t
    :diminish evil-smartparens-mode)

  (my/add-hooks '(prog-mode-hook comint-mode-hook css-mode-hook) (smartparens-mode))
  (setq my/lisp-mode-hooks '(emacs-lisp-mode-hook clojure-mode-hook))
  (my/add-hooks my/lisp-mode-hooks (smartparens-strict-mode) (evil-smartparens-mode))
  (my/add-hooks '(prog-mode-hook coq-mode-hook comint-mode-hook css-mode-hook) (smartparens-mode))


  :config
  (require 'smartparens-config)
  (show-smartparens-global-mode +1)

  ;; don't create a pair with single quote in minibuffer
  (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)

  (sp-pair "(" nil :post-handlers
           '(:add (my/smartparens-pair-newline-and-indent "RET")))
  (sp-pair "{" nil :post-handlers
           '(:add (my/smartparens-pair-newline-and-indent "RET")))
  (sp-pair "[" nil :post-handlers
           '(:add (my/smartparens-pair-newline-and-indent "RET")))

  ;; keybindings
  (sp-use-paredit-bindings)
  (define-key smartparens-mode-map (kbd "C-M-k") 'sp-kill-sexp)
  (define-key smartparens-mode-map (kbd "C-M-w") 'sp-copy-sexp)
  (define-key smartparens-mode-map (kbd "M-j") nil)
  (define-key smartparens-mode-map (kbd "M-?") nil))

(use-package which-key
  :ensure t
  :diminish which-key-mode
  :config
  (which-key-mode))

(use-package imenu-list
  :ensure t
  :bind ("C-|" . my/imenu-list-smart-toggle)
  :config

  (defun my/imenu-list-jump-to-window ()
    "Jump to imenu-list window if visible, otherwise create it and jump."
    (interactive)
    (if (get-buffer-window imenu-list-buffer-name)
        (select-window (get-buffer-window imenu-list-buffer-name))
      (progn
        (imenu-list-minor-mode)
        (select-window (get-buffer-window imenu-list-buffer-name)))))

  (defun my/imenu-list-smart-toggle ()
    "If imenu-list window doesn't exist, create it and jump. If if does but
it is not the current buffer, jump there. If it exists and it's the current
buffer, close it."
    (interactive)
    (if (eq (current-buffer) (get-buffer imenu-list-buffer-name))
        (imenu-list-quit-window)
      (my/imenu-list-jump-to-window)))

  ;; (global-set-key (kbd "C-|") #'my/imenu-list-smart-toggle)
  (setq imenu-list-size 30))

(use-package zeal-at-point
  :unless is-mac
  :ensure t
  :bind ("C-c d" . zeal-at-point)
  :config
  (add-to-list 'zeal-at-point-mode-alist '(python-mode . ("python" "django")))
  (add-to-list 'zeal-at-point-mode-alist '(haskell-mode . "haskell"))
  (add-to-list 'zeal-at-point-mode-alist '(js2-mode . "react")))

(use-package dash-at-point
  :if is-mac
  :ensure t
  :bind ("C-c d" . dash-at-point))

(use-package expand-region
  :ensure t
  :bind (("C-=" . er/expand-region)
         ("C-M-=" . er/contract-region)))

(use-package misc
  :bind ("M-Z" . zap-up-to-char))

(use-package subword
  :diminish subword-mode
  :commands (subword-mode my/subword-mode)
  :config
  (defun my/subword-mode (&optional arg)
    (interactive)
    (let ((disable
           (lambda ()
             (progn
               (subword-mode -1)
               (setq evil-symbol-word-search nil)
               ;; (minibuffer-message "subword-mode disabled")
               (put 'my/subword-mode-enabled 'state nil))))
          (enable
           (lambda ()
             (progn
               (subword-mode 1)
               (setq evil-symbol-word-search t)
               ;; (minibuffer-message "subword-mode enabled")
               (put 'my/subword-mode-enabled 'state t)))))
      (if arg
          (if (<= arg 0)
              (funcall disable)
            (funcall enable))
        (if (get 'my/subword-mode-enabled 'state)
            (funcall disable)
          (funcall enable))))))
#+END_SRC

** Jumping etc
   
#+BEGIN_SRC emacs-lisp
(defun my/goto-line-show ()
  "Show line numbers temporarily, while prompting for the line number input."
  (interactive)
  (unwind-protect
      (progn
        (linum-mode 1)
        (call-interactively #'goto-line))
    (linum-mode -1)))

(global-set-key (kbd "M-g M-g") 'my/goto-line-show)

(defadvice find-file (around find-file-line-number
                             (filename &optional wildcards)
                             activate)
  "Turn files like file.txt:14 into file.txt and going to the 14-th line."
  (save-match-data
    (let* ((matched (string-match "^\\(.*\\):\\([0-9]+\\):?$" filename))
           (line-number (and matched
                             (match-string 2 filename)
                             (string-to-number (match-string 2 filename))))
           (filename (if matched (match-string 1 filename) filename)))
      ad-do-it
      (when line-number
        ;; goto-line is for interactive use
        (goto-char (point-min))
        (forward-line (1- line-number))))))

(define-key prog-mode-map (kbd "M-a") 'beginning-of-defun)
(define-key prog-mode-map (kbd "M-e") 'end-of-defun)
#+END_SRC

** Autocompleting etc

#+begin_src emacs-lisp
;; Don't consider punctuation part of word for completion,
;; helps complete qualified symbols
(add-hook
 'prog-mode-hook
 (lambda ()
   (setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_\\|\\sw\\s.")))

;; Don't autofill when pressing RET
(aset auto-fill-chars ?\n nil)
#+end_src

** engine-mode
   
#+BEGIN_SRC emacs-lisp
(use-package engine-mode
  :ensure t
  :bind-keymap ("C-x /" . engine-mode-map)
  :config
  (engine-mode t)

  (defengine github
    "https://github.com/search?ref=simplesearch&q=%s"
    :keybinding "c")

  (defengine google
    "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s"
    :keybinding "g")

  (defengine google-images
    "http://www.google.com/images?hl=en&source=hp&biw=1440&bih=795&gbv=2&aq=f&aqi=&aql=&oq=&q=%s"
    :keybinding "i")

  (defengine google-maps
    "http://maps.google.com/maps?q=%s")

  (defengine rfcs
    "http://pretty-rfc.herokuapp.com/search?q=%s"
    :keybinding "r")

  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
    :keybinding "w")

  (defengine wiktionary
    "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

  (defengine wolfram-alpha
    "http://www.wolframalpha.com/input/?i=%s"
    :keybinding "m")

  (defengine youtube
    "http://www.youtube.com/results?aq=f&oq=&search_query=%s"
    :keybinding "v")

  (defengine hoogle
    "https://hoogle.haskell.org/?hoogle=%s"
    :keybinding "h")

  (defengine haskell-language-extensions
    "https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-%s"
    :keybinding "#")
  )
#+END_SRC

** anzu

#+BEGIN_SRC emacs-lisp
(use-package anzu
  :ensure t
  :config
  (setq anzu-mode-lighter "")
  (global-anzu-mode +1))

(use-package evil-anzu
  :ensure t
  :after anzu
  :config
  (with-eval-after-load 'evil (require 'evil-anzu)))
#+END_SRC

** math input
   
# http://ergoemacs.org/emacs/xmsi-math-symbols-input.html
# https://github.com/roelvandijk/base-unicode-symbols/blob/master/Prelude/Unicode.hs

#+BEGIN_SRC emacs-lisp
(use-package xah-math-input
  :ensure t
  :diminish xah-math-input-mode
  :config
  (global-xah-math-input-mode 1)
  (define-key xah-math-input-keymap (kbd "S-SPC" ) nil)
  (define-key xah-math-input-keymap (kbd "S-C-SPC") 'xah-math-input-change-to-symbol)

  (puthash "::" "∷" xah-math-input-abrvs)
  (puthash "bottom" "⊥" xah-math-input-abrvs))
#+END_SRC

** recentf 

#+BEGIN_SRC emacs-lisp
(setq recentf-max-saved-items 100) (recentf-mode 1)
#+END_SRC

** hi-lock

   #+begin_src emacs-lisp
(setq hi-lock-face-defaults
      '(
        "hi-green"
        "hi-blue"
        "hi-pink"
        "hi-green-b"
        "hi-blue-b"
        "hi-yellow"
        "hi-red-b"
        ))

;; solarized
;; (setq hi-lock-face-defaults
;;       '(
;;         "hi-green-b"
;;         "hi-blue-b"
;;         "hi-red-b"
;;         "hi-yellow"
;;         "hi-pink"
;;         "hi-blue"
;;         "hi-green"
;;         ))

(setq hi-lock-auto-select-face t)
   #+end_src

** aliases

#+begin_src emacs-lisp
(defalias 'rb 'revert-buffer)
(defalias 'rab 'my/revert-all-buffers)
(defalias 'gb 'magit-blame-addition)
(defalias 'magb 'magit-blame-addition)
(defalias 'gl 'magit-log-buffer-file)
(defalias 'magl 'magit-log-buffer-file)
#+end_src

** clean unused buffers

#+begin_src emacs-lisp
(setq clean-buffer-list-delay-general 3)  ;; 3 days
(setq clean-buffer-list-kill-regexps '("\\`\\*Customize .*\\*\\'"))
(setq clean-buffer-list-never-regexps '("\\`TAGS\\'"))
#+end_src

** indent guides

#+begin_src emacs-lisp
(use-package highlight-indent-guides
  :ensure t
  :commands (highlight-indent-guides-mode)
  :init
  (setq highlight-indent-guides-method 'character)
  (setq highlight-indent-guides-responsive nil))
#+end_src

* Term, eshell and comint-mode
** Terms
  
#+BEGIN_SRC emacs-lisp
(add-hook 'term-mode-hook
          (lambda ()
            (linum-mode 0)
            (define-key term-raw-map (kbd "M-o") 'other-window)
            (set-face-background 'term (face-attribute 'default :background))))

;; automatically close term buffers on EOF
(defun my/term-exec-hook ()
  (let* ((buff (current-buffer))
         (proc (get-buffer-process buff)))
    (set-process-sentinel
     proc
     `(lambda (process event)
        (if (string= event "finished\n")
            (kill-buffer ,buff))))))

(add-hook 'term-exec-hook 'my/term-exec-hook)

;; comint
(setq comint-prompt-read-only t)

(defun my/comint-clear-buffer ()
  (interactive)
  (let ((comint-buffer-maximum-size 0))
    (comint-truncate-buffer)))

(add-hook 'comint-mode-hook
          (lambda ()
            (define-key comint-mode-map (kbd "C-l") 'my/comint-clear-buffer)))
#+END_SRC

** eshell

#+BEGIN_SRC emacs-lisp
(setq eshell-destroy-buffer-when-process-dies t)
(setq eshell-history-size 1024)
(setq eshell-prompt-regexp "^[^#$]* [#$] ")
(load "em-hist")           ; So the history vars are defined
(if (boundp 'eshell-save-history-on-exit)
    (setq eshell-save-history-on-exit t)) ; Don't ask, just save
(if (boundp 'eshell-ask-to-save-history)
    (setq eshell-ask-to-save-history 'always)) ; For older(?) version

(defun pwd-repl-home (pwd)
  (interactive)
  (let* ((home (expand-file-name (getenv "HOME")))
   (home-len (length home)))
    (if (and
   (>= (length pwd) home-len)
   (equal home (substring pwd 0 home-len)))
  (concat "~" (substring pwd home-len))
      pwd)))

(defun curr-dir-git-branch-string (pwd)
  "Returns current git branch as a string, or the empty string if
PWD is not in a git repo (or the git command is not found)."
  (interactive)
  (when (and (eshell-search-path "git")
             (locate-dominating-file pwd ".git"))
    (let ((git-output
           (shell-command-to-string
            (concat "cd "
                    pwd
                    " && git branch | grep '\\*' | sed -e 's/^\\* //'"))))
      (propertize (concat "["
              (if (> (length git-output) 0)
                  (substring git-output 0 -1)
                "(no branch)")
              "]") 'face 'font-lock-string-face)
      )))

(setq eshell-prompt-function
      (lambda ()
        (concat
         (propertize
          ((lambda (p-lst)
             (if (> (length p-lst) 3)
                 (concat
                  (mapconcat (lambda (elm) (if (zerop (length elm)) ""
                                             (substring elm 0 1)))
                             (butlast p-lst 3)
                             "/")
                  "/"
                  (mapconcat (lambda (elm) elm)
                             (last p-lst 3)
                             "/"))
               (mapconcat (lambda (elm) elm)
                          p-lst
                          "/")))
           (split-string (pwd-repl-home (eshell/pwd)) "/"))
          'face
          'font-lock-type-face)
         (or (curr-dir-git-branch-string (eshell/pwd)))
         (propertize " $" 'face 'font-lock-type-face)
         (propertize " " 'face 'default))))

(require 'em-smart)
(setq eshell-where-to-jump 'begin)
(setq eshell-review-quick-commands nil)
(setq eshell-smart-space-goes-to-end t)

(defun eshell/clear ()
  (interactive)
  "Clear the eshell buffer."
  (let ((inhibit-read-only t))
    (erase-buffer)
    (eshell-send-input)))

(add-hook 'eshell-mode-hook
          (lambda ()
            (define-key eshell-mode-map (kbd "C-l") 'eshell/clear)))
#+END_SRC

* UI

#+BEGIN_SRC emacs-lisp
;; highlight numbers
(use-package highlight-numbers
  :ensure t
  :config
  (my/add-hooks '(prog-mode-hook css-mode-hook) (highlight-numbers-mode)))

;; show column in modeline
(setq column-number-mode t)

;; disable annoying stuff
(setq ring-bell-function 'ignore
      inhibit-startup-message t
      inhibit-splash-screen t
      initial-scratch-message nil)
(menu-bar-mode -1)
(scroll-bar-mode -1)
(tool-bar-mode -1)

;; linum
(setq linum-format 'dynamic)

;; hl-line
(setq hl-line-sticky-flag nil)
(defvar my/hl-line-contrast 5)
(defun my/hl-line-set-bg (&optional light-bg th)
  (let* ((func (if light-bg 'color-darken-name 'color-lighten-name))
         (bg (face-attribute 'default :background))
         (theme (if th th my/theme)))
    (custom-theme-set-faces
     theme
     `(hl-line ((t (:background ,(funcall func bg my/hl-line-contrast))))))))
;; (add-hook 'prog-mode-hook 'hl-line-mode)

(use-package fill-column-indicator
  :if (>= emacs-major-version 25)
  :ensure t
  :commands (fci-mode)
  :init
  (setq fci-handle-truncate-lines t)
  (setq
   fci-mode-hooks
   '(python-mode-hook
     markdown-mode-hook))
  (defvar my/fci-contrast 10)
  (defun my/set-fci-rule-color ()
    (setq fci-rule-color
          (let ((fci-face (face-attribute 'my/fci :foreground))
                (bg-color (face-attribute 'default :background)))
            (if (eq fci-face 'unspecified)
                (if my/theme-light-bg
                    (color-darken-name bg-color my/fci-contrast)
                  (color-lighten-name bg-color my/fci-contrast))
              fci-face))))
  (add-hook 'fci-mode-hook #'my/set-fci-rule-color)
  (my/add-hooks
   fci-mode-hooks
   (my/set-fci-rule-color) (fci-mode)))

#+END_SRC

** highlight trailing whitespace
   
#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :ensure t
  :diminish whitespace-mode
  :diminish global-whitespace-mode
  :config
  (setq whitespace-line-column 79
        whitespace-style '(face trailing))
  (add-hook 'prog-mode-hook #'whitespace-mode))
#+END_SRC

* Theme

#+BEGIN_SRC emacs-lisp
(defun my/after-set-theme (&optional light-bg)
  (setq my/theme-light-bg (if light-bg t nil))
  (my/diff-hl-set-fringe-faces light-bg)
  (my/hl-line-set-bg light-bg)
  (my/org-set-src-faces light-bg))

(defface my/fci '((t ())) "fci rule face")
(setq nord-comment-brightness 8)

;; I am trying a lot of themes dammit
(setq my/all-themes
      '(
        (wombat
         (progn
           (custom-theme-set-faces
            'wombat
            '(default ((t (:foreground "#d1d1d1" :background "#1a1a1a"))))
            '(font-lock-comment-face ((t (:foreground "#828987"))))
            '(font-lock-string-face ((t (:foreground "#2a96d3"))))
            '(font-lock-doc-face ((t (:foreground "#348dc1"))))
            '(region ((t (:background "#515151"))))
            '(highlight ((t (:background "#3a3a3a"))))
            '(cursor ((t (:background "#d8d8d8"))))
            '(fringe ((t (:background "#2e2e2e"))))
            '(isearch ((t (:foreground "#242424" :background "#e5786d"))))
            '(vertical-border ((t (:foreground "#b0b0b0"))))
            '(show-paren-match ((t (:background "steelblue4" :weight bold))))
            '(mode-line-buffer-id ((t (:weight bold))))
            '(persp-selected-face ((t (:inherit font-lock-string-face :weight bold))))
            '(treemacs-fringe-indicator-face ((t (:foreground "#8ac6f2"))))
            '(mode-line
              ((t (:background "#454545" :foreground "#d1d1d1" :box (:line-width 1 :color "#4a4a4a")))))
            '(mode-line-inactive
              ((t (:inherit mode-line :background "#282828" :foreground "#858585"))))
            '(outline-2 ((t (:foreground "#8ac6f2" :weight bold))))
            '(outline-3 ((t (:foreground "#ccaa8f" :weight bold))))
            ;; '(haskell-operator-face ((t (:foreground "#e5786d"))))
            )
           (my/after-set-theme)
           ))
        (gruvbox-dark-hard
         (progn
           (custom-theme-set-faces
            'gruvbox-dark-hard
            '(default ((t (:background "#1d2021" :foreground "#e5dfb0"))))
            '(fringe ((t (:background "#282b2c"))))
            '(highlight ((t (:background "#47423e"))))
            '(haskell-constructor-face ((t (:inherit font-lock-variable-name-face))))
            '(purescript-constructor-face ((t (:inherit haskell-constructor-face))))
            '(linum ((t (:background "#202324" :foreground "#6c5f54"))))
            '(line-number ((t (:background "#202324" :foreground "#6c5f54"))))
            '(line-number-current-line ((t (:background "#383b3c" :foreground "#fe8019"))))
            '(powerline-active0 ((t (:background "#70655d" :foreground "#fdf4c1"))))
            '(powerline-active1 ((t (:background "#595048" :foreground "#fdf4c1"))))
            '(powerline-active2 ((t (:background "#423b38" :foreground "#fdf4c1"))))
            '(powerline-inactive0 ((t (:background "#454140" :foreground "#a89984"))))
            '(powerline-inactive1 ((t (:background "#353130" :foreground "#a89984"))))
            '(powerline-inactive2 ((t (:background "#353130" :foreground "#a89984"))))
            )
           (my/org-set-src-faces)
           ))
        (darktooth
         (progn
           (custom-theme-set-faces
            'darktooth
            '(fringe ((t (:background "#313131"))))
            '(default ((t (:foreground "#ddd7b4" :background "#262626"))))
            '(persp-selected-face ((t (:foreground "#8ec07c" :weight bold))))
            ;; '(font-lock-function-name-face ((t (:foreground "#74b8bc"))))
            '(font-lock-preprocessor-face ((t (:foreground "#d787af"))))
            '(font-lock-keyword-face ((t (:foreground "#dd6f48" :weight bold))))
            '(purescript-constructor-face ((t (:inherit haskell-constructor-face))))
            '(mode-line ((t (:box nil :foreground "#e5dfbc" :background "#4d4845"))))
            '(mode-line-inactive ((t (:box nil :foreground "#968a79" :background "#33302d"))))
            '(vertical-border ((t (:foreground "#a89984"))))
            '(markdown-pre-face ((t (:foreground "#8ec07c"))))
            '(anzu-mode-line ((t (:foreground "magenta" :weight bold))))
            '(anzu-mode-line-no-match ((t (:foreground "red" :weight bold))))
            '(powerline-active0 ((t (:background "#696461" :foreground "#e5dfbc"))))
            '(powerline-active1 ((t (:background "#55504d" :foreground "#e5dfbc"))))
            '(powerline-active2 ((t (:background "#433f3e" :foreground "#e5dfbc"))))
            '(powerline-inactive0 ((t (:background "#393532" :foreground "#908473"))))
            '(powerline-inactive1 ((t (:background "#393532" :foreground "#908473"))))
            '(powerline-inactive2 ((t (:background "#393532" :foreground "#908473"))))
            )
           (my/after-set-theme)
           (setq pdf-view-midnight-colors '("#ddd7b4" . "#3d3d3d"))
           ))
        (gotham
         (progn
           (custom-theme-set-faces
            'gotham
            '(default ((t (:background "#11151b" :foreground "#99d1ce"))))
            '(fringe ((t (:background "#192128"))))
            '(persp-selected-face ((t (:foreground "#39b6dd" :weight bold :underline t))))
            '(font-lock-keyword-face ((t (:foreground "#2884a2" :weight bold))))
            '(font-lock-comment-face ((t (:foreground "#366773"))))
            '(font-lock-comment-delimiter-face ((t (:inherit font-lock-comment-face))))
            ;; '(haskell-constructor-face ((t (:foreground "#599cab"))))
            '(haskell-constructor-face ((t (:foreground "#9094b2"))))
            '(purescript-constructor-face ((t (:inherit haskell-constructor-face))))
            '(outline-1 ((t (:foreground "#2aa889"))))
            '(shadow ((t (:foreground "#599cab"))))
            '(avy-lead-face-0 ((t (:foreground "#99d1ce" :background "#245361"))))
            '(treemacs-fringe-indicator-face ((t (:foreground "#2aa889"))))
            '(isearch ((t (:inverse-video nil :foreground "black" :background "#d26937"))))
            '(lazy-highlight ((t (:foreground "black" :background "#2a6e83"))))
            '(ivy-current-match ((t (:background "#134a60"))))
            '(mode-line ((t (:box nil :foreground "#89c9d7" :background "#233a49"))))
            '(mode-line-inactive ((t (:box nil :foreground "#245361" :background "#19232d"))))
            '(hi-green ((t (:foreground "#191f28" :background "#2aa889"))))
            '(hi-green-b ((t (:foreground "#2aa889" :weight bold))))
            '(hi-blue ((t (:foreground "#191f28" :background "#599cab"))))
            '(hi-blue-b ((t (:foreground "#599cab" :weight bold))))
            '(hi-yellow ((t (:foreground "#191f28" :background "#edb443"))))
            '(hi-pink ((t (:foreground "#191f28" :background "#d26937"))))
            '(hi-red-b ((t (:foreground "#d26937" :weight bold))))
            )
           (my/after-set-theme)
           ))
        (nord
         (progn
           (custom-theme-set-faces
            'nord
            '(default ((t (:background "#191f28" :foreground "#b6c1d3"))))
            '(mode-line ((t (:background "#3f4758" :foreground "#9ac9d7"))))
            '(mode-line-inactive ((t (:background "#292e39" :foreground "#5e7591"))))
            '(font-lock-doc-face ((t (:foreground "#97aa86"))))
            '(font-lock-preprocessor-face ((t (:foreground "#B48EAD" :weight bold))))
            '(font-lock-variable-name-face ((t (:inherit default))))
            '(persp-selected-face ((t (:inherit font-lock-string-face :weight bold))))
            '(fringe ((t (:background "#1d242d"))))
            '(linum ((t (:foreground "#3f4758"))))
            '(show-paren-match ((t (:background "#477099" :weight bold))))
            '(treemacs-fringe-indicator-face ((t (:foreground "#8FBCBB"))))
            '(lazy-highlight ((t (:background "#496665"))))
            '(outline-2 ((t (:foreground "#8FBCBB" :weight bold))))
            '(org-level-2 ((t (:inherit outline-2))))
            '(outline-3 ((t (:foreground "#a3be8c" :weight bold))))
            '(org-level-3 ((t (:inherit outline-3))))
            )
           (my/after-set-theme)
           ))
        (zenburn
         (progn
           (custom-theme-set-faces
            'zenburn
            '(region ((t (:background "#5a5a5a"))))
            '(vertical-border ((t (:foreground "#b5b5b5"))))
            '(fringe ((t (:background "#4a4a4a"))))
            )
           (my/hl-line-set-bg) (my/org-set-src-faces)
           (setq pdf-view-midnight-colors '("#dcdccc" . "#383838"))
           ))
        ))

(defvar my/avail-themes '(wombat))
(defvar my/current-theme 0)
(defvar my/theme 'wombat)
(defvar my/theme-light-bg nil)

(defvar my/after-set-theme-hook nil
  "Hook called after setting a theme")

(defun my/set-theme (&optional theme-config light-bg)
  (let* ((theme-config (if (null theme-config)
                           (elt my/avail-themes my/current-theme)
                         theme-config))
         (theme (if (listp theme-config)
                    (car theme-config)
                  theme-config))
         (config (if (listp theme-config) (cadr theme-config) nil))
         (light-bg (if (listp theme-config)
                       (caddr theme-config)
                     light-bg)))
    (mapc 'disable-theme custom-enabled-themes)
    (load-theme theme t)
    (setq my/theme theme)
    (setq my/theme-light-bg light-bg)
    (setq pdf-view-midnight-colors '("#b3dfdd" . "#0a3749"))
    (eval config)
    (run-hooks 'my/after-set-theme-hook)))

(defun my/toggle-theme ()
  (interactive)
  (let* ((next-theme (mod (1+ my/current-theme) (length my/avail-themes)))
         (theme (elt my/avail-themes next-theme)))
    (setq my/current-theme next-theme)
    (my/set-theme)))

(defun my/refresh-theme ()
  (interactive)
  (my/set-theme)
  (setq linum-format 'dynamic))
#+END_SRC
   
* Font

#+BEGIN_SRC emacs-lisp
;; can set avail-fonts in ~/.emacs.d/hosts in the corresponding host file
(defvar my/avail-fonts '("Monospace-12"))
(defvar my/current-font 0)

(defun my/set-font (&optional font)
  (let ((font (if (null font) (elt my/avail-fonts my/current-font) font)))
    (if (listp font)
        (progn
          (set-frame-font (car font))
          (setq-default line-spacing (cdr font)))
      (progn
        (set-frame-font font)
        (setq-default line-spacing 0)))))

(defun my/toggle-font ()
  (interactive)
  (let ((next-font (mod (1+ my/current-font) (length my/avail-fonts))))
    (my/set-font (elt my/avail-fonts next-font))
    (setq my/current-font next-font)))

(defun my/refresh-font ()
  (interactive)
  (my/set-font (elt my/avail-fonts my/current-font)))

;; size & scaling
(setq text-scale-mode-step 1.05)
(define-key global-map (kbd "C-+") 'text-scale-increase)
(define-key global-map (kbd "C--") 'text-scale-decrease)
#+END_SRC

* VCS
** Magit
   
#+BEGIN_SRC emacs-lisp
(defun my/magit-set-diff-faces ()
  (custom-theme-set-faces
   my/theme
   '(magit-diff-added-highlight ((t (:background "#3f5f3f" :foreground "#afd8af"))))
   '(magit-diff-removed-highlight ((t (:background "#7c4343" :foreground "#ecb3b3"))))
   '(magit-diff-added ((t (:background "#2f4f2f" :foreground "#9fc59f"))))
   '(magit-diff-removed ((t (:background "#6c3333" :foreground "#dca3a3"))))
   ))

(use-package magit-todos
  :ensure t
  :after magit)

(use-package magit
  :ensure t
  :bind (("C-x g" . magit-status)
         ("C-x M-g" . magit-dispatch-popup))
  :config
  (magit-todos-mode)
  (add-hook 'magit-blame-mode-hook
            (lambda ()
              (if (or (not (boundp 'magit-blame-mode))
                      magit-blame-mode)
                  (evil-emacs-state)
                (evil-exit-emacs-state)))))
#+END_SRC

** Diff-hl

#+BEGIN_SRC emacs-lisp
(defun my/diff-hl-set-fringe-faces (&optional light-bg th)
  (let* ((dark (not light-bg))
         (ins-bg (if dark "#143514" "#b9e0b3"))
         (ins-fg (if dark "#2b872b" "#194219"))
         (ch-bg (if dark "#122544" "#b5d8f4"))
         (ch-fg (if dark "#4171c1" "#2b4775"))
         (del-bg (if dark "#491111" "#f4b5b5"))
         (del-fg (if dark "#bc4d4d" "#561a1a"))
         (theme (if th th my/theme)))
    (custom-theme-set-faces
     theme
     `(diff-hl-insert ((t (:background ,ins-bg :foreground ,ins-fg))))
     `(diff-hl-change ((t (:background ,ch-bg :foreground ,ch-fg))))
     `(diff-hl-delete ((t (:background ,del-bg :foreground ,del-fg)))))))

(if (display-graphic-p)
    (use-package diff-hl
      :ensure t
      :config
      (global-diff-hl-mode)
      (add-hook 'dired-mode-hook 'diff-hl-dired-mode)
      ;; (diff-hl-flydiff-mode)
      )
  (use-package git-gutter+
    :ensure t
    :config
    (global-git-gutter+-mode)))

#+END_SRC

** Helpers
   
#+BEGIN_SRC emacs-lisp
(defun my/git-blame-current-line ()
  "Runs `git blame` on the current line and
   adds the commit id to the kill ring"
  (interactive)
  (let* ((line-number (save-excursion
                        (goto-char (point-at-bol))
                        (+ 1 (count-lines 1 (point)))))
         (line-arg (format "%d,%d" line-number line-number))
         (commit-buf (generate-new-buffer "*git-blame-line-commit*")))
    (call-process "git" nil commit-buf nil
                  "blame" (buffer-file-name) "-L" line-arg)
    (let* ((commit-id (with-current-buffer commit-buf
                        (buffer-substring 1 9)))
           (log-buf (generate-new-buffer "*git-blame-line-log*")))
      (kill-new commit-id)
      (call-process "git" nil log-buf nil
                    "log" "-1" "--pretty=%h   %an   %s" commit-id)
      (with-current-buffer log-buf
        (message "Line %d: %s"
                 line-number
                 (replace-regexp-in-string "\n\\'" "" (buffer-string))))
      (kill-buffer log-buf))
    (kill-buffer commit-buf)))
#+END_SRC

** Keys

#+BEGIN_SRC emacs-lisp
(define-prefix-command 'my/git-map)
(global-set-key (kbd "C-c g") 'my/git-map)

(define-key my/git-map (kbd "g") 'magit-status)
(define-key my/git-map (kbd "b") 'magit-blame)
(define-key my/git-map (kbd "l") 'my/git-blame-current-line)
#+END_SRC

* Evil-mode
** keybind to command mapping

#+BEGIN_SRC emacs-lisp
(setq my/leader-keys
  '(
    ("SPC" fci-mode)

    ("a" align-regexp)

    ("bs" my/create-scratch-buffer-with-mode)

    ("el" my/toggle-flycheck-error-list)

    ("fa" helm-ag)
    ("ff" helm-find)
    ("fp" my/try-open-dominating-file)
    ("fc" my/copy-file-path)

    ("gb" my/git-blame-current-line)

    ("h"  help)

    ("if" my/file-name-at-point)
    ("iu" counsel-unicode-char)

    ("ps" counsel-projectile-ag)
    ("pt" my/counsel-ag-todos-global)

    ("sd" pwd)

    ("t8" fci-mode)
    ("tc" global-company-mode)
    ("tf" my/toggle-font)
    ("tg" global-diff-hl-mode)
    ("tl" my/line-numbers)
    ("to" global-symbol-overlay-mode)
    ("ti" highlight-indent-guides-mode)
    ("th" hl-line-mode)
    ("ts" flycheck-mode)
    ("tt" my/toggle-theme)
    ("tw" toggle-truncate-lines)

    ("uh" rainbow-mode)
    ("um" (lambda () (interactive) (call-interactively 'tool-bar-mode) (call-interactively 'menu-bar-mode)))
    ("up" rainbow-delimiters-mode)

    ("Ts" counsel-load-theme)

    ("Q" evil-local-mode)
    ))
#+END_SRC

** evil-mode setup
   
#+BEGIN_SRC emacs-lisp
(use-package evil-leader
  :ensure t
  :config
  (global-evil-leader-mode)
  (evil-leader/set-leader "<SPC>")
  (dolist (i my/leader-keys)
    (let ((k (car i))
          (f (cadr i)))
      (evil-leader/set-key k f))))

(use-package evil
  :ensure t
  :init (defvar my/use-evil-mode t)
  :config
  (setq evil-want-C-i-jump nil)
  ;; (setq evil-move-cursor-back nil)  ;; works better with lisp navigation
  (my/add-hooks
   '(
     prog-mode-hook
     text-mode-hook
     haskell-cabal-mode-hook
     coq-mode-hook easycrypt-mode-hook phox-mode-hook
     conf-unix-mode-hook
     conf-colon-mode-hook
     conf-space-mode-hook
     conf-windows-mode-hook
     toml-mode-hook
     )
   (if my/use-evil-mode (evil-local-mode)))

  (defun my/make-emacs-mode (mode)
    "Make `mode' use emacs keybindings."
    (delete mode evil-insert-state-modes)
    (add-to-list 'evil-emacs-state-modes mode))

  ;; don't need C-n, C-p
  (define-key evil-insert-state-map (kbd "C-n") nil)
  (define-key evil-insert-state-map (kbd "C-p") nil)

  ;; magit
  (evil-define-key 'normal magit-blame-mode-map (kbd "q") 'magit-blame-quit)

  ;; intercept ESC when running in terminal
  (setq evil-intercept-esc t)
  (evil-esc-mode)

  ;; move state to beginning of modeline
  (setq evil-mode-line-format '(before . mode-line-front-space))
  ;; (setq evil-mode-line-format 'nil)

  ;; move search result to center of the screen
  (defadvice evil-search-next
      (after advice-for-evil-search-next activate)
    (evil-scroll-line-to-center (line-number-at-pos)))

  (defadvice evil-search-previous
      (after advice-for-evil-search-previous activate)
    (evil-scroll-line-to-center (line-number-at-pos)))

  ;; this is needed to be able to use C-h
  (global-set-key (kbd "C-h") 'help)
  (define-key evil-normal-state-map (kbd "C-h") 'undefined)
  (define-key evil-insert-state-map (kbd "C-h") 'undefined)
  (define-key evil-visual-state-map (kbd "C-h") 'undefined)

  (define-key evil-emacs-state-map (kbd "C-h") 'help)
  (define-key evil-insert-state-map (kbd "C-k") nil)

  (define-key evil-normal-state-map (kbd "M-.") nil)

  (define-key evil-normal-state-map (kbd "C-h") 'evil-window-left)
  (define-key evil-normal-state-map (kbd "C-j") 'evil-window-down)
  (define-key evil-normal-state-map (kbd "C-k") 'evil-window-up)
  (define-key evil-normal-state-map (kbd "C-l") 'evil-window-right)

  (define-key evil-normal-state-map (kbd ";") 'evil-ex)
  (define-key evil-visual-state-map (kbd ";") 'evil-ex)
  (evil-ex-define-cmd "sv" 'split-window-below)

  (define-key evil-normal-state-map (kbd "C-p") 'counsel-projectile-find-file)

  (define-key evil-insert-state-map (kbd "C-M-i") 'company-complete)

  (define-key evil-visual-state-map (kbd "<") #'(lambda ()
                 (interactive)
                 (progn
                     (call-interactively 'evil-shift-left)
                     (execute-kbd-macro "gv"))))

  (define-key evil-visual-state-map (kbd ">") #'(lambda ()
                 (interactive)
                 (progn
                     (call-interactively 'evil-shift-right)
                     (execute-kbd-macro "gv"))))

  ;; redefine so that $ doesn't include the EOL char
  (evil-define-motion evil-end-of-line (count)
    "Move the cursor to the end of the current line.

If COUNT is given, move COUNT - 1 lines downward first."
    :type inclusive
    (move-end-of-line count)
    (when evil-track-eol
      (setq temporary-goal-column most-positive-fixnum
            this-command 'next-line))
    (unless (and (evil-visual-state-p) my/evil-$-include-eol)
      (evil-adjust-cursor)
      (when (eolp)
        ;; prevent "c$" and "d$" from deleting blank lines
        (setq evil-this-type 'exclusive))))

  (setq my/evil-$-include-eol nil)

  ;; https://github.com/emacs-evil/evil-surround/issues/141
  (defmacro my/evil-define-text-object (name key start-regex end-regex)
    (let ((inner-name (make-symbol (concat "evil-inner-" name)))
          (outer-name (make-symbol (concat "evil-a-" name))))
      `(progn
         (evil-define-text-object ,inner-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count nil))
         (evil-define-text-object ,outer-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count t))
         (define-key evil-inner-text-objects-map ,key #',inner-name)
         (define-key evil-outer-text-objects-map ,key #',outer-name))))

  ;; search with star while in v-mode
  (use-package evil-visualstar
    :ensure t
    :config
    (global-evil-visualstar-mode))
  )

#+END_SRC

** evil packages that can be used without evil-mode

#+BEGIN_SRC emacs-lisp
(use-package evil-nerd-commenter
  :ensure t
  :bind ("M-;" . evilnc-comment-or-uncomment-lines)
  :config
  ;; evilnc toggles instead of commenting/uncommenting
  (setq evilnc-invert-comment-line-by-line t))

(use-package evil-surround
  :ensure t
  :config
  (global-evil-surround-mode 1)
  (evil-define-key 'visual evil-surround-mode-map "s" 'evil-surround-region)
  (defconst my/mark-active-alist
  `((mark-active
      ,@(let ((m (make-sparse-keymap)))
          (define-key m (kbd "C-c s") 'evil-surround-region)
          m))))
  (add-to-list 'emulation-mode-map-alists 'my/mark-active-alist))
#+END_SRC

* Keybindings

  #+begin_src emacs-lisp
(define-prefix-command 'my/leader-map)

;; (define-key ctl-x-map "m" 'my/leader-map)
(define-prefix-command 'my/leader-map)
(global-set-key (kbd "C-c m") 'my/leader-map)

(dolist (i my/leader-keys)
  (let ((k (car i))
        (f (cadr i)))
    (define-key my/leader-map (kbd k) f)))

(define-prefix-command 'my/major-mode-map)

(if (display-graphic-p)
    (progn
      ;; distinguish `C-m` from `RET`
      (define-key input-decode-map [?\C-m] [C-m])
      ;; distinguish `C-i` from `TAB`
      ;; (define-key input-decode-map [?\C-i] [C-i])
      (global-set-key (kbd "C-c <C-m>") 'my/leader-map)
      (setq my/major-mode-map-key "<C-m>"))
  (setq my/major-mode-map-key "C-c m m"))

;; on hold
;; (defun my/define-major-mode-keys (hook &rest combinations)
;;   "Bind all pairs of (key . function) under `my/major-mode-map-key'
;;
;; The keys are bound after `hook'."
;;   (add-hook
;;    hook
;;    `(lambda ()
;;       (let ((map (make-sparse-keymap)))
;;         (local-set-key (kbd ,my/major-mode-map-key) map)
;;         (dolist (comb (quote ,combinations))
;;           (define-key map (kbd (car comb)) (cdr comb)))))))

(defun my/define-major-mode-key (mode key func)
  (let* ((map-symbol (intern (format "my/%s-map" mode)))
         (hook (intern (format "%s-hook" mode)))
         (map
          (if (boundp map-symbol)
              (symbol-value map-symbol)
            (progn
              (let ((map- (make-sparse-keymap)))
                (add-hook
                 hook
                 `(lambda ()
                    (local-set-key (kbd ,my/major-mode-map-key) (quote ,map-))))
                (set (intern (format "my/%s-map" mode)) map-))))))
    (define-key map (kbd key) func)))

(if (display-graphic-p)
    (progn
      (global-set-key (kbd "<C-m>") 'my/major-mode-map))
  (global-set-key (kbd "C-c m m") 'my/major-mode-map))
  #+end_src

* Keybindings (not used)
  
Treat hybrid mode and emacs keybindings the same way

#+BEGIN_SRC emacs-lisp :tangle no
(defun my/emacs-modes-keybind (key fun)
  (define-key global-map (kbd key) fun)
  (define-key evil-hybrid-state-map (kbd key) fun))

(define-prefix-command 'my/command-map)

(define-key ctl-x-map (kbd "C-;") 'my/command-map)

(define-key my/command-map (kbd "c") 'evil-surround-change)

(defun vi-open-line-above ()
  "Insert a newline above the current line and put point at beginning."
  (interactive)
  (unless (bolp)
    (beginning-of-line))
  (newline)
  (forward-line -1)
  (indent-according-to-mode))

(defun vi-open-line-below ()
  "Insert a newline below the current line and put point at beginning."
  (interactive)
  (unless (eolp)
    (end-of-line))
  (newline-and-indent))

(defun vi-open-line (&optional abovep)
  "Insert a newline below the current line and put point at beginning.
With a prefix argument, insert a newline above the current line."
  (interactive "P")
  (if abovep
      (vi-open-line-above)
    (vi-open-line-below)))
#+END_SRC

* Hybrid input mode
  
# Copied directly from spacemacs

#+BEGIN_SRC emacs-lisp
(defcustom hybrid-mode-default-state 'normal
  "Value of `evil-default-state' for hybrid-mode."
  :group 'my
  :type 'symbol)

(defcustom hybrid-mode-enable-evilified-state t
  "If non nil then evilified states is enabled in buffer supporting it."
  :group 'my
  :type 'boolean)

(defvar hybrid-mode-default-state-backup evil-default-state
  "Backup of `evil-default-state'.")

(defadvice evil-insert-state (around hybrid-insert-to-hybrid-state disable)
  "Forces Hybrid state."
  (evil-hybrid-state))

(defadvice evil-evilified-state (around hybrid-evilified-to-hybrid-state disable)
  "Forces Hybrid state."
  (if (equal -1 (ad-get-arg 0))
      ad-do-it
    (if hybrid-mode-enable-evilified-state
        ad-do-it
      ;; seems better to set the emacs state instead of hybrid for evilified
      ;; buffers
      (evil-emacs-state))))

;;;###autoload
(define-minor-mode hybrid-mode
  "Global minor mode to replace insert state by hybrid state."
  :global t
  :lighter ""
  :group 'my
  (if hybrid-mode
      (enable-hybrid-editing-style)
    (disable-hybrid-editing-style)))

(defun enable-hybrid-editing-style ()
  "Enable the hybrid editing style."
  (setq hybrid-mode-default-state-backup evil-default-state
        evil-default-state hybrid-mode-default-state)
  ;; replace evil states by `hybrid state'
  (ad-enable-advice 'evil-insert-state
                    'around 'hybrid-insert-to-hybrid-state)
  (ad-enable-advice 'evil-evilified-state
                    'around 'hybrid-evilified-to-hybrid-state)
  (ad-activate 'evil-insert-state)
  (ad-activate 'evil-evilified-state)
  ;; key bindings hooks for dynamic switching of editing styles
  (run-hook-with-args 'spacemacs-editing-style-hook 'hybrid)
  ;; initiate `hybrid state'
  )

(defun disable-hybrid-editing-style ()
  "Disable the hybrid editing style (reverting to 'vim style)."
  (setq evil-default-state hybrid-mode-default-state-backup)
  ;; restore evil states
  (ad-disable-advice 'evil-insert-state
                     'around 'hybrid-insert-to-hybrid-state)
  (ad-disable-advice 'evil-evilified-state
                     'around 'hybrid-evilified-to-hybrid-state)
  (ad-activate 'evil-insert-state)
  (ad-activate 'evil-evilified-state)
  ;; restore key bindings
  (run-hook-with-args 'spacemacs-editing-style-hook 'vim)
  ;; restore the states
  )

;; This code is from evil insert state definition, any change upstream
;; should be reflected here
;; see https://github.com/emacs-evil/evil/blob/56e92f7cb4e04e665670460093b41f58446b7a2b/evil-states.el#L108
(evil-define-state hybrid
  "Hybrid state for hybrid mode."
  :tag " <I> "
  :cursor (bar . 2)
  :message "-- HYBRID --"
  :entry-hook (evil-start-track-last-insertion)
  :exit-hook (evil-cleanup-insert-state evil-stop-track-last-insertion)
  :input-method t
  (cond
   ((evil-hybrid-state-p)
    (add-hook 'post-command-hook #'evil-maybe-remove-spaces)
    (add-hook 'pre-command-hook #'evil-insert-repeat-hook)
    (setq evil-maybe-remove-spaces t)
    (unless (eq evil-want-fine-undo t)
      (evil-start-undo-step)))
   (t
    (remove-hook 'post-command-hook #'evil-maybe-remove-spaces)
    (remove-hook 'pre-command-hook #'evil-insert-repeat-hook)
    (evil-maybe-remove-spaces t)
    (setq evil-insert-repeat-info evil-repeat-info)
    (evil-set-marker ?^ nil t)
    (unless (eq evil-want-fine-undo t)
      (evil-end-undo-step))
    (when evil-move-cursor-back
      (when (or (evil-normal-state-p evil-next-state)
                (evil-motion-state-p evil-next-state))
        (evil-move-cursor-back))))))

(define-key evil-hybrid-state-map [escape] 'evil-normal-state)

;; Override stock evil function `evil-insert-state-p'
(defun evil-insert-state-p (&optional state)
  "Whether the current state is insert."
  (and evil-local-mode
       (memq (or state evil-state) '(insert hybrid))))

(define-key evil-hybrid-state-map [escape] 'evil-normal-state)
(define-key evil-hybrid-state-map (kbd "C-w") 'evil-delete-backward-word)
#+END_SRC

* Haskell
  
#+BEGIN_SRC emacs-lisp
(use-package intero
  :ensure t
  :defer t
  :diminish intero-mode
  :init
  (setq intero-blacklist '("~/.xmonad"))
  :config
  ;; pretty print (use :pretty, :prettyl, :no-pretty in ghci)
  ;; this has to be installed in every repo until I find a solution
  ;; (setq intero-extra-ghci-options '("-package" "pretty-simple"))
  ;; don't auto insert matching single quotes in haskell mode, since I
  ;; mostly use them for promoted data types
  (define-key intero-mode-map (kbd "M-.") nil)
  (sp-local-pair 'intero-repl-mode "'" nil :actions nil)
  (flycheck-add-next-checker 'intero '(t . haskell-hlint)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq haskell-hoogle-command "hoogle --count=100")

(use-package haskell-mode
  :ensure t
  :config

  (font-lock-add-keywords
   'haskell-mode
   '(("\\<\\(error\\)\\>" 1 font-lock-preprocessor-face prepend)
     ("\\<\\(undefined\\)\\>" 1 font-lock-preprocessor-face prepend)))

  (my/define-major-mode-key 'haskell-mode "h" 'hoogle)
  (my/define-major-mode-key 'haskell-mode "i" 'haskell-navigate-imports)
  (my/define-major-mode-key 'haskell-mode "a" 'my/haskell-align-and-sort-imports)
  (my/define-major-mode-key 'haskell-mode "s" 'my/haskell-format-and-save)
  )
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/haskell-project-ghcid-output ()
  (interactive)
  (let ((ghcid-buf (my/projectile-get-ghcid-buffer)))
    (if ghcid-buf
        (minibuffer-message
         (with-current-buffer ghcid-buf
           (buffer-substring-no-properties (point-min) (point-max))))
      (minibuffer-message "No ghcid process running for this project"))))

(defun my/projectile-get-ghcid-buffer ()
  (let* ((proj-bufs (projectile-project-buffers))
         (ghcid-bufs (seq-filter
                      '(lambda (buf) (string-prefix-p "*ghcid" (buffer-name buf)))
                      proj-bufs)))
    (car ghcid-bufs)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/haskell-format-and-save ()
  "Formats the import statements using haskell-stylish and saves
the current file."
  (interactive)
  (save-buffer)
  (haskell-mode-stylish-buffer)
  (save-buffer))

(defun my/haskell-align-and-sort-imports ()
  (interactive)
  (call-interactively 'haskell-align-imports)
  (call-interactively 'haskell-sort-imports))

(defun my/haskell-open-package-yaml ()
  (interactive)
  (my/try-open-dominating-file "package.yaml"))

(with-eval-after-load 'haskell-mode
  (sp-local-pair 'haskell-mode "'" nil :actions nil))

(my/evil-define-text-object "haskell-inline-comment" "#" "{- " " -}")
(setq haskell-align-imports-pad-after-name t)
(add-hook 'haskell-mode-hook
          (lambda ()
            (setq evil-shift-width 2)
            (push '(?# . ("{- " . " -}")) evil-surround-pairs-alist)
            (intero-mode-blacklist)
            (haskell-decl-scan-mode)
            (my/subword-mode 1)
            ;; (add-hook 'after-save-hook 'my/haskell-project-ghcid-output nil 'make-it-local)
            ))
#+END_SRC
 
* Purescript

#+BEGIN_SRC emacs-lisp
(defun my/purescript-sort-and-align-imports ()
  (interactive)
  (save-excursion
    (while (purescript-navigate-imports)
      (progn
        (purescript-sort-imports)
        (purescript-align-imports)))
    (purescript-navigate-imports-return)))

(defun my/purescript-format-and-save ()
  "Formats the import statements using haskell-stylish and saves
the current file."
  (interactive)
  (my/purescript-sort-and-align-imports)
  (save-buffer))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package purescript-mode
  :ensure t
  :mode ("\\.purs\\'" . purescript-mode)
  :init
  (setq purescript-indent-offset 2
        purescript-align-imports-pad-after-name t)
  :config
  (my/define-major-mode-key 'purescript-mode "i" 'purescript-navigate-imports)
  (my/define-major-mode-key 'purescript-mode "s" 'my/purescript-format-and-save)
  (add-hook
   'purescript-mode-hook
   (lambda ()
     (setq evil-shift-width 2)
     (turn-on-purescript-indentation)
     (turn-on-purescript-decl-scan)
     ;; (turn-on-purescript-font-lock)
     (push '(?# . ("{- " . " -}")) evil-surround-pairs-alist)
     (my/subword-mode 1)
     (make-variable-buffer-local 'find-tag-default-function)
     (setq find-tag-default-function (lambda () (current-word t t)))
     ))
  ;; xref for purescript works a bit weird with qualified identifiers
  ;; (define-key purescript-mode-map (kbd "M-.")
    ;; #'(lambda () (interactive) (xref-find-definitions (current-word t t))))
  )

;; This needs to exist in custom/
(require 'custom-purescript-font-lock)
;; copy these into the purescript-mode definition
;; (setq-local font-lock-defaults
;;             '((purescript-font-lock-keywords)
;;               nil nil nil nil
;;               (font-lock-syntactic-face-function
;;                . purescript-syntactic-face-function)
;;               (parse-sexp-lookup-properties . t)
;;               (font-lock-extra-managed-props . (composition purescript-type))))
;; (setq-local font-lock-multiline t)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(use-package psc-ide
  :ensure t
  :after (purescript-mode)
  :init (setq my/use-psc-ide t)
  :config
  (add-hook
   'purescript-mode-hook
   (lambda () (if my/use-psc-ide (psc-ide-mode)))))
#+END_SRC

* Idris

#+BEGIN_SRC emacs-lisp
(use-package idris-mode
  :ensure t
  :mode ("\\.idr\\'" . idris-mode))
#+END_SRC

* Coq

#+BEGIN_SRC emacs-lisp
(use-package proof-general
  :ensure t
  :init
  (setq proof-splash-enable nil
        proof-script-fly-past-comments t)
  (setq coq-one-command-per-line nil
        coq-compile-before-require t)
  :config
  (add-hook 'coq-mode-hook
            (lambda ()
              (setq evil-shift-width 2)
              (undo-tree-mode 1)
              (whitespace-mode 1)
              )))
#+END_SRC

* Python
   
#+BEGIN_SRC emacs-lisp
(use-package pyvenv :after python) ;; this has to be downloaded

(defun eshell/workon (arg) (pyvenv-workon arg))
(defun eshell/deactivate () (pyvenv-deactivate))

(setq python-shell-prompt-detect-failure-warning nil)

(defun my/mode-line-venv ()
  (if (string= major-mode "python-mode")
      (let ((venv (if (null pyvenv-virtual-env-name)
                      "-"
                    pyvenv-virtual-env-name)))
        (concat
         "["
         (propertize venv 'face '(:underline t))
         "] "))
    ""))

(use-package anaconda-mode
  :ensure t
  :defer t
  :diminish anaconda-mode
  :diminish anaconda-eldoc-mode)

(add-hook 'python-mode-hook
          (lambda ()
            (anaconda-mode)
            (anaconda-eldoc-mode)
            (define-key python-mode-map (kbd "C-c C-j") 'counsel-imenu)
            (setq-default flycheck-disabled-checkers
                          (append flycheck-disabled-checkers
                                  '(python-pycompile)))))

#+END_SRC

* Javascript
   
#+BEGIN_SRC emacs-lisp
(use-package rjsx-mode
  :ensure t
  :mode (("\\.js\\'" . rjsx-mode)
         ("\\.jsx\\'" . rjsx-mode))
  :config
  (add-hook 'rjsx-mode-hook
    (lambda ()
      (setq evil-shift-width 2))))

(setq ;; js2-mode
 js-indent-level 2
 ;; web-mode
 css-indent-offset 2
 web-mode-markup-indent-offset 2
 web-mode-css-indent-offset 2
 web-mode-code-indent-offset 2
 web-mode-attr-indent-offset 2)
#+END_SRC

* Clojure
   
#+BEGIN_SRC emacs-lisp :tangle no
(use-package clojure-mode
  :ensure t
  :mode ("\\.clj\\'" . clojure-mode)
  :config
  (add-hook 'clojure-mode-hook 'eldoc-mode))

(use-package cider
  :ensure t
  :after clojure-mode
  :config
  (add-hook
   'cider-repl-mode-hook
   (lambda ()
     (eldoc-mode)
     (define-key cider-repl-mode-map (kbd "C-c C-l") 'cider-repl-clear-buffer))))
#+END_SRC

* Lisps
   
#+BEGIN_SRC emacs-lisp
;; expand macros in another window
(define-key
  lisp-mode-map
  (kbd "C-c C-m")
  #'(lambda () (interactive) (macrostep-expand t)))

(my/add-hooks
 '(lisp-mode-hook emacs-lisp-mode-hook lisp-interaction-mode-hook)
 (eldoc-mode))
#+END_SRC

* Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode)
         ("\\.page\\'" . gfm-mode))
  :config
  (my/set-mode-fill-width 'markdown-mode-hook 100)
  (my/add-hooks '(markdown-mode-hook)
                (auto-fill-mode 1))
  ;; (setq markdown-fontify-code-blocks-natively t)
  )
#+END_SRC

* Other programming languages
** C/C++

#+BEGIN_SRC emacs-lisp
(setq c-default-style "linux"
      c-basic-offset 4)
#+END_SRC

** HTML

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :mode ("\\.html\\'" . web-mode))

(use-package emmet-mode
  :ensure t
  :after web-mode
  :commands (emmet-mode)
  :init
  (add-hook 'web-mode-hook 'emmet-mode)
  (add-hook 'css-mode-hook 'emmet-mode))
#+END_SRC

** JSON, YAML etc.

#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :ensure t
  :mode (("\\.json\\'" . json-mode)
         ("\\.json.tmpl\\'" . json-mode)))

(use-package yaml-mode
  :ensure t
  :mode (("\\.yaml\\'" . yaml-mode)
         ("\\.yml\\'" . yaml-mode)))

(use-package flycheck-yamllint
  :ensure t
  :after flycheck yaml-mode
  :commands (flycheck-yamllint-setup)
  :init
  (add-hook 'yaml-mode-hook #'flycheck-yamllint-setup))
#+END_SRC

#+begin_src emacs-lisp
(defun my/jq-buffer-or-region ()
  (interactive)
  (save-excursion
    (unless (region-active-p)
      (mark-whole-buffer))
    (shell-command-on-region (region-beginning)
                             (region-end)
                             "jq ."
                             nil
                             t)))
#+end_src
    
** Elasticsearch

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '(".es\\'" . js-mode))
#+end_src

* Company
   
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :diminish company-mode
  :init
  (setq company-dabbrev-downcase nil
        company-minimum-prefix-length 3
        company-idle-delay 0.4)
  (add-hook 'after-init-hook 'global-company-mode)
  :config
  (use-package company-quickhelp :ensure t)
  (use-package company-anaconda :ensure t :defer t)
  (company-quickhelp-mode 1)
  (global-set-key (kbd "C-M-i") 'company-complete)
  (eval-after-load "company"
    '(progn
       (add-to-list 'company-backends 'company-anaconda)
       (add-to-list 'company-backends 'company-files)
       (setq company-backends (delete 'company-dabbrev company-backends))
       (define-key company-active-map (kbd "C-p") 'company-select-previous)
       (define-key company-active-map (kbd "C-n") 'company-select-next)
       (define-key company-active-map (kbd "TAB") 'company-complete-common-or-cycle)
       (define-key company-active-map (kbd "<tab>") 'company-complete-common-or-cycle)
       (define-key company-active-map (kbd "C-f") 'company-show-location))))
#+END_SRC

* Flycheck
   
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :diminish flycheck-mode
  :init (global-flycheck-mode)
  :config
  (add-hook 'after-init-hook #'global-flycheck-mode)
  (defun my/toggle-flycheck-error-list ()
    (interactive)
    (-if-let (window (flycheck-get-error-list-window))
        (quit-window nil window)
      (flycheck-list-errors)))

  ;; for defining syntax checkers
  (defun my/flycheck-buffer-relevant-errors (errors)
    "Filter out the irrelevant errors from ERRORS.

Return a list of all errors that are relevant for their
corresponding buffer."
    (seq-filter '(lambda (err) (not (flycheck-relevant-error-other-file-p err))) errors))

  (define-key global-map (kbd "C-c ! t") 'flycheck-mode)
  (add-to-list 'display-buffer-alist
               `(,(rx bos "*Flycheck errors*" eos)
                 (display-buffer-reuse-window
                  display-buffer-in-side-window)
                 (side            . bottom)
                 (reusable-frames . visible)
                 (window-height   . 0.33)))

  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(javascript-jshint haskell-ghc haskell-stack-ghc)))
  (flycheck-add-mode 'javascript-eslint 'web-mode)
  (flycheck-add-mode 'javascript-eslint 'js2-mode)
  (setq-default flycheck-temp-prefix ".flycheck")
  (setq-default flycheck-emacs-lisp-load-path 'inherit)
  (defun my/flycheck-always ()
    (interactive)
    (setq flycheck-check-syntax-automatically '(save idle-change new-line mode-enabled)))

  (defun my/flycheck-on-save ()
    (interactive)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; use as dir-local variable
(defvar my/flycheck-haskell-default-directory nil)

(defun my/flycheck-haskell-get-default-directory ()
  (or my/flycheck-haskell-default-directory
      (if (projectile-project-p)
          (projectile-project-root)
        (flycheck-haskell--find-default-directory 'haskell-stack-ghc))))

(defun my/flycheck-haskell-ghcid-file-exists ()
  (let ((dir (my/flycheck-haskell-get-default-directory)))
    (file-exists-p
     (concat (file-name-as-directory dir) ".ghcid-output"))))

(flycheck-define-checker haskell-ghcid
  "syntax checker using ghcid"
  :command ("flycheck-ghcid-check.sh" (eval (my/flycheck-haskell-get-default-directory)))
  :error-patterns
  ((warning line-start (file-name) ":" line ":"
            column (optional "-" (one-or-more digit))
            ":"
            (or " " "\n    ") (in "Ww") "arning:"
            (optional " " "[" (id (one-or-more not-newline)) "]")
            (optional "\n")
            (message
             (one-or-more " ") (one-or-more not-newline)
             (zero-or-more "\n"
                           (one-or-more " ")
                           (one-or-more (not (any ?\n ?|))))))
   (error line-start (file-name) ":" line ":"
          column (optional "-" (one-or-more digit))
          ": error:"
          (or (message (one-or-more not-newline))
              (and "\n"
                   (message
                    (one-or-more " ") (one-or-more not-newline)
                    (zero-or-more "\n"
                                  (one-or-more " ")
                                  (one-or-more (not (any ?\n ?|)))))))
          line-end))
  :error-filter
  (lambda (errors)
    (flycheck-sanitize-errors
     (flycheck-dedent-error-messages
      (my/flycheck-buffer-relevant-errors
       errors))))
  :modes haskell-mode
  :next-checkers ((warning . haskell-hlint))
  :predicate (lambda () (my/flycheck-haskell-ghcid-file-exists)))

(add-to-list 'flycheck-checkers 'haskell-ghcid)
#+END_SRC

* Projectile
  
#+BEGIN_SRC emacs-lisp
(use-package perspective
  :ensure t
  :config
  (persp-mode)
  ;; (global-set-key (kbd "M-O") 'persp-next)
  (global-set-key (kbd "M-N") 'persp-next)
  (global-set-key (kbd "M-P") 'persp-prev)
  ;; emacs window title
  (defadvice persp-switch
      (after advice-for-persp-switch activate)
    (message (persp-name (persp-curr))))
  (setq frame-title-format
        '("" invocation-name "@" system-name
          (:eval (when persp-mode (format "[%s]" (persp-name (persp-curr))))))))

(use-package persp-projectile
  :ensure t)
#+END_SRC
   
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :bind-keymap ("C-c p" . projectile-command-map)
  :diminish projectile-mode
  :config
  (setq projectile-completion-system 'ivy)
  (setq
   projectile-mode-line-function
   '(lambda () (format " P[%s]" (or (projectile-project-name) "-"))))
  (projectile-mode)
  (defun my/try-exec-in-project (in-proj-f out-proj-f &rest args)
    (if (projectile-project-p)
        (apply in-proj-f args)
      (apply out-proj-f args))))
#+END_SRC

* Searching
** ag

#+begin_src emacs-lisp
(use-package ag
  :ensure t
  :config
  (add-to-list 'ag-arguments "--nogroup")
  (add-to-list 'ag-arguments "--vimgrep")
  (add-to-list 'ag-dired-arguments "--vimgrep")
  (define-key
    ag-mode-map
    (kbd "Q")
    '(lambda () (interactive) (ag-kill-buffers) (delete-window))))
#+end_src

** winnow

#+begin_src emacs-lisp
(use-package winnow
  :ensure t
  :config
  (add-hook 'compilation-mode-hook 'winnow-mode))
#+end_src

* Ivy/Counsel/Swiper

#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  :ensure t
  :init
  (setq projectile-switch-project-action 'counsel-projectile-find-file)
  :config
  (define-key projectile-command-map (kbd "f") 'counsel-projectile-find-file)
  (define-key projectile-command-map (kbd "s") 'counsel-projectile-ag)
  (define-key projectile-command-map (kbd "b") 'counsel-projectile-switch-to-buffer))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/swiper (fuzzy)
  (interactive "P")
  (if (null fuzzy)
      (swiper)
    (let* ((temp-builders (copy-alist ivy-re-builders-alist))
           (ivy-re-builders-alist (add-to-list 'temp-builders
                                               '(swiper . ivy--regex-fuzzy))))
      (swiper))))

(defun my/insert-word-boundary-regexp ()
  (save-excursion
    (let* ((rx "[^a-zA-Z]")
           (start (if (region-active-p) (region-beginning) (point-min)))
           (end (+ (length rx) (if (region-active-p) (region-end) (point-max)))))
      (goto-char start)
      (insert rx)
      (goto-char end)
      (insert rx)
      (deactivate-mark))))

(use-package ivy-xref
  :config (setq xref-show-xrefs-function 'ivy-xref-show-xrefs))

(use-package swiper
  :ensure t
  :commands (swiper swiper-all swiper-multi)
  :bind ("C-s" . my/swiper))

(use-package ivy
  :ensure t
  :diminish ivy-mode
  :init
  (use-package counsel :ensure t)
  (use-package flx :ensure t)  ;; better fuzzy matching
  (use-package smex :ensure t :config (setq smex-history-length 12))
  ;; this has to exist e.g. in .emacs.d/lisp/
  :config
  (ivy-mode 1)
  (setq ivy-use-virtual-buffers nil)
  (setq enable-recursive-minibuffers t)
  (setq ivy-count-format "(%d/%d) ")

  (define-key ivy-minibuffer-map (kbd "C-l") 'ivy-call-and-recenter)

  (global-set-key (kbd "C-c r") 'ivy-resume)
  (global-set-key (kbd "M-x") 'counsel-M-x)
  (global-set-key (kbd "M-i") 'counsel-imenu)
  (global-set-key (kbd "C-x C-f") 'counsel-find-file)
  (global-set-key (kbd "C-x r b") 'counsel-bookmark)
  (global-set-key (kbd "C-x C-a") 'counsel-recentf)
  (global-set-key (kbd "C-x b") 'ivy-switch-buffer)

  (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)

  ;; counsel-ag
  (setq counsel-ag-base-command "ag --vimgrep --nocolor --nogroup %s")

  (defun my/counsel-ag-maybe-project-root ()
    (interactive)
    ;; if not in a project, (projectile-project-root) returns `nil' which is fine
    (let ((root-dir (read-file-name "Search in: " (projectile-project-root))))
      (counsel-ag "" root-dir)))

  (global-set-key (kbd "C-c s") 'my/counsel-ag-maybe-project-root)
  ;; S-SPC doesn't work properly in counsel-ag anyway
  (define-key counsel-ag-map (kbd "S-SPC") nil)

  (setq ivy-re-builders-alist
        '((swiper . ivy--regex-plus)
          (ivy-bibtex . ivy--regex-ignore-order)
          (counsel-unicode-char . ivy--regex-ignore-order)
          (insert-char . ivy--regex-ignore-order)
          (ucs-insert . ivy--regex-ignore-order)
          (counsel-unicode-char . ivy--regex-ignore-order)
          (counsel-ag . ivy--regex-plus)
          (t . ivy--regex-fuzzy)))
  (setq ivy-initial-inputs-alist nil)  ;; no ^ initially
  (setq ivy-magic-tilde nil)

  (defun my/ivy-yank-current-region-or-word (&optional qual)
    "Insert current region, if it's active, otherwise the current word,into
the minibuffer."
    (interactive "P")
    (let (text)
      (with-ivy-window
        (unwind-protect
            (setq text
                  (if (region-active-p)
                      (buffer-substring-no-properties (region-beginning) (region-end))
                    (current-word t (not qual))))))
      (when text (insert text))))
  (define-key ivy-minibuffer-map (kbd "M-j") 'my/ivy-yank-current-region-or-word)
  ;; TODO: something's up with rotation
  (define-key ivy-minibuffer-map (kbd "M-r") 'ivy-rotate-preferred-builders)

  ;; minibuffer actions for specific commands
  (dolist (action '(counsel-find-file counsel-recentf))
    (ivy-set-actions
     action
     `(("s"
        ,(my/control-function-window-split
          find-file-other-window
          0 nil)
        "split horizontally")
       ("v"
        ,(my/control-function-window-split
          find-file-other-window
          nil 0)
        "split vertically")
       ("n"
        ,(my/execute-f-with-hook
          find-file
          ace-select-window)
        "select window")
       )))

  (ivy-set-actions
   'ivy-switch-buffer
   `(("s"
      ,(my/control-function-window-split
        ivy--switch-buffer-other-window-action
        0 nil)
      "split horizontally")
     ("v"
      ,(my/control-function-window-split
        ivy--switch-buffer-other-window-action
        nil 0)
      "split vertically")
     ("n"
      ,(my/execute-f-with-hook
        (lambda (b) (switch-to-buffer b nil 'force-same-window))
        ace-select-window)
      "select window")
     ("k" kill-buffer "kill buffer")
     ))

  (dolist (action '(counsel-projectile-find-file projectile-recentf))
    (ivy-set-actions
     action
     `(("s"
        ,(my/control-function-window-split
          counsel-projectile-find-file-action-other-window
          0 nil)
        "split horizontally")
       ("v"
        ,(my/control-function-window-split
          counsel-projectile-find-file-action-other-window
          nil 0)
        "split vertically")
       ("n"
        ,(my/execute-f-with-hook
          counsel-projectile-find-file-action
          ace-select-window)
        "select window")
       ("R"
        (lambda (f) (projectile-recentf))
        "recent files")
       )))

  (ivy-set-actions
   'projectile-switch-project
   '(("d"
      dired
      "Open Dired in project's directory")
     ("v"
      projectile-vc
      "Open project root in vc-dir or magit")
     ("r"
      projectile-remove-known-project
      "Remove project(s)")))

  ;; also applies to counsel-projectile-ag
  (ivy-set-actions
   'counsel-ag
   '(("v"
      (lambda (x) (split-window-right) (windmove-right) (counsel-git-grep-action x))
      "split vertically")
     ("s"
      (lambda (x) (split-window-below) (windmove-down) (counsel-git-grep-action x))
      "split horizontally")
     ("n"
      (lambda (x) (ace-select-window) (counsel-git-grep-action x))
      "select window")))

  )

(defvar my/todo-search-string
  "TODO|NOTE|FIXME|XXX|DONE|HACK")

(defun my/counsel-projectile-ag-todos ()
  (interactive)
  (let ((counsel-projectile-ag-initial-input my/todo-search-string))
    (counsel-projectile-ag)))

(defun my/counsel-ag-todos-global ()
  (interactive)
  (my/try-exec-in-project 'my/counsel-projectile-ag-todos 'my/counsel-ag-todos))
#+END_SRC

* Yasnippet

#+BEGIN_SRC emacs-lisp
(use-package yasnippet-snippets
  :ensure t
  :after yasnippet
  :config (yas-reload-all))

(use-package yasnippet
  :ensure t
  :bind ("C-c y" . yas-expand)
  :diminish yas-minor-mode
  :init
  :config
  ;; (yas-global-mode 1)
  (add-hook 'prog-mode-hook (yas-minor-mode))
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil))
#+END_SRC

* Other window management
** Dired

#+BEGIN_SRC emacs-lisp
(use-package dired-subtree
  :ensure t
  :config
  (define-key dired-mode-map (kbd "<tab>") 'dired-subtree-toggle)
  (define-key dired-mode-map (kbd "TAB") 'dired-subtree-toggle))

(use-package dired-collapse
  :ensure t
  :config
  (define-key dired-mode-map (kbd "/") 'dired-collapse-mode))

(defun my/dired-find-file-ace ()
  (interactive)
  (let ((find-file-run-dired t)
        (fname (dired-get-file-for-visit)))
    (if (ace-select-window)
        (find-file fname))))

(defun my/dired-persistent-buffer ()
  (interactive)
  (call-interactively 'dired)
  (use-local-map (copy-keymap dired-mode-map))
  (local-set-key (kbd "RET") #'my/dired-find-file-ace))

(with-eval-after-load 'dired
  (define-key dired-mode-map
    (kbd "C-c v")
    (my/control-function-window-split
     dired-find-file-other-window
     nil 0))
  (define-key dired-mode-map
    (kbd "C-c s")
    (my/control-function-window-split
     dired-find-file-other-window
     0 nil))
  (define-key dired-mode-map
    (kbd "C-c n")
    'my/dired-find-file-ace))

(require 'dired-x)
(if is-mac (setq dired-use-ls-dired nil))
#+END_SRC

** ibuffer

   #+begin_src emacs-lisp
;; `/ R` to toggle showing these groups
;; `/ \` to disable
(setq-default ibuffer-saved-filter-groups
              `(("Default"
                 ("Ag" (name . "\*ag .*\*"))
                 ("Dired" (mode . dired-mode))
                 ("Scratch" (name . "\*scratch.*"))
                 ("Temporary" (name . "\*.*\*"))
                 )))
(setq ibuffer-show-empty-filter-groups nil)

(use-package ibuffer
  :config
  (define-key ibuffer-mode-map (kbd "M-o") nil))

(add-hook 'ibuffer-mode-hook
          '(lambda ()
             (ibuffer-auto-mode 1)))
   #+end_src

** Avy

#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :bind ("C-c i" . avy-goto-line))
#+END_SRC
    
** Ace-window

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :bind ("C-c o" . ace-window)
  :config
  (setq aw-dispatch-always t)
  (custom-set-faces
   '(aw-leading-char-face ((t (:foreground "magenta" :background "gray16" :weight bold :height 1.8))))))
#+END_SRC

** Treemacs
   
#+BEGIN_SRC emacs-lisp
(use-package treemacs-projectile
  :ensure t
  :after treemacs)

(use-package treemacs
  :if (>= emacs-major-version 25)
  :ensure t
  :bind ("M-0" . my/treemacs-smart-toggle)
  :config
  (setq treemacs-follow-mode t
        treemacs-filewatch-mode t
        treemacs-silent-refresh t)
  (treemacs-git-mode 'simple)
  (define-key treemacs-mode-map (kbd "C-p") 'treemacs-previous-line)
  (define-key treemacs-mode-map (kbd "C-n") 'treemacs-next-line)
  (defun my/treemacs-smart-toggle ()
    (interactive)
    (if (string-match-p
         (regexp-quote treemacs--buffer-name-prefix)
         (buffer-name (current-buffer)))
        (treemacs)
      (treemacs-select-window)))
  (defun my/kill-all-treemacs-buffers ()
    (if (eq (treemacs-current-visibility) 'visible)
        (dolist (buf (buffer-list))
          (progn
            (if (string-match-p
                 (regexp-quote treemacs--buffer-name-prefix) (buffer-name buf))
                (kill-buffer buf))))))
  ;; it breaks persp-mode otherwise
  (defadvice persp-switch
      (before advice-for-persp-switch activate)
    (my/kill-all-treemacs-buffers)))
#+END_SRC

** buffer-move

#+BEGIN_SRC emacs-lisp
(use-package buffer-move
  :ensure t
  :bind (("<C-S-up>" . buf-move-up)
         ("<C-S-down>" . buf-move-down)
         ("<C-S-left>" . buf-move-left)
         ("<C-S-right>" . buf-move-right)))
#+END_SRC

** zoom

#+begin_src emacs-lisp
(use-package zoom
  :ensure t
  :bind ("M-+" . zoom)
  :config
  (setq zoom-size '(190 . 92)))
#+end_src

* Other major modes
** PDF tools

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :ensure t
  :defer t
  :init
  (pdf-tools-install)
  :config
  ;; temporary - will investigate breaking changes
  (define-key pdf-view-mode-map (kbd "j") 'pdf-view-next-line-or-next-page)
  (define-key pdf-view-mode-map (kbd "k") 'pdf-view-previous-line-or-previous-page)
  (define-key pdf-view-mode-map (kbd "h") 'image-backward-hscroll)
  (define-key pdf-view-mode-map (kbd "l") 'image-forward-hscroll)
  (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)  ;; don't use swiper
  (with-eval-after-load 'pdf-outline
    (define-key pdf-outline-buffer-mode-map (kbd "<backtab>") 'outline-hide-sublevels))
  (add-hook
   'pdf-tools-enabled-hook
   (lambda ()
     ;; (setq pdf-view-midnight-colors '("#dcdccc" . "#383838"))
     (setq pdf-view-midnight-colors '("#a2d8d5" . "#0a3749")))))
#+END_SRC

** deft

#+begin_src emacs-lisp
(use-package deft
  :ensure t
  :bind ("<f8>" . deft)
  :commands (deft)
  :init
  (setq deft-extensions '("md" "org" "txt")))
#+end_src

** elfeed
   
#+BEGIN_SRC emacs-lisp
(use-package elfeed-web
  :ensure t
  :defer elfeed)

(use-package elfeed-goodies
  :ensure t
  :defer elfeed)

(use-package elfeed
  :ensure t
  :defer t
  :config
  (setq elfeed-search-filter "@10-days-ago +unread")
  (define-key elfeed-search-mode-map (kbd "U") #'elfeed-update)
  (setq
   elfeed-feeds
   '(
     "http://xkcd.com/rss.xml"
     "https://idontgetoutmuch.wordpress.com/feed"
     "http://jr0cket.co.uk/atom.xml"
     "http://www.howardism.org/index.xml"
     "https://harryrschwartz.com/atom.xml"
     "http://lucumr.pocoo.org/feed.atom"
     "https://www.joelonsoftware.com/feed/"
     "http://lambdafoo.com/atom.xml"
     "http://www.rntz.net/blog/atom.xml"
     "https://jacobian.org/feed.xml"
     "https://accidentallyquadratic.tumblr.com/rss"
     "http://blog.acolyer.org/feed/"
     "http://jakevdp.github.io/feeds/all.atom.xml"
     "http://www.usrsb.in/rss.xml"
     "https://dev.to/feed"
     "https://eli.thegreenplace.net/feeds/all.atom.xml"
     "https://www.peterbe.com/rss.xml"

     ;; Microservices, DDD etc
     "https://microservices.io/feed.xml"

     ;; Emacs
     "http://nullprogram.com/feed/"
     "http://endlessparentheses.com/atom.xml"
     "http://irreal.org/blog/?feed=rss2"
     "https://ekaschalk.github.io/index.xml"
     "http://oremacs.com/atom.xml"
     "https://emacs.cafe/feed.xml"

     ;; FP
     "http://www.haskellforall.com/feeds/posts/default"
     "http://jaspervdj.be/rss.xml"
     "http://neilmitchell.blogspot.com/feeds/posts/default"
     "https://blog.qfpl.io/rss.xml"
     "http://bitemyapp.com/rss.xml"
     "http://feeds.feedburner.com/incodeblog"
     "http://www.tomharding.me/atom.xml"
     "http://www.serpentine.com/blog/feed/"
     "http://reasonablypolymorphic.com/atom.xml"
     "https://chrispenner.ca/atom.xml"
     "https://bartoszmilewski.com/feed/"
     "https://doisinkidney.com/rss.xml"
     "http://planet.haskell.org/rss20.xml"
     "http://fpcomplete.com/feed/"
     "http://taylor.fausak.me/sitemap.atom"
     "http://argumatronic.com/rss.xml"
     "https://teh.id.au/posts/atom.xml"

     ;; Podcasts
     "http://www.magicreadalong.com/episode?format=rss"

     ;; News

     ;; Comics
     "https://www.monkeyuser.com/feed.xml"

     ;; Infosec
     "https://blog.g0tmi1k.com/atom.xml"
     )))
#+END_SRC

** restclient

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :ensure t
  :mode ("\\.http\\'" . restclient-mode)
  :config
  (add-hook 'restclient-mode-hook 'evil-local-mode))
#+END_SRC

** Ledger

#+BEGIN_SRC emacs-lisp
(use-package ledger-mode
  :ensure t
  :mode ("\\.hledger\\..*\\'" . ledger-mode)
  :init
  (setq ledger-mode-should-check-version nil
        ledger-report-links-in-register nil
        ledger-binary-path "hledger"))
#+END_SRC

** mu4e
   
#+BEGIN_SRC emacs-lisp :tangle no
(if is-mac
    (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu/mu4e")
  (progn
    (defvar mu-prefix (expand-file-name "~/opt/mu"))
    (add-to-list 'load-path (concat mu-prefix "/share/emacs/site-lisp/mu4e"))
    (setq mu4e-mu-binary (concat mu-prefix "/bin/mu"))))

(defvar mu-prefix (expand-file-name "~/opt/mu"))
(add-to-list 'load-path (concat mu-prefix "/share/emacs/site-lisp/mu4e"))
(setq mu4e-mu-binary (concat mu-prefix "/bin/mu"))
(setq mu4e-get-mail-command "offlineimap -o")
(require 'mu4e)
(setq mu4e-contexts
      `( ,(make-mu4e-context
           :name "Gmail"
           :match-func
           (lambda (msg)
             (when msg
               (string-prefix-p "/Gmail" (mu4e-message-field msg :maildir))))
           :vars '(
                   (mu4e-trash-folder . "/Gmail/[Gmail].Trash")
                   (mu4e-refile-folder . "/Gmail/[Gmail].Archive")
                   (mu4e-drafts-folder . "/Gmail/[Gmail].Drafts")
                   (mu4e-sent-folder . "/Gmail/[Gmail].Sent Mail")
                   ))))
;; smtpmail
(require 'smtpmail)
(setq message-send-mail-function 'smtpmail-send-it
      smtpmail-stream-type 'starttls
      smtpmail-default-smtp-server "smtp.gmail.com"
      smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-smtp-user "alexpeitsinis@gmail.com"
      smtpmail-smtp-service 587)
#+END_SRC

** erc

#+BEGIN_SRC emacs-lisp
(use-package erc
  :defer t
  :config
  (setq erc-rename-buffers t
        erc-interpret-mirc-color t
        erc-lurker-hide-list '("JOIN" "PART" "QUIT")
        erc-autojoin-channels-alist '(("freenode.net" "#haskell")))

  (defun my/erc-freenode ()
    (interactive)
    (erc :server "irc.freenode.net" :port 6667 :nick "runforestrun"))

  (defun my/erc-switch-to-buffer ()
    (interactive)
    (let ((read-buffer-function nil))
      (call-interactively 'erc-switch-to-buffer)))
  (define-key erc-mode-map (kbd "C-c C-b") 'my/erc-switch-to-buffer))
#+END_SRC

* Other minor modes
** direnv

#+begin_src emacs-lisp :tangle no
(use-package direnv
  :if (executable-find "direnv")
  :ensure t
  :init
  (setq direnv-show-paths-in-summary nil)
  :config
  (direnv-mode))
#+end_src

* Modeline
** Regular modeline
  
# Copied from spacemacs

#+BEGIN_SRC emacs-lisp
(defface modeline-flycheck-error
  '((t (:foreground "#e05e5e" :distant-foreground "#e05e5e")))
  "Face for flycheck error feedback in the modeline."
  :group 'modeline-flycheck)
(defface modeline-flycheck-warning
  '((t (:foreground "#bfb03d" :distant-foreground "#bfb03d")))
  "Face for flycheck warning feedback in the modeline."
  :group 'modeline-flycheck)
(defface modeline-flycheck-info
  '((t (:foreground "DeepSkyBlue3" :distant-foreground "DeepSkyBlue3")))
  "Face for flycheck info feedback in the modeline."
  :group 'modeline-flycheck)

(defun my/modeline-flycheck-darker-faces ()
  (custom-theme-set-faces
   my/theme
   '(modeline-flycheck-error ((t (:foreground "#c63d3d" :distant-foreground "#c63d3d"))))
   '(modeline-flycheck-warning ((t (:foreground "#84781a" :distant-foreground "#84781a"))))
   '(modeline-flycheck-info ((t (:foreground "DeepSkyBlue4" :distant-foreground "DeepSkyBlue4"))))
   ))

(defvar modeline-flycheck-bullet "•%s")

(defun my/mode-line-flycheck-state (state)
  (let* ((counts (flycheck-count-errors flycheck-current-errors))
         (errorp (flycheck-has-current-errors-p state))
         (err (or (cdr (assq state counts)) "?"))
         (running (eq 'running flycheck-last-status-change))
         (face (intern (format "modeline-flycheck-%S" state))))
    (if (or errorp running)
        (propertize (format modeline-flycheck-bullet err) 'face face))))

(defun my/mode-line-flycheck ()
  (let* ((ml-error (my/mode-line-flycheck-state 'error))
         (ml-warning (my/mode-line-flycheck-state 'warning))
         (ml-info (my/mode-line-flycheck-state 'info))
         (ml-status (concat ml-error ml-warning ml-info)))
    (if (null ml-status) "" (concat " " ml-status " "))))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(setq-default mode-line-format
              '("%e"
                mode-line-front-space
                ;; evil-mode-line-tag
                mode-line-mule-info
                mode-line-client mode-line-modified mode-line-remote
                mode-line-frame-identification mode-line-buffer-identification " "
                mode-line-position
                (vc-mode vc-mode)
                (:eval (my/mode-line-flycheck))
                (:eval (my/mode-line-venv))
                mode-line-modes mode-line-misc-info mode-line-end-spaces))

(setq mode-line-misc-info
      (cons '(:eval (if (window-dedicated-p) "× " "")) mode-line-misc-info))
#+END_SRC

** Experimental new modeline

#+BEGIN_SRC emacs-lisp :tangle no
(defun my/split-mode-line-render (left right)
  "Return a string of `window-width' length containing LEFT, and RIGHT aligned respectively."
  (let* ((available-width (- (window-total-width)
                             (+ (length (format-mode-line left))
                                (length (format-mode-line right))))))
    (append left
            (list
             (format
              (format "%%%ds" available-width) ""))
            right)))

(setq global-mode-string (delete '(:eval (persp-mode-line)) global-mode-string))
(require 'powerline)

(defun my/mode-line-hud ()
  (let* ((active (eq my/-selected-window (selected-window)))
         (face0 (if active 'powerline-active0 'powerline-inactive0))
         (face2 (if active 'powerline-active2 'powerline-inactive2)))
    (pl/render (powerline-hud face0 face2))))

(setq-default
 mode-line-format
 '((:eval
    (my/split-mode-line-render
     ;; left
     (quote
      ("%e"
       evil-mode-line-tag " "
       mode-line-mule-info
       mode-line-client mode-line-modified mode-line-remote "  "
       mode-line-buffer-identification " "
       mode-line-position
       ;; (vc-mode vc-mode)
       (:eval (my/mode-line-flycheck))
       (:eval (my/mode-line-venv))
       mode-line-modes
       mode-line-misc-info
       ))
     ;; right
     (quote
      (
       (:eval (frame-parameter nil 'persp--modestring)) " "
       ;; (:eval (pl/render (powerline-hud 'powerline-active0 'powerline-active2)))
       (:eval (my/mode-line-hud))
       "  "
       ))
     ))))
#+END_SRC

** Be able to tell which modeline is active

#+BEGIN_SRC emacs-lisp :tangle no
;; is window selected?
(defvar my/-selected-window nil)
;; (add-hook 'post-command-hook '(lambda () (setq my/-selected-window (selected-window))))
(add-hook 'post-command-hook
          '(lambda ()
             (when (not (minibuffer-window-active-p (selected-window)))
               (setq my/-selected-window (selected-window)))))
(add-hook 'buffer-list-update-hook '(lambda () (force-mode-line-update t)))

;; is emacs focused?
(defvar my/-focused-in t)
(add-hook 'focus-in-hook '(lambda () (setq my/-focused-in t)))
(add-hook 'focus-out-hook '(lambda () (setq my/-focused-in nil)))

(defun my/current-window-active-p ()
  (and my/-focused-in
       (eq my/-selected-window (selected-window))))
#+END_SRC

** Powerline

#+BEGIN_SRC emacs-lisp :tangle no
(use-package powerline
  :ensure t
  :config
  (powerline-default-theme)
  (setq flycheck-mode-line '(:eval (my/mode-line-flycheck)))
  (diminish-undo 'flycheck-mode)
  (setq global-mode-string
        (append global-mode-string '((:eval (my/mode-line-venv)))))
  (add-hook 'my/after-set-theme-hook 'powerline-reset)
  (setq global-mode-string
        (cons '(:eval (if (window-dedicated-p) "× " "")) global-mode-string)))

;; Try this to see if it fixes powerline hiccups
(defun powerline-selected-window-active ()
  "Return whether the current window is active."
  (my/current-window-active-p))
#+END_SRC

** Spaceline

#+BEGIN_SRC emacs-lisp :tangle no
(use-package spaceline
  :ensure t
  :init
  (require 'spaceline-config)
  (setq powerline-default-separator 'arrow
        powerline-height nil
        spaceline-highlight-face-func 'spaceline-highlight-face-modified)
  ;; (spaceline-toggle-buffer-encoding-abbrev-off)
  (spaceline-toggle-buffer-size-off)
  (spaceline-toggle-anzu-off)
  (spaceline-emacs-theme)
  ;; (custom-set-faces
  ;;  '(spaceline-unmodified
  ;;    ((t (:inherit mode-line :background "DarkOrange" :foreground "#3e3d31")))))
  )
#+END_SRC

* Org-mode
   
#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cc" 'org-capture)
(global-set-key "\C-cb" 'org-iswitchb)

(setq org-log-done 'time
      org-confirm-babel-evaluate nil
      org-clock-into-drawer nil
      org-src-fontify-natively t
      org-src-preserve-indentation t
      org-src-tab-acts-natively t
      org-src-window-setup 'other-window
      org-hide-leading-stars t
      org-adapt-indentation nil
      org-directory (expand-file-name "~/org/")
      org-default-notes-file (concat org-directory "notes.org")
      org-ellipsis "…"
      org-todo-keywords '((sequence "TODO" "IN PROGRESS" "|" "DONE"))
      org-todo-keyword-faces '(("IN PROGRESS" . (:foreground "DarkOrange3" :weight bold)))
      )

;; org-capture
(setq org-capture-templates
      '(("c"
         "Code comment"
         entry
         (file+headline org-default-notes-file "Code comments")
         "\n\n* %?\n\n#+BEGIN_SRC %^{Language}\n%i\n#+END_SRC\n\n%a\n")))

;; format string used when creating CLOCKSUM lines and when generating a
;; time duration (avoid showing days)
(setq org-time-clocksum-format
      '(:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t))

(defun my/org-insert-template ()
  (interactive)
  (let* ((templ-dir (expand-file-name "~/.emacs.d/org-templates/"))
         (ls (directory-files templ-dir nil "^[^.]"))
         (file (completing-read "Template: " ls))
         (path (concat templ-dir file)))
    (insert-file-contents path)))

(defun my/org-set-src-faces (&optional light-bg th)
  (let* ((func (if light-bg 'color-darken-name 'color-lighten-name))
         (rfunc (if light-bg 'color-lighten-name 'color-darken-name))
         (bg (face-attribute 'default :background))
         (bg+ (funcall func bg 1))
         (bg++ (funcall func bg 4.5))
         (fg (face-attribute 'default :foreground))
         (theme (if th th my/theme))
         (cur-line-fg (face-attribute 'org-block-begin-line :foreground nil t))
         (cur-block-fg (funcall rfunc (face-attribute 'default :foreground nil t) 11))
         )
    (custom-theme-set-faces
     theme
     `(org-block ((t (:background ,bg+ :foreground ,cur-block-fg))))
     `(org-block-begin-line ((t (:background ,bg++ :foreground ,cur-line-fg))))
     `(org-block-end-line ((t (:background ,bg++ :foreground ,cur-line-fg)))))))

;; (use-package graphviz-dot-mode :ensure t)

(org-babel-do-load-languages
 'org-babel-load-languages
 '((python . t)
   ;; (ipython . t)
   (haskell . t)
   ;; (dot . t)
   ;; (restclient . t)
   ))

(add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)
(add-hook
 'org-mode-hook
 (lambda ()
   (use-package ox-twbs :ensure t)
   ;; (use-package ox-reveal :ensure t)
   (use-package org-bullets :ensure t :config (org-bullets-mode))

   (define-key org-mode-map (kbd "TAB") 'org-cycle)
   ;; (define-key evil-normal-state-map (kbd "TAB") 'org-cycle)

   (my/set-mode-fill-width 'org-mode-hook 100)

   (if (require 'org-tempo nil 'noerror)
       (add-to-list
        'org-structure-template-alist
        '("pr" . "preview"))
     (add-to-list
      'org-structure-template-alist
      '("pr" . "#+BEGIN_PREVIEW\n?\n#+END_PREVIEW")))
   ))
#+END_SRC
   
* Setup
** Per-workstation setup

#+BEGIN_SRC emacs-lisp
(defvar my/after-init-hook nil "Hook called after initialization")
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; these have to be paths to projects that projectile recognizes (e.g. git)
(defvar my/start-up-projects '())

(defun my/open-start-up-projects ()
  (unless (null my/start-up-projects)
    (let ((projectile-switch-project-action 'projectile-dired))
      (dolist (proj my/start-up-projects)
        (projectile-persp-switch-project proj)))
    (persp-switch "main")))

(add-hook 'my/after-init-hook 'my/open-start-up-projects)
#+END_SRC

# thanks Nicolas Petton
#+BEGIN_SRC emacs-lisp

(defvar my/hosts-dir (expand-file-name "~/.emacs.d/hosts/"))
(defvar my/hostname (substring (shell-command-to-string "hostname") 0 -1))
(let* ((host-file (concat my/hosts-dir "init-" my/hostname ".el")))
  (load-file host-file))
#+END_SRC

** Global setup
   
#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
;; (load custom-file 'noerror)

(setq x-underline-at-descent-line t)

(custom-set-faces
 '(anzu-mode-line ((t (:foreground "magenta" :weight bold))))
 '(anzu-mode-line-no-match ((t (:foreground "red" :weight bold))))
 '(fixed-pitch ((t nil)))
 '(flycheck-error ((t (:underline (:color "red1" :style wave)))))
 '(flycheck-fringe-error ((t (:foreground "#FB4933"))))
 '(flycheck-fringe-info ((t (:foreground "DeepSkyBlue2"))))
 '(flycheck-fringe-warning ((t (:foreground "orange1"))))
 '(flycheck-info ((t (:underline (:color "DeepSkyBlue2" :style wave)))))
 '(flycheck-warning ((t (:underline (:color "orange1" :style wave)))))
 '(whitespace-trailing ((t (:background "#602020")))))

(dolist (val '((eval . (setq flycheck-disabled-checkers
                             (append flycheck-disabled-checkers
                                     (quote
                                      (intero)))))
               (psc-ide-output-directory . "build/")
               (projectile-tags-command . "fast-tags -e -R -o %s --exclude=\"%s\" \"%s\"")
               (projectile-tags-command . "fast-tags -e -R .")
               (projectile-tags-command . "npm run etags")
               (haskell-hoogle-command . "stack hoogle -- --count=100")
               (my/use-intero . nil)
               ))
  (add-to-list 'safe-local-variable-values val))

(my/set-theme)
(my/set-font)

(unless (display-graphic-p)
  (set-face-attribute 'default nil :background "#222222"))

(setq linum-format 'dynamic)

(setq default-input-method "TeX")

(hybrid-mode)
(winner-mode)
(global-hi-lock-mode 1)
(define-key hi-lock-map (kbd "M-H") (lookup-key hi-lock-map (kbd "C-x w")))

;; I have to put it here in order to use hi-lock-map for some reason
(use-package symbol-overlay
  :ensure t
  :diminish
  :config
  (define-globalized-minor-mode global-symbol-overlay-mode
    symbol-overlay-mode symbol-overlay-mode)
  ;; (define-key symbol-overlay-map (kbd "d") 'symbol-overlay-remove-all)
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd ",i") 'symbol-overlay-put)
    (define-key map (kbd ",d") 'symbol-overlay-remove-all)
    (define-key map (kbd "n") 'symbol-overlay-jump-next)
    (define-key map (kbd "p") 'symbol-overlay-jump-prev)
    (define-key map (kbd ",q") 'symbol-overlay-query-replace)
    (define-key map (kbd ",r") 'symbol-overlay-rename)
    (define-key map (kbd ",w") 'symbol-overlay-save-symbol)
    (define-key map (kbd ",s") 'symbol-overlay-isearch-literally)
    (setq symbol-overlay-map map))
  (global-set-key (kbd "M-H s") 'symbol-overlay-put)
  (global-set-key (kbd "M-H d") 'symbol-overlay-remove-all))
;; (setq remember-notes-initial-major-mode 'org-mode)
;; (add-to-list 'remember-handler-functions 'remember-diary-extract-entries)


(when (fboundp 'treemacs--setup-icon-background-colors)
  (treemacs--setup-icon-background-colors))

(run-hooks 'my/after-init-hook)
#+END_SRC

